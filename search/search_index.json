{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyDMConverter","text":"<p>PyDMConverter is a PyDM-based tool developed at SLAC National Accelerator Laboratory. PyDMConverter has been built to convert files from other display managers into PyDM's .ui file format. Currently the converter only supports converting from EDM's .edl format the PyDM .ui format.</p>"},{"location":"arguments/","title":"Arguments","text":"<p>Pydmconverter supports a few optional startup arguments that allow users to execute specific actions when running the converter.</p> <p>Below, you'll find a detailed overview of each available argument to help you use the converter as you need to.</p>"},{"location":"arguments/#override","title":"Override","text":"<p><code>-o</code> or <code>--override</code></p> <p>This argument allows users to override the output file if it already exists. Most often this will be used with the scroll bar argument if it appears a screen exceeds the screen. This will replace the file with a new converted file.</p>"},{"location":"arguments/#scroll-bars","title":"Scroll Bars","text":"<p><code>-s</code> or <code>--scrollable</code></p> <p>This argument adds scroll bars to converted screens. It will ad a horizontal and vertical scroll bar. If this argument is not included, the screen will not contain a scroll bar.</p>"},{"location":"arguments/#help","title":"Help","text":"<p><code>-h</code> or <code>--help</code></p> <p>This argument shows the converter's help message, which outlines the available arguments for users.</p>"},{"location":"user_guide/","title":"Installation","text":""},{"location":"user_guide/#prerequisites","title":"Prerequisites","text":""},{"location":"user_guide/#installation-methods","title":"Installation Methods","text":""},{"location":"user_guide/#option-1-install-from-pypi-recommended","title":"Option 1: Install from PyPI (Recommended)","text":"<p>The easiest way to install the converter is directly from PyPI: <pre><code>pip install PyDMConverter\n</code></pre></p>"},{"location":"user_guide/#option-2-install-from-source","title":"Option 2: Install from Source","text":"<p>If you need the latest development version or want to contribute:</p>"},{"location":"user_guide/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/slaclab/pydm-converter-tool.git\ncd pydm-converter-tool\n</code></pre>"},{"location":"user_guide/#set-up-environment","title":"Set up Environment","text":"<p>Using <code>conda</code>: <pre><code>conda env create -f environment.yml\nconda activate pydm\n</code></pre></p> <p>Or using pip: <pre><code>pip install -e .\n</code></pre></p>"},{"location":"user_guide/#how-to-run-the-converter","title":"How to Run the Converter","text":"<p>The converter can be run in two ways: via the command line interface (CLI) or through the graphical user interface (GUI).</p>"},{"location":"user_guide/#launch-the-gui","title":"Launch the GUI","text":"<p>To launch the graphical interface: <pre><code>pydmconverter\n</code></pre></p> <p>This will open the PyDM Converter GUI where you can: - Select files or folders to convert</p>"},{"location":"user_guide/#command-line-interface","title":"Command Line Interface","text":"<p>The CLI provides two main ways to run the converter: on individual files and entire folders. Users can include additional arguments described on the Arguments page.</p>"},{"location":"user_guide/#for-individual-files","title":"For individual files","text":"<p>When using the converter on a single file, the command line is: <pre><code>pydmconverter '/path/old_file.edl' 'new_file_name.ui' `\n</code></pre></p>"},{"location":"user_guide/#for-an-entire-folder","title":"For an entire folder","text":"<p>When converting an entire folder, the command line is: <pre><code>pydmconverter '/path_to_old_directory' '/new_file_location' 'old_file_type'\n</code></pre></p>"},{"location":"user_guide/#examples","title":"Examples","text":"<p>To convert EDM file called \"file.edl\" to PYDM file called \"file.ui\" : <pre><code>pydmconverter /afs/slac/g/lcls/edm/file.edl file.ui`\n</code></pre> To convert EDM files in a folder called \"edm\" to PYDM file in the current folder : <pre><code>pydmconverter /afs/slac/g/lcls/edm . .edl`\n</code></pre></p>"},{"location":"reference/","title":"Developer Reference","text":"<p>Welcome to the PyDMConverter Developer Reference. This section provides comprehensive documentation for the internal Python modules, classes, and functions that make up the PyDMConverter application. Here you will find detailed descriptions of each component, including their parameters, return values, and usage examples.</p> <p>Use this reference to:</p> <ul> <li>Understand the structure and functionality of PyDMConverter\u2019s codebase</li> <li>Integrate or extend PyDMConverter with your own scripts or plugins</li> <li>Explore available widgets, file I/O utilities, and service modules</li> </ul> <p>Browse the subpages for specific modules and components. For guidance on using the application, see the user documentation in the main sections.</p>"},{"location":"reference/custom_types/","title":"Custom Types","text":""},{"location":"reference/widgets/","title":"Widgets","text":""},{"location":"reference/widgets/#widgets.PyDMByteIndicator","title":"<code>PyDMByteIndicator</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code></p> <p>Represents a widget that displays a multi-bit (byte) indicator.</p> <p>Attributes:</p> Name Type Description <code>numBits</code> <code>Optional[int]</code> <p>Number of bits to display.</p> <code>showLabels</code> <code>Optional[bool]</code> <p>Whether to show bit labels.</p> <code>on_color</code> <code>Optional[RGBA]</code> <p>RGBA color when a bit is on.</p> <code>off_color</code> <code>Optional[RGBA]</code> <p>RGBA color when a bit is off.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMByteIndicator(Alarmable):\n    \"\"\"\n    Represents a widget that displays a multi-bit (byte) indicator.\n\n    Attributes:\n        numBits (Optional[int]): Number of bits to display.\n        showLabels (Optional[bool]): Whether to show bit labels.\n        on_color (Optional[RGBA]): RGBA color when a bit is on.\n        off_color (Optional[RGBA]): RGBA color when a bit is off.\n    \"\"\"\n\n    numBits: Optional[int] = None\n    showLabels: Optional[bool] = None\n    on_color: Optional[RGBA] = None\n    off_color: Optional[RGBA] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generates a list of XML elements representing the byte indicator's properties.\n\n        Returns:\n            List[ET.Element]: List of XML elements for serialization.\n        \"\"\"\n\n        properties: List[ET.Element] = super().generate_properties()\n\n        if self.numBits is not None:\n            properties.append(Int(\"numBits\", self.numBits).to_xml())\n        if self.showLabels is not None:\n            properties.append(Bool(\"showLabels\", self.showLabels).to_xml())\n        if self.on_color is not None:\n            properties.append(OnOffColor(\"on\", *self.on_color).to_xml())\n        if self.off_color is not None:\n            properties.append(OnOffColor(\"off\", *self.off_color).to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMByteIndicator.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generates a list of XML elements representing the byte indicator's properties.</p> <p>Returns:</p> Type Description <code>List[Element]</code> <p>List[ET.Element]: List of XML elements for serialization.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generates a list of XML elements representing the byte indicator's properties.\n\n    Returns:\n        List[ET.Element]: List of XML elements for serialization.\n    \"\"\"\n\n    properties: List[ET.Element] = super().generate_properties()\n\n    if self.numBits is not None:\n        properties.append(Int(\"numBits\", self.numBits).to_xml())\n    if self.showLabels is not None:\n        properties.append(Bool(\"showLabels\", self.showLabels).to_xml())\n    if self.on_color is not None:\n        properties.append(OnOffColor(\"on\", *self.on_color).to_xml())\n    if self.off_color is not None:\n        properties.append(OnOffColor(\"off\", *self.off_color).to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingArc","title":"<code>PyDMDrawingArc</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code>, <code>Drawable</code>, <code>Hidable</code>, <code>StyleSheetObject</code></p> <p>PyDMDrawingArc represents a drawable ellipse that supports XML serialization, alarm functionality, and can be hidden.</p> <p>This class does not add any extra properties beyond those provided by its base classes.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMDrawingArc(Alarmable, Drawable, Hidable, StyleSheetObject):\n    \"\"\"\n    PyDMDrawingArc represents a drawable ellipse that supports XML serialization,\n    alarm functionality, and can be hidden.\n\n    This class does not add any extra properties beyond those provided by its base classes.\n    \"\"\"\n\n    startAngle: Optional[float] = None\n    spanAngle: Optional[int] = 180\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate XML properties for the drawable widget.\n\n        Returns\n        -------\n        List[etree.Element]\n            A list containing arc properties.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n        if self.startAngle is not None:\n            properties.append(\n                Double(\"startAngle\", self.startAngle).to_xml()\n            )  # TODO: Maybe make a float class (probabaly unnecessary)\n        properties.append(Int(\"spanAngle\", self.spanAngle).to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingArc.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate XML properties for the drawable widget.</p>"},{"location":"reference/widgets/#widgets.PyDMDrawingArc.generate_properties--returns","title":"Returns","text":"<p>List[etree.Element]     A list containing arc properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate XML properties for the drawable widget.\n\n    Returns\n    -------\n    List[etree.Element]\n        A list containing arc properties.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n    if self.startAngle is not None:\n        properties.append(\n            Double(\"startAngle\", self.startAngle).to_xml()\n        )  # TODO: Maybe make a float class (probabaly unnecessary)\n    properties.append(Int(\"spanAngle\", self.spanAngle).to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingEllipse","title":"<code>PyDMDrawingEllipse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code>, <code>Drawable</code>, <code>Hidable</code>, <code>StyleSheetObject</code></p> <p>PyDMDrawingEllipse represents a drawable ellipse that supports XML serialization, alarm functionality, and can be hidden.</p> <p>This class does not add any extra properties beyond those provided by its base classes.</p>"},{"location":"reference/widgets/#widgets.PyDMDrawingEllipse--attributes","title":"Attributes","text":"<p>count : ClassVar[int]     A class variable tracking the number of PyDMDrawingEllipse instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMDrawingEllipse(Alarmable, Drawable, Hidable, StyleSheetObject):\n    \"\"\"\n    PyDMDrawingEllipse represents a drawable ellipse that supports XML serialization,\n    alarm functionality, and can be hidden.\n\n    This class does not add any extra properties beyond those provided by its base classes.\n\n    Attributes\n    ----------\n    count : ClassVar[int]\n        A class variable tracking the number of PyDMDrawingEllipse instances.\n    \"\"\"\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingIrregularPolygon","title":"<code>PyDMDrawingIrregularPolygon</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code>, <code>Drawable</code>, <code>Hidable</code></p> <p>PyDMDrawingIrregularPolygon represents a filled irregular polygon defined by points. The first and last points must be the same to close the shape, creating a defined inside and outside that can be filled with color.</p>"},{"location":"reference/widgets/#widgets.PyDMDrawingIrregularPolygon--attributes","title":"Attributes","text":"<p>points : Optional[List[str]]     A list of point strings in the format \"x, y\". First and last points should match     to close the polygon. count : ClassVar[int]     Class variable tracking the number of PyDMDrawingIrregularPolygon instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMDrawingIrregularPolygon(Alarmable, Drawable, Hidable):\n    \"\"\"\n    PyDMDrawingIrregularPolygon represents a filled irregular polygon defined by points.\n    The first and last points must be the same to close the shape, creating a defined\n    inside and outside that can be filled with color.\n\n    Attributes\n    ----------\n    points : Optional[List[str]]\n        A list of point strings in the format \"x, y\". First and last points should match\n        to close the polygon.\n    count : ClassVar[int]\n        Class variable tracking the number of PyDMDrawingIrregularPolygon instances.\n    \"\"\"\n\n    points: Optional[List[str]] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMDrawingIrregularPolygon-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the PyDMDrawingIrregularPolygon properties.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n\n        # Always add transparent background for widget itself (not the polygon fill)\n        # This ensures the rectangular widget background doesn't obstruct other widgets\n        # The polygon shape will still be filled via the brush property\n        from pydmconverter.widgets_helpers import TransparentBackground\n\n        properties.append(TransparentBackground().to_xml())\n\n        if self.points is not None:\n            points_prop = ET.Element(\"property\", attrib={\"name\": \"points\", \"stdset\": \"0\"})\n            stringlist = ET.SubElement(points_prop, \"stringlist\")\n\n            for point in self.points:\n                string_el = ET.SubElement(stringlist, \"string\")\n                string_el.text = point\n\n            # Ensure polygon is closed (first point == last point)\n            if self.points and self.points[0] != self.points[-1]:\n                string_el = ET.SubElement(stringlist, \"string\")\n                string_el.text = self.points[0]  # Add first point again to close\n\n            properties.append(points_prop)\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingIrregularPolygon.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMDrawingIrregularPolygon-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.PyDMDrawingIrregularPolygon.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the PyDMDrawingIrregularPolygon properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMDrawingIrregularPolygon-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the PyDMDrawingIrregularPolygon properties.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n\n    # Always add transparent background for widget itself (not the polygon fill)\n    # This ensures the rectangular widget background doesn't obstruct other widgets\n    # The polygon shape will still be filled via the brush property\n    from pydmconverter.widgets_helpers import TransparentBackground\n\n    properties.append(TransparentBackground().to_xml())\n\n    if self.points is not None:\n        points_prop = ET.Element(\"property\", attrib={\"name\": \"points\", \"stdset\": \"0\"})\n        stringlist = ET.SubElement(points_prop, \"stringlist\")\n\n        for point in self.points:\n            string_el = ET.SubElement(stringlist, \"string\")\n            string_el.text = point\n\n        # Ensure polygon is closed (first point == last point)\n        if self.points and self.points[0] != self.points[-1]:\n            string_el = ET.SubElement(stringlist, \"string\")\n            string_el.text = self.points[0]  # Add first point again to close\n\n        properties.append(points_prop)\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingLine","title":"<code>PyDMDrawingLine</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Legible</code>, <code>Drawable</code>, <code>Alarmable</code></p> <p>PyDMDrawingLine represents a drawable line with arrow properties.</p>"},{"location":"reference/widgets/#widgets.PyDMDrawingLine--attributes","title":"Attributes","text":"<p>arrow_size : Optional[int]     The size of the arrow. arrow_end_point : Optional[bool]     If True, draws an arrow at the end point. arrow_start_point : Optional[bool]     If True, draws an arrow at the start point. arrow_mid_point : Optional[bool]     If True, draws an arrow at the midpoint. flip_mid_point_arrow : Optional[bool]     If True, flips the midpoint arrow. count : ClassVar[int]     Class variable tracking the number of PyDMDrawingLine instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMDrawingLine(Legible, Drawable, Alarmable):\n    \"\"\"\n    PyDMDrawingLine represents a drawable line with arrow properties.\n\n    Attributes\n    ----------\n    arrow_size : Optional[int]\n        The size of the arrow.\n    arrow_end_point : Optional[bool]\n        If True, draws an arrow at the end point.\n    arrow_start_point : Optional[bool]\n        If True, draws an arrow at the start point.\n    arrow_mid_point : Optional[bool]\n        If True, draws an arrow at the midpoint.\n    flip_mid_point_arrow : Optional[bool]\n        If True, flips the midpoint arrow.\n    count : ClassVar[int]\n        Class variable tracking the number of PyDMDrawingLine instances.\n    \"\"\"\n\n    pen_width: Optional[int] = None\n    arrow_size: Optional[int] = None\n    arrow_end_point: Optional[bool] = None\n    arrow_start_point: Optional[bool] = None\n    arrow_mid_point: Optional[bool] = None\n    flip_mid_point_arrow: Optional[bool] = None\n    arrows: Optional[str] = None\n    penColor: Optional[RGBA] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMDrawingLine-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the PyDMDrawingLine properties.\n        \"\"\"\n        if self.arrows in (\"to\", \"from\", \"both\"):\n            self.brushFill = True\n            self.brushColor = self.penColor\n\n        properties: List[ET.Element] = super().generate_properties()\n        if self.pen_width is not None:\n            properties.append(Int(\"penWidth\", self.pen_width).to_xml())\n        if self.arrow_size is not None:\n            properties.append(Int(\"arrowSize\", self.arrow_size).to_xml())\n        if self.arrow_end_point is not None:\n            properties.append(Bool(\"arrowEndPoint\", self.arrow_end_point).to_xml())\n        if self.arrow_start_point is not None:\n            properties.append(Bool(\"arrowStartPoint\", self.arrow_start_point).to_xml())\n        if self.arrow_mid_point is not None:\n            properties.append(Bool(\"arrowMidPoint\", self.arrow_mid_point).to_xml())\n        if self.flip_mid_point_arrow is not None:\n            properties.append(Bool(\"flipMidPointArrow\", self.flip_mid_point_arrow).to_xml())\n        if self.arrows is not None and (self.arrows == \"both\" or self.arrows == \"to\"):\n            properties.append(Bool(\"arrowStartPoint\", True).to_xml())\n        if self.arrows is not None and (self.arrows == \"both\" or self.arrows == \"from\"):\n            properties.append(Bool(\"arrowEndPoint\", True).to_xml())\n        properties.append(TransparentBackground().to_xml())\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingLine.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMDrawingLine-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.PyDMDrawingLine.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the PyDMDrawingLine properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMDrawingLine-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the PyDMDrawingLine properties.\n    \"\"\"\n    if self.arrows in (\"to\", \"from\", \"both\"):\n        self.brushFill = True\n        self.brushColor = self.penColor\n\n    properties: List[ET.Element] = super().generate_properties()\n    if self.pen_width is not None:\n        properties.append(Int(\"penWidth\", self.pen_width).to_xml())\n    if self.arrow_size is not None:\n        properties.append(Int(\"arrowSize\", self.arrow_size).to_xml())\n    if self.arrow_end_point is not None:\n        properties.append(Bool(\"arrowEndPoint\", self.arrow_end_point).to_xml())\n    if self.arrow_start_point is not None:\n        properties.append(Bool(\"arrowStartPoint\", self.arrow_start_point).to_xml())\n    if self.arrow_mid_point is not None:\n        properties.append(Bool(\"arrowMidPoint\", self.arrow_mid_point).to_xml())\n    if self.flip_mid_point_arrow is not None:\n        properties.append(Bool(\"flipMidPointArrow\", self.flip_mid_point_arrow).to_xml())\n    if self.arrows is not None and (self.arrows == \"both\" or self.arrows == \"to\"):\n        properties.append(Bool(\"arrowStartPoint\", True).to_xml())\n    if self.arrows is not None and (self.arrows == \"both\" or self.arrows == \"from\"):\n        properties.append(Bool(\"arrowEndPoint\", True).to_xml())\n    properties.append(TransparentBackground().to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingPie","title":"<code>PyDMDrawingPie</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code>, <code>Drawable</code>, <code>Hidable</code>, <code>StyleSheetObject</code></p> <p>PyDMDrawingPie represents a filled pie/wedge shape that supports XML serialization, alarm functionality, and can be hidden.</p> <p>This is used for EDM arcs that have fill enabled.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMDrawingPie(Alarmable, Drawable, Hidable, StyleSheetObject):\n    \"\"\"\n    PyDMDrawingPie represents a filled pie/wedge shape that supports XML serialization,\n    alarm functionality, and can be hidden.\n\n    This is used for EDM arcs that have fill enabled.\n    \"\"\"\n\n    startAngle: Optional[float] = None\n    spanAngle: Optional[int] = 180\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate XML properties for the pie widget.\n\n        Returns\n        -------\n        List[etree.Element]\n            A list containing pie properties.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n        if self.startAngle is not None:\n            properties.append(Double(\"startAngle\", self.startAngle).to_xml())\n        properties.append(Int(\"spanAngle\", self.spanAngle).to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingPie.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate XML properties for the pie widget.</p>"},{"location":"reference/widgets/#widgets.PyDMDrawingPie.generate_properties--returns","title":"Returns","text":"<p>List[etree.Element]     A list containing pie properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate XML properties for the pie widget.\n\n    Returns\n    -------\n    List[etree.Element]\n        A list containing pie properties.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n    if self.startAngle is not None:\n        properties.append(Double(\"startAngle\", self.startAngle).to_xml())\n    properties.append(Int(\"spanAngle\", self.spanAngle).to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingPolyline","title":"<code>PyDMDrawingPolyline</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PyDMDrawingLine</code></p> <p>PyDMDrawingPolyline represents a drawable polyline defined by a sequence of points.</p>"},{"location":"reference/widgets/#widgets.PyDMDrawingPolyline--attributes","title":"Attributes","text":"<p>points : Optional[List[str]]     A list of point strings in the format \"x, y\". count : ClassVar[int]     Class variable tracking the number of PyDMDrawingPolyline instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMDrawingPolyline(PyDMDrawingLine):\n    \"\"\"\n    PyDMDrawingPolyline represents a drawable polyline defined by a sequence of points.\n\n    Attributes\n    ----------\n    points : Optional[List[str]]\n        A list of point strings in the format \"x, y\".\n    count : ClassVar[int]\n        Class variable tracking the number of PyDMDrawingPolyline instances.\n    \"\"\"\n\n    points: Optional[List[str]] = None\n    arrows: Optional[str] = None\n    closePolygon: Optional[bool] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMDrawingPolyline-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the PyDMDrawingPolyline properties.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n        if self.points is not None:\n            points_prop = ET.Element(\"property\", attrib={\"name\": \"points\", \"stdset\": \"0\"})\n            stringlist = ET.SubElement(points_prop, \"stringlist\")\n            for point in self.points:\n                string_el = ET.SubElement(stringlist, \"string\")\n                string_el.text = point  # Use points as-is, no offset adjustment\n\n            # If closePolygon is True, add the first point at the end to close the shape\n            if self.closePolygon is True:\n                # Only add closing point if first and last are different\n                if self.points and self.points[0] != self.points[-1]:\n                    string_el = ET.SubElement(stringlist, \"string\")\n                    string_el.text = self.points[0]  # Close polygon with first point\n\n            properties.append(points_prop)\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingPolyline.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMDrawingPolyline-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.PyDMDrawingPolyline.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the PyDMDrawingPolyline properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMDrawingPolyline-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the PyDMDrawingPolyline properties.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n    if self.points is not None:\n        points_prop = ET.Element(\"property\", attrib={\"name\": \"points\", \"stdset\": \"0\"})\n        stringlist = ET.SubElement(points_prop, \"stringlist\")\n        for point in self.points:\n            string_el = ET.SubElement(stringlist, \"string\")\n            string_el.text = point  # Use points as-is, no offset adjustment\n\n        # If closePolygon is True, add the first point at the end to close the shape\n        if self.closePolygon is True:\n            # Only add closing point if first and last are different\n            if self.points and self.points[0] != self.points[-1]:\n                string_el = ET.SubElement(stringlist, \"string\")\n                string_el.text = self.points[0]  # Close polygon with first point\n\n        properties.append(points_prop)\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingRectangle","title":"<code>PyDMDrawingRectangle</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code>, <code>Drawable</code>, <code>Hidable</code></p> <p>PyDMDrawingRectangle represents a drawable rectangle that supports XML serialization, alarm functionality, and can be hidden.</p>"},{"location":"reference/widgets/#widgets.PyDMDrawingRectangle--attributes","title":"Attributes","text":"<p>indicatorColor: Optional[RGBA]     The fill color for specifically activebar/slacbarclass rectangles</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMDrawingRectangle(Alarmable, Drawable, Hidable):\n    \"\"\"\n    PyDMDrawingRectangle represents a drawable rectangle that supports XML serialization,\n    alarm functionality, and can be hidden.\n\n    Attributes\n    ----------\n    indicatorColor: Optional[RGBA]\n        The fill color for specifically activebar/slacbarclass rectangles\n    \"\"\"\n\n    indicatorColor: Optional[RGBA] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate XML properties for the drawable widget.\n\n        Returns\n        -------\n        List[etree.Element]\n            A list containing geometry, pen, brush, and rotation properties.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n        if self.indicatorColor is not None:\n            properties.append(Brush(*self.indicatorColor, fill=True).to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMDrawingRectangle.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate XML properties for the drawable widget.</p>"},{"location":"reference/widgets/#widgets.PyDMDrawingRectangle.generate_properties--returns","title":"Returns","text":"<p>List[etree.Element]     A list containing geometry, pen, brush, and rotation properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate XML properties for the drawable widget.\n\n    Returns\n    -------\n    List[etree.Element]\n        A list containing geometry, pen, brush, and rotation properties.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n    if self.indicatorColor is not None:\n        properties.append(Brush(*self.indicatorColor, fill=True).to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMEmbeddedDisplay","title":"<code>PyDMEmbeddedDisplay</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code>, <code>Hidable</code>, <code>Drawable</code></p> <p>PyDMEmbeddedDisplay embeds another UI file (display) inside the current display.</p>"},{"location":"reference/widgets/#widgets.PyDMEmbeddedDisplay--attributes","title":"Attributes","text":"<p>filename : Optional[str]     The path to the embedded UI file. macros : Optional[Dict[str, str]]     Macros to pass down to the embedded display. visible : Optional[bool]     Whether the embedded display is visible.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMEmbeddedDisplay(Alarmable, Hidable, Drawable):\n    \"\"\"\n    PyDMEmbeddedDisplay embeds another UI file (display) inside the current display.\n\n    Attributes\n    ----------\n    filename : Optional[str]\n        The path to the embedded UI file.\n    macros : Optional[Dict[str, str]]\n        Macros to pass down to the embedded display.\n    visible : Optional[bool]\n        Whether the embedded display is visible.\n    \"\"\"\n\n    filename: Optional[str] = None\n    macros: Optional[Dict[str, str]] = field(default_factory=dict)\n    visible: Optional[bool] = True\n    noscroll: Optional[bool] = True\n    background_color: Optional[bool] = None\n    foreground_color: Optional[bool] = None\n\n    def generate_properties(self) -&gt; list:\n        \"\"\"\n        Generate XML elements for PyDMEmbeddedDisplay properties.\n        \"\"\"\n        properties = super().generate_properties()\n        if self.filename is not None:\n            converted_filename = self.convert_filetype(self.filename)\n            properties.append(Str(\"filename\", converted_filename).to_xml())\n        if self.macros:\n            import json\n\n            macros_str = json.dumps(self.macros)\n            properties.append(Str(\"macros\", macros_str).to_xml())\n        if self.visible is not None:\n            properties.append(Bool(\"visible\", self.visible).to_xml())\n        if self.noscroll is not None:\n            scroll: Bool = not self.noscroll\n            properties.append(Bool(\"scrollable\", scroll).to_xml())\n        if (\n            self.foreground_color is not None\n            or self.background_color is not None\n            or (isinstance(self.name, str) and self.name.startswith(\"activePipClass\"))\n        ):\n            styles: Dict[str, any] = {}\n            if self.name.startswith(\"activePipClass\"):\n                styles[\"border\"] = \"1px solid black\"\n            if self.foreground_color is not None:\n                styles[\"color\"] = self.foreground_color\n            elif self.background_color is not None:\n                styles[\"background-color\"] = self.background_color\n            properties.append(StyleSheet(styles).to_xml())\n        return properties\n\n    def convert_filetype(self, file_string: str) -&gt; None:\n        \"\"\"\n        Converts file strings of .&lt;type&gt; to .ui\n        \"\"\"\n        filename = \".\".join(file_string.split(\".\")[:-1])\n        return f\"{filename}.ui\"  # TODO: ask if this should be expanded or be turned into a Path\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMEmbeddedDisplay.convert_filetype","title":"<code>convert_filetype(file_string)</code>","text":"<p>Converts file strings of . to .ui Source code in <code>pydmconverter/widgets.py</code> <pre><code>def convert_filetype(self, file_string: str) -&gt; None:\n    \"\"\"\n    Converts file strings of .&lt;type&gt; to .ui\n    \"\"\"\n    filename = \".\".join(file_string.split(\".\")[:-1])\n    return f\"{filename}.ui\"  # TODO: ask if this should be expanded or be turned into a Path\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMEmbeddedDisplay.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate XML elements for PyDMEmbeddedDisplay properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; list:\n    \"\"\"\n    Generate XML elements for PyDMEmbeddedDisplay properties.\n    \"\"\"\n    properties = super().generate_properties()\n    if self.filename is not None:\n        converted_filename = self.convert_filetype(self.filename)\n        properties.append(Str(\"filename\", converted_filename).to_xml())\n    if self.macros:\n        import json\n\n        macros_str = json.dumps(self.macros)\n        properties.append(Str(\"macros\", macros_str).to_xml())\n    if self.visible is not None:\n        properties.append(Bool(\"visible\", self.visible).to_xml())\n    if self.noscroll is not None:\n        scroll: Bool = not self.noscroll\n        properties.append(Bool(\"scrollable\", scroll).to_xml())\n    if (\n        self.foreground_color is not None\n        or self.background_color is not None\n        or (isinstance(self.name, str) and self.name.startswith(\"activePipClass\"))\n    ):\n        styles: Dict[str, any] = {}\n        if self.name.startswith(\"activePipClass\"):\n            styles[\"border\"] = \"1px solid black\"\n        if self.foreground_color is not None:\n            styles[\"color\"] = self.foreground_color\n        elif self.background_color is not None:\n            styles[\"background-color\"] = self.background_color\n        properties.append(StyleSheet(styles).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMEnumButton","title":"<code>PyDMEnumButton</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code>, <code>Legible</code></p> <p>PyDMEnumButton represents a button widget with enumerated options and layout properties.</p>"},{"location":"reference/widgets/#widgets.PyDMEnumButton--attributes","title":"Attributes","text":"<p>tool_tip : Optional[str]     The tooltip text for the button. monitor_disp : Optional[bool]     If True, enables monitoring of the display. items_translatable : Optional[bool]     If True, the items are translatable. items_disambiguation : Optional[str]     Disambiguation text for the items. items_comment : Optional[str]     Comment text for the items. use_custom_order : Optional[bool]     If True, a custom order is used. invert_order : Optional[bool]     If True, inverts the order of the items. custom_order_translatable : Optional[bool]     If True, the custom order is translatable. custom_order_disambiguation : Optional[str]     Disambiguation text for the custom order. custom_order_comment : Optional[str]     Comment for the custom order. widget_type : Optional[str]     The widget type. orientation : Optional[str]     The orientation of the widget. margin_top : Optional[int]     Top margin. margin_bottom : Optional[int]     Bottom margin. margin_left : Optional[int]     Left margin. margin_right : Optional[int]     Right margin. horizontal_spacing : Optional[int]     Horizontal spacing. vertical_spacing : Optional[int]     Vertical spacing. checkable : Optional[bool]     If True, the button is checkable. count : ClassVar[int]     Class variable tracking the number of PyDMEnumButton instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMEnumButton(Alarmable, Legible):\n    \"\"\"\n    PyDMEnumButton represents a button widget with enumerated options and layout properties.\n\n    Attributes\n    ----------\n    tool_tip : Optional[str]\n        The tooltip text for the button.\n    monitor_disp : Optional[bool]\n        If True, enables monitoring of the display.\n    items_translatable : Optional[bool]\n        If True, the items are translatable.\n    items_disambiguation : Optional[str]\n        Disambiguation text for the items.\n    items_comment : Optional[str]\n        Comment text for the items.\n    use_custom_order : Optional[bool]\n        If True, a custom order is used.\n    invert_order : Optional[bool]\n        If True, inverts the order of the items.\n    custom_order_translatable : Optional[bool]\n        If True, the custom order is translatable.\n    custom_order_disambiguation : Optional[str]\n        Disambiguation text for the custom order.\n    custom_order_comment : Optional[str]\n        Comment for the custom order.\n    widget_type : Optional[str]\n        The widget type.\n    orientation : Optional[str]\n        The orientation of the widget.\n    margin_top : Optional[int]\n        Top margin.\n    margin_bottom : Optional[int]\n        Bottom margin.\n    margin_left : Optional[int]\n        Left margin.\n    margin_right : Optional[int]\n        Right margin.\n    horizontal_spacing : Optional[int]\n        Horizontal spacing.\n    vertical_spacing : Optional[int]\n        Vertical spacing.\n    checkable : Optional[bool]\n        If True, the button is checkable.\n    count : ClassVar[int]\n        Class variable tracking the number of PyDMEnumButton instances.\n    \"\"\"\n\n    tool_tip: Optional[str] = None\n    monitor_disp: Optional[bool] = None\n    items_translatable: Optional[bool] = None\n    items_disambiguation: Optional[str] = None\n    items_comment: Optional[str] = None\n    use_custom_order: Optional[bool] = None\n    invert_order: Optional[bool] = None\n    custom_order_translatable: Optional[bool] = None\n    custom_order_disambiguation: Optional[str] = None\n    custom_order_comment: Optional[str] = None\n    widget_type: Optional[str] = None\n    orientation: Optional[str] = None\n    margin_top: Optional[int] = 0\n    margin_bottom: Optional[int] = 0\n    margin_left: Optional[int] = 0\n    margin_right: Optional[int] = 0\n    horizontal_spacing: Optional[int] = 0\n    vertical_spacing: Optional[int] = 0\n    checkable: Optional[bool] = None\n    tab_names: Optional[List[str]] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMEnumButton-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the PyDMEnumButton properties.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n        if self.tool_tip is not None:\n            properties.append(Str(\"toolTip\", self.tool_tip).to_xml())\n        if self.monitor_disp is not None:\n            properties.append(Bool(\"monitorDisp\", self.monitor_disp).to_xml())\n        if self.items_translatable is not None:\n            properties.append(Bool(\"itemsTranslatable\", self.items_translatable).to_xml())\n        if self.items_disambiguation is not None:\n            properties.append(Str(\"itemsDisambiguation\", self.items_disambiguation).to_xml())\n        if self.items_comment is not None:\n            properties.append(Str(\"itemsComment\", self.items_comment).to_xml())\n        if self.use_custom_order is not None:\n            properties.append(Bool(\"useCustomOrder\", self.use_custom_order).to_xml())\n        if self.invert_order is not None:\n            properties.append(Bool(\"invertOrder\", self.invert_order).to_xml())\n        if self.custom_order_translatable is not None:\n            properties.append(Bool(\"customOrderTranslatable\", self.custom_order_translatable).to_xml())\n        if self.custom_order_disambiguation is not None:\n            properties.append(Str(\"customOrderDisambiguation\", self.custom_order_disambiguation).to_xml())\n        if self.custom_order_comment is not None:\n            properties.append(Str(\"customOrderComment\", self.custom_order_comment).to_xml())\n        if self.widget_type is not None:\n            properties.append(Str(\"widgetType\", self.widget_type).to_xml())\n        if self.orientation is not None:\n            properties.append(Enum(\"orientation\", f\"Qt::{self.orientation.capitalize()}\").to_xml())\n        elif self.tab_names is not None:\n            properties.append(Enum(\"orientation\", \"Qt::Horizontal\").to_xml())\n        if self.margin_top is not None:\n            properties.append(Int(\"marginTop\", self.margin_top).to_xml())\n        if self.margin_bottom is not None:\n            properties.append(Int(\"marginBottom\", self.margin_bottom).to_xml())\n        if self.margin_left is not None:\n            properties.append(Int(\"marginLeft\", self.margin_left).to_xml())\n        if self.margin_right is not None:\n            properties.append(Int(\"marginRight\", self.margin_right).to_xml())\n        if self.horizontal_spacing is not None:\n            properties.append(Int(\"horizontalSpacing\", self.horizontal_spacing).to_xml())\n        if self.vertical_spacing is not None:\n            properties.append(Int(\"verticalSpacing\", self.vertical_spacing).to_xml())\n        if self.checkable is not None:\n            properties.append(Bool(\"checkable\", self.checkable).to_xml())\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMEnumButton.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMEnumButton-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.PyDMEnumButton.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the PyDMEnumButton properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMEnumButton-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the PyDMEnumButton properties.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n    if self.tool_tip is not None:\n        properties.append(Str(\"toolTip\", self.tool_tip).to_xml())\n    if self.monitor_disp is not None:\n        properties.append(Bool(\"monitorDisp\", self.monitor_disp).to_xml())\n    if self.items_translatable is not None:\n        properties.append(Bool(\"itemsTranslatable\", self.items_translatable).to_xml())\n    if self.items_disambiguation is not None:\n        properties.append(Str(\"itemsDisambiguation\", self.items_disambiguation).to_xml())\n    if self.items_comment is not None:\n        properties.append(Str(\"itemsComment\", self.items_comment).to_xml())\n    if self.use_custom_order is not None:\n        properties.append(Bool(\"useCustomOrder\", self.use_custom_order).to_xml())\n    if self.invert_order is not None:\n        properties.append(Bool(\"invertOrder\", self.invert_order).to_xml())\n    if self.custom_order_translatable is not None:\n        properties.append(Bool(\"customOrderTranslatable\", self.custom_order_translatable).to_xml())\n    if self.custom_order_disambiguation is not None:\n        properties.append(Str(\"customOrderDisambiguation\", self.custom_order_disambiguation).to_xml())\n    if self.custom_order_comment is not None:\n        properties.append(Str(\"customOrderComment\", self.custom_order_comment).to_xml())\n    if self.widget_type is not None:\n        properties.append(Str(\"widgetType\", self.widget_type).to_xml())\n    if self.orientation is not None:\n        properties.append(Enum(\"orientation\", f\"Qt::{self.orientation.capitalize()}\").to_xml())\n    elif self.tab_names is not None:\n        properties.append(Enum(\"orientation\", \"Qt::Horizontal\").to_xml())\n    if self.margin_top is not None:\n        properties.append(Int(\"marginTop\", self.margin_top).to_xml())\n    if self.margin_bottom is not None:\n        properties.append(Int(\"marginBottom\", self.margin_bottom).to_xml())\n    if self.margin_left is not None:\n        properties.append(Int(\"marginLeft\", self.margin_left).to_xml())\n    if self.margin_right is not None:\n        properties.append(Int(\"marginRight\", self.margin_right).to_xml())\n    if self.horizontal_spacing is not None:\n        properties.append(Int(\"horizontalSpacing\", self.horizontal_spacing).to_xml())\n    if self.vertical_spacing is not None:\n        properties.append(Int(\"verticalSpacing\", self.vertical_spacing).to_xml())\n    if self.checkable is not None:\n        properties.append(Bool(\"checkable\", self.checkable).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMEnumComboBox","title":"<code>PyDMEnumComboBox</code>  <code>dataclass</code>","text":"<p>               Bases: <code>QComboBox</code>, <code>Alarmable</code>, <code>StyleSheetObject</code></p> <p>PyDMEnumComboBox extends QComboBox to support enumeration with additional properties.</p>"},{"location":"reference/widgets/#widgets.PyDMEnumComboBox--attributes","title":"Attributes","text":"<p>tool_tip : Optional[str]     The tooltip text for the combo box. monitor_disp : Optional[bool]     If True, enables monitoring of the display.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMEnumComboBox(QComboBox, Alarmable, StyleSheetObject):\n    \"\"\"\n    PyDMEnumComboBox extends QComboBox to support enumeration with additional properties.\n\n    Attributes\n    ----------\n    tool_tip : Optional[str]\n        The tooltip text for the combo box.\n    monitor_disp : Optional[bool]\n        If True, enables monitoring of the display.\n    \"\"\"\n\n    tool_tip: Optional[str] = None\n    monitor_disp: Optional[bool] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMEnumComboBox-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the PyDMEnumComboBox properties.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n        if self.tool_tip is not None:\n            properties.append(Str(\"toolTip\", self.tool_tip).to_xml())\n        if self.monitor_disp is not None:\n            properties.append(Bool(\"monitorDisp\", self.monitor_disp).to_xml())\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMEnumComboBox.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMEnumComboBox-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.PyDMEnumComboBox.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the PyDMEnumComboBox properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMEnumComboBox-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the PyDMEnumComboBox properties.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n    if self.tool_tip is not None:\n        properties.append(Str(\"toolTip\", self.tool_tip).to_xml())\n    if self.monitor_disp is not None:\n        properties.append(Bool(\"monitorDisp\", self.monitor_disp).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMFrame","title":"<code>PyDMFrame</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code></p> <p>PyDMFrame is a container widget that can hold other PyDM widgets. It inherits from Alarmable to support alarm-related features.</p>"},{"location":"reference/widgets/#widgets.PyDMFrame--attributes","title":"Attributes","text":"<p>frameShape : Optional[str]     The shape of the frame. frameShadow : Optional[str]     The shadow style of the frame. lineWidth : Optional[int]     The width of the frame's line. midLineWidth : Optional[int]     The width of the mid-line of the frame. disableOnDisconnect : Optional[bool]     If True, disables the frame on disconnect. children : List[PyDMFrame]     A list of child PyDMFrame widgets. count : ClassVar[int]     A class variable counting frames.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMFrame(Alarmable):\n    \"\"\"\n    PyDMFrame is a container widget that can hold other PyDM widgets.\n    It inherits from Alarmable to support alarm-related features.\n\n    Attributes\n    ----------\n    frameShape : Optional[str]\n        The shape of the frame.\n    frameShadow : Optional[str]\n        The shadow style of the frame.\n    lineWidth : Optional[int]\n        The width of the frame's line.\n    midLineWidth : Optional[int]\n        The width of the mid-line of the frame.\n    disableOnDisconnect : Optional[bool]\n        If True, disables the frame on disconnect.\n    children : List[PyDMFrame]\n        A list of child PyDMFrame widgets.\n    count : ClassVar[int]\n        A class variable counting frames.\n    \"\"\"\n\n    frameShape: Optional[str] = None\n    frameShadow: Optional[str] = None\n    lineWidth: Optional[int] = None\n    midLineWidth: Optional[int] = None\n    disableOnDisconnect: Optional[bool] = None\n\n    children: List[\"PyDMFrame\"] = field(default_factory=list)\n\n    def add_child(self, child: \"PyDMFrame\") -&gt; None:\n        \"\"\"\n        Add a child widget to this frame's internal list.\n\n        Parameters\n        ----------\n        child : PyDMFrame\n            The child widget to add.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.children.append(child)\n\n    def to_xml(self) -&gt; ET.Element:\n        \"\"\"\n        Serialize the PyDMFrame and its children to an XML element.\n\n        Returns\n        -------\n        ET.Element\n            The XML element representing this PyDMFrame and its children.\n        \"\"\"\n        widget_el: ET.Element = super().to_xml()\n\n        for child in self.children:\n            widget_el.append(child.to_xml())\n\n        return widget_el\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMFrame-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the properties of this PyDMFrame.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n\n        if self.frameShape is not None:\n            properties.append(Str(\"frameShape\", self.frameShape).to_xml())\n        if self.frameShadow is not None:\n            properties.append(Str(\"frameShadow\", self.frameShadow).to_xml())\n        if self.lineWidth is not None:\n            properties.append(Int(\"lineWidth\", self.lineWidth).to_xml())\n        if self.midLineWidth is not None:\n            properties.append(Int(\"midLineWidth\", self.midLineWidth).to_xml())\n        if self.disableOnDisconnect is not None:\n            properties.append(Bool(\"disableOnDisconnect\", self.disableOnDisconnect).to_xml())\n        properties.append(TransparentBackground().to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMFrame.add_child","title":"<code>add_child(child)</code>","text":"<p>Add a child widget to this frame's internal list.</p>"},{"location":"reference/widgets/#widgets.PyDMFrame.add_child--parameters","title":"Parameters","text":"<p>child : PyDMFrame     The child widget to add.</p>"},{"location":"reference/widgets/#widgets.PyDMFrame.add_child--returns","title":"Returns","text":"<p>None</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def add_child(self, child: \"PyDMFrame\") -&gt; None:\n    \"\"\"\n    Add a child widget to this frame's internal list.\n\n    Parameters\n    ----------\n    child : PyDMFrame\n        The child widget to add.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.children.append(child)\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMFrame.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMFrame-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.PyDMFrame.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the properties of this PyDMFrame.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMFrame-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the properties of this PyDMFrame.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n\n    if self.frameShape is not None:\n        properties.append(Str(\"frameShape\", self.frameShape).to_xml())\n    if self.frameShadow is not None:\n        properties.append(Str(\"frameShadow\", self.frameShadow).to_xml())\n    if self.lineWidth is not None:\n        properties.append(Int(\"lineWidth\", self.lineWidth).to_xml())\n    if self.midLineWidth is not None:\n        properties.append(Int(\"midLineWidth\", self.midLineWidth).to_xml())\n    if self.disableOnDisconnect is not None:\n        properties.append(Bool(\"disableOnDisconnect\", self.disableOnDisconnect).to_xml())\n    properties.append(TransparentBackground().to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMFrame.to_xml","title":"<code>to_xml()</code>","text":"<p>Serialize the PyDMFrame and its children to an XML element.</p>"},{"location":"reference/widgets/#widgets.PyDMFrame.to_xml--returns","title":"Returns","text":"<p>ET.Element     The XML element representing this PyDMFrame and its children.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def to_xml(self) -&gt; ET.Element:\n    \"\"\"\n    Serialize the PyDMFrame and its children to an XML element.\n\n    Returns\n    -------\n    ET.Element\n        The XML element representing this PyDMFrame and its children.\n    \"\"\"\n    widget_el: ET.Element = super().to_xml()\n\n    for child in self.children:\n        widget_el.append(child.to_xml())\n\n    return widget_el\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMImageView","title":"<code>PyDMImageView</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code></p> <p>PyDMImageView represents an image file to be inserted.</p>"},{"location":"reference/widgets/#widgets.PyDMImageView--attributes","title":"Attributes","text":"<p>filename : Optional[str]     A string representing the filename of the image file.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMImageView(Alarmable):\n    \"\"\"\n    PyDMImageView represents an image file to be inserted.\n\n    Attributes\n    ----------\n    filename : Optional[str]\n        A string representing the filename of the image file.\n    \"\"\"\n\n    filename: Optional[str] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMImageView-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the PyDMImageView properties.\n        \"\"\"\n\n        properties: List[ET.Element] = super().generate_properties()\n\n        if self.filename is not None:\n            properties.append(Str(\"filename\", self.filename).to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMImageView.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMImageView-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.PyDMImageView.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the PyDMImageView properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMImageView-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the PyDMImageView properties.\n    \"\"\"\n\n    properties: List[ET.Element] = super().generate_properties()\n\n    if self.filename is not None:\n        properties.append(Str(\"filename\", self.filename).to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMLabel","title":"<code>PyDMLabel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>QLabel</code>, <code>Alarmable</code></p> <p>PyDMLabel is an extension of QLabel that supports an additional property to indicate whether the numerical precision should be derived from the process variable (PV).</p>"},{"location":"reference/widgets/#widgets.PyDMLabel--attributes","title":"Attributes","text":"<p>precision_from_pv : Optional[bool]     If True, the numerical precision is determined from the process variable.     If None, no such property is added. count : ClassVar[int]     A class variable tracking the number of PyDMLabel instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMLabel(QLabel, Alarmable):\n    \"\"\"\n    PyDMLabel is an extension of QLabel that supports an additional property to indicate whether\n    the numerical precision should be derived from the process variable (PV).\n\n    Attributes\n    ----------\n    precision_from_pv : Optional[bool]\n        If True, the numerical precision is determined from the process variable.\n        If None, no such property is added.\n    count : ClassVar[int]\n        A class variable tracking the number of PyDMLabel instances.\n    \"\"\"\n\n    precision_from_pv: Optional[bool] = None\n    autoSize: bool = False\n\n    def __post_init__(self):\n        super().__post_init__()\n        if self.autoSize:\n            self.adjustSize()\n\n    def setText(self, text):\n        super().setText(text)\n        if self.autoSize:\n            self.adjustSize()\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMLabel-specific properties for XML serialization.\n\n        This method extends the properties generated by its superclass by appending a property\n        for 'precisionFromPV' if the corresponding attribute is not None.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the properties of the PyDMLabel.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n        if self.precision_from_pv is not None:\n            properties.append(Bool(\"precisionFromPV\", self.precision_from_pv).to_xml())\n        if self.autoSize:\n            properties.append(Bool(\"autoSize\", True).to_xml())\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMLabel.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMLabel-specific properties for XML serialization.</p> <p>This method extends the properties generated by its superclass by appending a property for 'precisionFromPV' if the corresponding attribute is not None.</p>"},{"location":"reference/widgets/#widgets.PyDMLabel.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the properties of the PyDMLabel.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMLabel-specific properties for XML serialization.\n\n    This method extends the properties generated by its superclass by appending a property\n    for 'precisionFromPV' if the corresponding attribute is not None.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the properties of the PyDMLabel.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n    if self.precision_from_pv is not None:\n        properties.append(Bool(\"precisionFromPV\", self.precision_from_pv).to_xml())\n    if self.autoSize:\n        properties.append(Bool(\"autoSize\", True).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMLineEdit","title":"<code>PyDMLineEdit</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Legible</code>, <code>Alarmable</code>, <code>StyleSheetObject</code></p> <p>PyDMLineEdit represents a PyDMLineEdit widget with XML serialization capabilities. It extends Legible, and Alarmable to support additional features.</p>"},{"location":"reference/widgets/#widgets.PyDMLineEdit--attributes","title":"Attributes","text":"<p>displayFormat : Optional[int]     An integer representing the display format. If None, the display format property is omitted. count : ClassVar[int]     A class variable tracking the number of PyDMLineEdit instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMLineEdit(Legible, Alarmable, StyleSheetObject):\n    \"\"\"\n    PyDMLineEdit represents a PyDMLineEdit widget with XML serialization capabilities.\n    It extends Legible, and Alarmable to support additional features.\n\n    Attributes\n    ----------\n    displayFormat : Optional[int]\n        An integer representing the display format. If None, the display format property is omitted.\n    count : ClassVar[int]\n        A class variable tracking the number of PyDMLineEdit instances.\n    \"\"\"\n\n    displayFormat: Optional[int] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMLineEdit-specific properties for XML serialization.\n\n        This method extends the properties generated by the superclass by appending a property\n        for 'displayFormat' if the attribute is not None.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the properties of the PyDMLineEdit.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n        if self.displayFormat is not None:\n            properties.append(Int(\"displayFormat\", self.displayFormat).to_xml())\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMLineEdit.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMLineEdit-specific properties for XML serialization.</p> <p>This method extends the properties generated by the superclass by appending a property for 'displayFormat' if the attribute is not None.</p>"},{"location":"reference/widgets/#widgets.PyDMLineEdit.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the properties of the PyDMLineEdit.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMLineEdit-specific properties for XML serialization.\n\n    This method extends the properties generated by the superclass by appending a property\n    for 'displayFormat' if the attribute is not None.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the properties of the PyDMLineEdit.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n    if self.displayFormat is not None:\n        properties.append(Int(\"displayFormat\", self.displayFormat).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMPushButton","title":"<code>PyDMPushButton</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PyDMPushButtonBase</code></p> <p>PyDMPushButton extends PyDMPushButtonBase with additional properties for push button behavior.</p>"},{"location":"reference/widgets/#widgets.PyDMPushButton--attributes","title":"Attributes","text":"<p>monitor_disp : Optional[bool]     If True, enables monitoring of the display. show_confirm_dialog : Optional[bool]     If True, displays a confirmation dialog before action. confirm_message : Optional[str]     The confirmation message to display. press_value : Optional[str]     The value to send when the button is pressed. release_value : Optional[str]     The value to send when the button is released. relative_change : Optional[bool]     If True, indicates that the change is relative. write_when_release : Optional[bool]     If True, writes the value when the button is released. count : ClassVar[int]     Class variable tracking the number of PyDMPushButton instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMPushButton(PyDMPushButtonBase):\n    \"\"\"\n    PyDMPushButton extends PyDMPushButtonBase with additional properties for push button behavior.\n\n    Attributes\n    ----------\n    monitor_disp : Optional[bool]\n        If True, enables monitoring of the display.\n    show_confirm_dialog : Optional[bool]\n        If True, displays a confirmation dialog before action.\n    confirm_message : Optional[str]\n        The confirmation message to display.\n    press_value : Optional[str]\n        The value to send when the button is pressed.\n    release_value : Optional[str]\n        The value to send when the button is released.\n    relative_change : Optional[bool]\n        If True, indicates that the change is relative.\n    write_when_release : Optional[bool]\n        If True, writes the value when the button is released.\n    count : ClassVar[int]\n        Class variable tracking the number of PyDMPushButton instances.\n    \"\"\"\n\n    monitor_disp: Optional[bool] = None\n    show_confirm_dialog: Optional[bool] = None\n    confirm_message: Optional[str] = None\n    press_value: Optional[str] = None\n    release_value: Optional[str] = None\n    relative_change: Optional[bool] = None\n    write_when_release: Optional[bool] = None\n    on_color: Optional[RGBA] = None  # TODO: clean up where these attributes are called to a parent to reduce redundancy\n    off_color: Optional[RGBA] = (\n        None  # TODO: clean up where these attributes are called to a parent to reduce redundancy\n    )\n    foreground_color: Optional[RGBA] = None\n    background_color: Optional[RGBA] = None\n    useDisplayBg: Optional[bool] = None\n    on_label: Optional[str] = None\n    off_label: Optional[str] = None\n    is_off_button: Optional[bool] = None\n    is_freeze_button: Optional[bool] = None\n    text: Optional[str] = None\n    visMin: Optional[int] = None\n    visMax: Optional[int] = None\n    pressValue: Optional[str] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMPushButton-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the PyDMPushButton properties.\n        \"\"\"\n        if self.is_off_button is not None:\n            show_button = not self.is_off_button\n\n            self.rules.append(RuleArguments(\"Visible\", self.channel, False, show_button, None, None))\n            self.rules.append(RuleArguments(\"Enable\", self.channel, False, show_button, None, None))\n            enum_index = 0 if self.is_off_button else 1\n            if self.text is None and self.channel is not None:\n                pv = PV(self.channel, connection_timeout=0.5)\n                if pv and pv.enum_strs and len(list(pv.enum_strs)) &gt;= 2:\n                    self.text = pv.enum_strs[enum_index]\n        if self.is_freeze_button is not None and not self.is_freeze_button:\n            self.channel = \"loc://FROZEN_STATE?type=int&amp;init=0\"\n            self.rules.append(RuleArguments(\"Visible\", \"loc://FROZEN_STATE\", False, False, None, None))\n            self.rules.append(RuleArguments(\"Enable\", \"loc://FROZEN_STATE\", False, False, None, None))\n        elif self.is_freeze_button is not None and self.is_freeze_button:\n            self.channel = \"loc://FROZEN_STATE\"\n            self.rules.append(RuleArguments(\"Visible\", \"loc://FROZEN_STATE\", False, True, None, None))\n            self.rules.append(RuleArguments(\"Enable\", \"loc://FROZEN_STATE\", False, True, None, None))\n\n        properties: List[ET.Element] = super().generate_properties()\n        if self.monitor_disp is not None:\n            properties.append(Bool(\"monitorDisp\", self.monitor_disp).to_xml())\n        if self.show_confirm_dialog is not None:\n            properties.append(Bool(\"showConfirmDialog\", self.show_confirm_dialog).to_xml())\n        if self.confirm_message is not None:\n            properties.append(Str(\"confirmMessage\", self.confirm_message).to_xml())\n        if self.press_value is not None:\n            properties.append(Str(\"pressValue\", self.press_value).to_xml())\n        if self.release_value is not None:\n            properties.append(Str(\"releaseValue\", self.release_value).to_xml())\n        if self.relative_change is not None:\n            properties.append(Bool(\"relativeChange\", self.relative_change).to_xml())\n        if self.write_when_release is not None:\n            properties.append(Bool(\"writeWhenRelease\", self.write_when_release).to_xml())\n        if self.on_label is not None:\n            properties.append(Str(\"text\", self.on_label).to_xml())\n        if self.is_freeze_button is not None and not self.is_freeze_button:\n            properties.append(Str(\"pressValue\", \"1\").to_xml())\n        if self.is_freeze_button is not None and self.is_freeze_button:\n            properties.append(Str(\"pressValue\", \"0\").to_xml())\n        if (\n            self.on_color is not None\n            or self.foreground_color is not None\n            or self.background_color is not None\n            or self.flat is True\n            or (\n                isinstance(self.name, str)\n                and (\n                    self.name.startswith(\"activeMenuButtonClass\") or self.name.startswith(\"activeMessageButtonClass\")\n                )  # TODO: Eventually remove this whole stylesheet property\n            )\n        ):\n            styles: Dict[str, any] = {}\n            if self.name.startswith(\"activeMenuButtonClass\") or self.name.startswith(\"activeMessageButtonClass\"):\n                styles[\"border\"] = \"1px solid black\"\n            if self.foreground_color is not None:\n                styles[\"color\"] = self.foreground_color\n            if (\n                self.on_color is not None\n            ):  # TODO: find if on_color/background_color should take precedent (they are used for diff edm classes anyway) #TODO: Replace with OnOffColor class eventually\n                styles[\"background-color\"] = self.on_color\n            elif self.background_color is not None and self.useDisplayBg is None:\n                styles[\"background-color\"] = self.background_color\n            elif self.flat is True and self.background_color is None and self.on_color is None:\n                # When flat is true but no background is set, set transparent background for embedded displays\n                styles[\"background-color\"] = \"transparent\"\n            if self.on_color is not None and self.off_color != self.on_color:\n                logging.warning(\"on and off colors are different, need to modify code\")\n            properties.append(StyleSheet(styles).to_xml())\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMPushButton.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMPushButton-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.PyDMPushButton.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the PyDMPushButton properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMPushButton-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the PyDMPushButton properties.\n    \"\"\"\n    if self.is_off_button is not None:\n        show_button = not self.is_off_button\n\n        self.rules.append(RuleArguments(\"Visible\", self.channel, False, show_button, None, None))\n        self.rules.append(RuleArguments(\"Enable\", self.channel, False, show_button, None, None))\n        enum_index = 0 if self.is_off_button else 1\n        if self.text is None and self.channel is not None:\n            pv = PV(self.channel, connection_timeout=0.5)\n            if pv and pv.enum_strs and len(list(pv.enum_strs)) &gt;= 2:\n                self.text = pv.enum_strs[enum_index]\n    if self.is_freeze_button is not None and not self.is_freeze_button:\n        self.channel = \"loc://FROZEN_STATE?type=int&amp;init=0\"\n        self.rules.append(RuleArguments(\"Visible\", \"loc://FROZEN_STATE\", False, False, None, None))\n        self.rules.append(RuleArguments(\"Enable\", \"loc://FROZEN_STATE\", False, False, None, None))\n    elif self.is_freeze_button is not None and self.is_freeze_button:\n        self.channel = \"loc://FROZEN_STATE\"\n        self.rules.append(RuleArguments(\"Visible\", \"loc://FROZEN_STATE\", False, True, None, None))\n        self.rules.append(RuleArguments(\"Enable\", \"loc://FROZEN_STATE\", False, True, None, None))\n\n    properties: List[ET.Element] = super().generate_properties()\n    if self.monitor_disp is not None:\n        properties.append(Bool(\"monitorDisp\", self.monitor_disp).to_xml())\n    if self.show_confirm_dialog is not None:\n        properties.append(Bool(\"showConfirmDialog\", self.show_confirm_dialog).to_xml())\n    if self.confirm_message is not None:\n        properties.append(Str(\"confirmMessage\", self.confirm_message).to_xml())\n    if self.press_value is not None:\n        properties.append(Str(\"pressValue\", self.press_value).to_xml())\n    if self.release_value is not None:\n        properties.append(Str(\"releaseValue\", self.release_value).to_xml())\n    if self.relative_change is not None:\n        properties.append(Bool(\"relativeChange\", self.relative_change).to_xml())\n    if self.write_when_release is not None:\n        properties.append(Bool(\"writeWhenRelease\", self.write_when_release).to_xml())\n    if self.on_label is not None:\n        properties.append(Str(\"text\", self.on_label).to_xml())\n    if self.is_freeze_button is not None and not self.is_freeze_button:\n        properties.append(Str(\"pressValue\", \"1\").to_xml())\n    if self.is_freeze_button is not None and self.is_freeze_button:\n        properties.append(Str(\"pressValue\", \"0\").to_xml())\n    if (\n        self.on_color is not None\n        or self.foreground_color is not None\n        or self.background_color is not None\n        or self.flat is True\n        or (\n            isinstance(self.name, str)\n            and (\n                self.name.startswith(\"activeMenuButtonClass\") or self.name.startswith(\"activeMessageButtonClass\")\n            )  # TODO: Eventually remove this whole stylesheet property\n        )\n    ):\n        styles: Dict[str, any] = {}\n        if self.name.startswith(\"activeMenuButtonClass\") or self.name.startswith(\"activeMessageButtonClass\"):\n            styles[\"border\"] = \"1px solid black\"\n        if self.foreground_color is not None:\n            styles[\"color\"] = self.foreground_color\n        if (\n            self.on_color is not None\n        ):  # TODO: find if on_color/background_color should take precedent (they are used for diff edm classes anyway) #TODO: Replace with OnOffColor class eventually\n            styles[\"background-color\"] = self.on_color\n        elif self.background_color is not None and self.useDisplayBg is None:\n            styles[\"background-color\"] = self.background_color\n        elif self.flat is True and self.background_color is None and self.on_color is None:\n            # When flat is true but no background is set, set transparent background for embedded displays\n            styles[\"background-color\"] = \"transparent\"\n        if self.on_color is not None and self.off_color != self.on_color:\n            logging.warning(\"on and off colors are different, need to modify code\")\n        properties.append(StyleSheet(styles).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMPushButtonBase","title":"<code>PyDMPushButtonBase</code>  <code>dataclass</code>","text":"<p>               Bases: <code>QPushButton</code>, <code>Alarmable</code></p> <p>PyDMPushButtonBase extends QPushButton with additional PyDM-specific properties, including icon settings and password protection features.</p>"},{"location":"reference/widgets/#widgets.PyDMPushButtonBase--attributes","title":"Attributes","text":"<p>pydm_icon : Optional[str]     Icon identifier or file path for the PyDM button. pydm_icon_color : Optional[str]     The color to apply to the PyDM icon. password_protected : Optional[bool]     Indicates whether the button is password protected. password : Optional[str]     The password used by the button (if applicable). protected_password : Optional[str]     A version of the password that is protected or encrypted. count : ClassVar[int]     Class variable tracking the number of PyDMPushButtonBase instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMPushButtonBase(QPushButton, Alarmable):\n    \"\"\"\n    PyDMPushButtonBase extends QPushButton with additional PyDM-specific properties,\n    including icon settings and password protection features.\n\n    Attributes\n    ----------\n    pydm_icon : Optional[str]\n        Icon identifier or file path for the PyDM button.\n    pydm_icon_color : Optional[str]\n        The color to apply to the PyDM icon.\n    password_protected : Optional[bool]\n        Indicates whether the button is password protected.\n    password : Optional[str]\n        The password used by the button (if applicable).\n    protected_password : Optional[str]\n        A version of the password that is protected or encrypted.\n    count : ClassVar[int]\n        Class variable tracking the number of PyDMPushButtonBase instances.\n    \"\"\"\n\n    pydm_icon: Optional[str] = None\n    pydm_icon_color: Optional[str] = None\n    password_protected: Optional[bool] = None\n    password: Optional[str] = None\n    protected_password: Optional[str] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMPushButtonBase-specific properties for XML serialization.\n\n        This method extends the properties generated by the superclass (QPushButton) by appending\n        additional properties related to PyDM-specific features if they are not None.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the PyDMPushButtonBase properties.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n\n        if self.pydm_icon is not None:\n            properties.append(Str(\"PyDMIcon\", self.pydm_icon).to_xml())\n        if self.pydm_icon_color is not None:\n            properties.append(Str(\"PyDMIconColor\", self.pydm_icon_color).to_xml())\n        if self.password_protected is not None:\n            properties.append(Bool(\"passwordProtected\", self.password_protected).to_xml())\n        if self.password is not None:\n            properties.append(Str(\"password\", self.password).to_xml())\n        if self.protected_password is not None:\n            properties.append(Str(\"protectedPassword\", self.protected_password).to_xml())\n        if isinstance(self.name, str) and self.name.startswith(\"activeMenuButtonClass\"):\n            properties.append(Str(\"text\", \"Menu\").to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMPushButtonBase.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMPushButtonBase-specific properties for XML serialization.</p> <p>This method extends the properties generated by the superclass (QPushButton) by appending additional properties related to PyDM-specific features if they are not None.</p>"},{"location":"reference/widgets/#widgets.PyDMPushButtonBase.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the PyDMPushButtonBase properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMPushButtonBase-specific properties for XML serialization.\n\n    This method extends the properties generated by the superclass (QPushButton) by appending\n    additional properties related to PyDM-specific features if they are not None.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the PyDMPushButtonBase properties.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n\n    if self.pydm_icon is not None:\n        properties.append(Str(\"PyDMIcon\", self.pydm_icon).to_xml())\n    if self.pydm_icon_color is not None:\n        properties.append(Str(\"PyDMIconColor\", self.pydm_icon_color).to_xml())\n    if self.password_protected is not None:\n        properties.append(Bool(\"passwordProtected\", self.password_protected).to_xml())\n    if self.password is not None:\n        properties.append(Str(\"password\", self.password).to_xml())\n    if self.protected_password is not None:\n        properties.append(Str(\"protectedPassword\", self.protected_password).to_xml())\n    if isinstance(self.name, str) and self.name.startswith(\"activeMenuButtonClass\"):\n        properties.append(Str(\"text\", \"Menu\").to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMRelatedDisplayButton","title":"<code>PyDMRelatedDisplayButton</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PyDMPushButtonBase</code></p> <p>PyDMRelatedDisplayButton extends PyDMPushButtonBase to support opening related displays.</p>"},{"location":"reference/widgets/#widgets.PyDMRelatedDisplayButton--attributes","title":"Attributes","text":"<p>show_icon : Optional[bool]     If True, an icon is displayed. filenames : Optional[str]     The filenames associated with the display. titles : Optional[str]     The titles for the display. macros : Optional[str]     Macros used for the display. open_in_new_window : Optional[bool]     If True, opens the display in a new window. follow_symlinks : Optional[bool]     If True, follows symbolic links. count : ClassVar[int]     Class variable tracking the number of PyDMRelatedDisplayButton instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMRelatedDisplayButton(PyDMPushButtonBase):\n    \"\"\"\n    PyDMRelatedDisplayButton extends PyDMPushButtonBase to support opening related displays.\n\n    Attributes\n    ----------\n    show_icon : Optional[bool]\n        If True, an icon is displayed.\n    filenames : Optional[str]\n        The filenames associated with the display.\n    titles : Optional[str]\n        The titles for the display.\n    macros : Optional[str]\n        Macros used for the display.\n    open_in_new_window : Optional[bool]\n        If True, opens the display in a new window.\n    follow_symlinks : Optional[bool]\n        If True, follows symbolic links.\n    count : ClassVar[int]\n        Class variable tracking the number of PyDMRelatedDisplayButton instances.\n    \"\"\"\n\n    show_icon: Optional[bool] = None\n    filenames: Optional[str] = None\n    titles: Optional[str] = None\n    macros: Optional[str] = None\n    open_in_new_window: Optional[bool] = None\n    follow_symlinks: Optional[bool] = None\n    displayFileName = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMRelatedDisplayButton-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the PyDMRelatedDisplayButton properties.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n        if self.show_icon is not None:\n            properties.append(Bool(\"showIcon\", self.show_icon).to_xml())\n        else:\n            properties.append(Bool(\"showIcon\", False).to_xml())\n        # if self.filenames is not None:\n        #    properties.append(Str(\"filenames\", self.filenames).to_xml()) #TODO: Maybe come back and include this if it comes up in edm\n        if self.titles is not None:\n            properties.append(Str(\"titles\", self.titles).to_xml())\n        if self.macros is not None:\n            properties.append(Str(\"macros\", self.macros).to_xml())\n        # if self.open_in_new_window is not None:\n        properties.append(Bool(\"openInNewWindow\", True).to_xml())\n        if self.follow_symlinks is not None:\n            properties.append(Bool(\"followSymlinks\", self.follow_symlinks).to_xml())\n        if (\n            self.displayFileName is not None and self.displayFileName\n        ):  # TODO: Come back and find out why sometimes an empty list\n            converted_filenames = list(map(self.convert_filetype, self.displayFileName))\n            properties.append(StringList(\"filenames\", converted_filenames).to_xml())\n        return properties\n\n    def convert_filetype(self, file_string: str) -&gt; None:\n        \"\"\"\n        Converts file strings of .&lt;type&gt; to .ui\n        \"\"\"\n        filearr = file_string.split(\".\")\n        if len(filearr) &gt; 1:\n            filename = \".\".join(filearr[:-1])\n        else:\n            filename = file_string\n        return f\"{filename}.ui\"\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMRelatedDisplayButton.convert_filetype","title":"<code>convert_filetype(file_string)</code>","text":"<p>Converts file strings of . to .ui Source code in <code>pydmconverter/widgets.py</code> <pre><code>def convert_filetype(self, file_string: str) -&gt; None:\n    \"\"\"\n    Converts file strings of .&lt;type&gt; to .ui\n    \"\"\"\n    filearr = file_string.split(\".\")\n    if len(filearr) &gt; 1:\n        filename = \".\".join(filearr[:-1])\n    else:\n        filename = file_string\n    return f\"{filename}.ui\"\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMRelatedDisplayButton.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMRelatedDisplayButton-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.PyDMRelatedDisplayButton.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the PyDMRelatedDisplayButton properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMRelatedDisplayButton-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the PyDMRelatedDisplayButton properties.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n    if self.show_icon is not None:\n        properties.append(Bool(\"showIcon\", self.show_icon).to_xml())\n    else:\n        properties.append(Bool(\"showIcon\", False).to_xml())\n    # if self.filenames is not None:\n    #    properties.append(Str(\"filenames\", self.filenames).to_xml()) #TODO: Maybe come back and include this if it comes up in edm\n    if self.titles is not None:\n        properties.append(Str(\"titles\", self.titles).to_xml())\n    if self.macros is not None:\n        properties.append(Str(\"macros\", self.macros).to_xml())\n    # if self.open_in_new_window is not None:\n    properties.append(Bool(\"openInNewWindow\", True).to_xml())\n    if self.follow_symlinks is not None:\n        properties.append(Bool(\"followSymlinks\", self.follow_symlinks).to_xml())\n    if (\n        self.displayFileName is not None and self.displayFileName\n    ):  # TODO: Come back and find out why sometimes an empty list\n        converted_filenames = list(map(self.convert_filetype, self.displayFileName))\n        properties.append(StringList(\"filenames\", converted_filenames).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMScaleIndicator","title":"<code>PyDMScaleIndicator</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code></p> <p>Represents a PyDM widget that displays a scale indicator.</p>"},{"location":"reference/widgets/#widgets.PyDMScaleIndicator--attributes","title":"Attributes","text":"<p>showUnits : Optional[bool]     Whether to display units next to the scale. showLimits : Optional[bool]     Whether to display min/max limits. showValue : Optional[bool]     Whether to display the current value. flipScale : Optional[bool]     Whether to reverse the scale orientation. precision : Optional[int]     Number of decimal places for displayed values. minorTicks : Optional[int]     Number of minor tick marks. majorTicks : Optional[int]     Number of major tick marks. indicatorColor : Optional[RGBA]     Color of the indicator line. background_color : Optional[RGBA]     Background color of the scale widget. foreground_color : Optional[RGBA]     Color of tick marks.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMScaleIndicator(Alarmable):\n    \"\"\"\n    Represents a PyDM widget that displays a scale indicator.\n\n    Attributes\n    ----------\n    showUnits : Optional[bool]\n        Whether to display units next to the scale.\n    showLimits : Optional[bool]\n        Whether to display min/max limits.\n    showValue : Optional[bool]\n        Whether to display the current value.\n    flipScale : Optional[bool]\n        Whether to reverse the scale orientation.\n    precision : Optional[int]\n        Number of decimal places for displayed values.\n    minorTicks : Optional[int]\n        Number of minor tick marks.\n    majorTicks : Optional[int]\n        Number of major tick marks.\n    indicatorColor : Optional[RGBA]\n        Color of the indicator line.\n    background_color : Optional[RGBA]\n        Background color of the scale widget.\n    foreground_color : Optional[RGBA]\n        Color of tick marks.\n    \"\"\"\n\n    showUnits: Optional[bool] = None\n    showLimits: Optional[bool] = False\n    showValue: Optional[bool] = False\n    flipScale: Optional[bool] = None\n    precision: Optional[int] = None\n    # numDivisions: Optional[int] = None\n    minorTicks: Optional[int] = None\n    majorTicks: Optional[int] = None\n    indicatorColor: Optional[RGBA] = None\n    background_color: Optional[RGBA] = None\n    foreground_color: Optional[RGBA] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generates a list of XML elements representing the pydmscaleindicator's properties.\n\n        Returns:\n            List[ET.Element]: List of XML elements for serialization.\n        \"\"\"\n\n        # The \"flipScale\" property should be included, as scaleIndicator does not load properly without it.\n        # self.height += 20\n        # self.y -= 10  # TODO: Find a better way to just get the bottom (can create a frame that cuts off the top)\n        properties: List[ET.Element] = super().generate_properties()\n\n        if self.showUnits is not None:\n            properties.append(Bool(\"showUnits\", self.showUnits).to_xml())\n        # if self.showLimits is not None:\n        #    properties.append(Bool(\"showLimits\", self.showLimits).to_xml())\n        # if self.showValue is not None:\n        #    properties.append(Bool(\"showValue\", self.showValue).to_xml())\n        if self.flipScale is not None:\n            properties.append(Bool(\"flipScale\", self.flipScale).to_xml())\n        if self.precision is not None:\n            properties.append(Int(\"precision\", self.precision).to_xml())\n        if self.minorTicks is not None or self.majorTicks is not None:\n            properties.append(Int(\"numDivisions\", int(self.minorTicks or 0) + int(self.majorTicks or 0)).to_xml())\n        if self.indicatorColor is not None:\n            properties.append(ColorObject(\"indicatorColor\", *self.indicatorColor).to_xml())\n        # if self.background_color is not None:\n        #    styles: Dict[str, any] = {}\n        #    styles[\"color\"] = self.background_color\n        #    properties.append(StyleSheet(styles).to_xml())\n        if self.background_color is not None:\n            properties.append(ColorObject(\"backgroundColor\", *self.background_color).to_xml())\n        if self.foreground_color is not None:\n            properties.append(ColorObject(\"tickColor\", *self.foreground_color).to_xml())\n        properties.append(TransparentBackground().to_xml())\n        # properties.append(ColorObject(\"tickColor\", 255, 255, 255).to_xml())\n        properties.append(Bool(\"showTicks\", True).to_xml())\n        properties.append(Bool(\"showValue\", self.showValue).to_xml())\n        properties.append(Bool(\"showLimits\", self.showLimits).to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMScaleIndicator.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generates a list of XML elements representing the pydmscaleindicator's properties.</p> <p>Returns:</p> Type Description <code>List[Element]</code> <p>List[ET.Element]: List of XML elements for serialization.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generates a list of XML elements representing the pydmscaleindicator's properties.\n\n    Returns:\n        List[ET.Element]: List of XML elements for serialization.\n    \"\"\"\n\n    # The \"flipScale\" property should be included, as scaleIndicator does not load properly without it.\n    # self.height += 20\n    # self.y -= 10  # TODO: Find a better way to just get the bottom (can create a frame that cuts off the top)\n    properties: List[ET.Element] = super().generate_properties()\n\n    if self.showUnits is not None:\n        properties.append(Bool(\"showUnits\", self.showUnits).to_xml())\n    # if self.showLimits is not None:\n    #    properties.append(Bool(\"showLimits\", self.showLimits).to_xml())\n    # if self.showValue is not None:\n    #    properties.append(Bool(\"showValue\", self.showValue).to_xml())\n    if self.flipScale is not None:\n        properties.append(Bool(\"flipScale\", self.flipScale).to_xml())\n    if self.precision is not None:\n        properties.append(Int(\"precision\", self.precision).to_xml())\n    if self.minorTicks is not None or self.majorTicks is not None:\n        properties.append(Int(\"numDivisions\", int(self.minorTicks or 0) + int(self.majorTicks or 0)).to_xml())\n    if self.indicatorColor is not None:\n        properties.append(ColorObject(\"indicatorColor\", *self.indicatorColor).to_xml())\n    # if self.background_color is not None:\n    #    styles: Dict[str, any] = {}\n    #    styles[\"color\"] = self.background_color\n    #    properties.append(StyleSheet(styles).to_xml())\n    if self.background_color is not None:\n        properties.append(ColorObject(\"backgroundColor\", *self.background_color).to_xml())\n    if self.foreground_color is not None:\n        properties.append(ColorObject(\"tickColor\", *self.foreground_color).to_xml())\n    properties.append(TransparentBackground().to_xml())\n    # properties.append(ColorObject(\"tickColor\", 255, 255, 255).to_xml())\n    properties.append(Bool(\"showTicks\", True).to_xml())\n    properties.append(Bool(\"showValue\", self.showValue).to_xml())\n    properties.append(Bool(\"showLimits\", self.showLimits).to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMShellCommand","title":"<code>PyDMShellCommand</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PyDMPushButtonBase</code>, <code>StyleSheetObject</code></p> <p>PyDMShellCommand extends PyDMPushButtonBase to execute shell commands.</p>"},{"location":"reference/widgets/#widgets.PyDMShellCommand--attributes","title":"Attributes","text":"<p>show_confirm_dialog : Optional[bool]     If True, displays a confirmation dialog before executing the command. confirm_message : Optional[str]     The message to display in the confirmation dialog. run_commands_in_full_shell : Optional[bool]     If True, runs commands in a full shell environment. environment_variables : Optional[str]     Environment variables to pass to the command. show_icon : Optional[bool]     If True, displays an icon on the button. redirect_command_output : Optional[bool]     If True, redirects the command output. allow_multiple_executions : Optional[bool]     If True, permits multiple command executions. titles : Optional[List[str]]     Titles associated with the commands (one per command). command : Optional[List[str]]     The shell commands to execute. count : ClassVar[int]     Class variable tracking the number of PyDMShellCommand instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMShellCommand(PyDMPushButtonBase, StyleSheetObject):\n    \"\"\"\n    PyDMShellCommand extends PyDMPushButtonBase to execute shell commands.\n\n    Attributes\n    ----------\n    show_confirm_dialog : Optional[bool]\n        If True, displays a confirmation dialog before executing the command.\n    confirm_message : Optional[str]\n        The message to display in the confirmation dialog.\n    run_commands_in_full_shell : Optional[bool]\n        If True, runs commands in a full shell environment.\n    environment_variables : Optional[str]\n        Environment variables to pass to the command.\n    show_icon : Optional[bool]\n        If True, displays an icon on the button.\n    redirect_command_output : Optional[bool]\n        If True, redirects the command output.\n    allow_multiple_executions : Optional[bool]\n        If True, permits multiple command executions.\n    titles : Optional[List[str]]\n        Titles associated with the commands (one per command).\n    command : Optional[List[str]]\n        The shell commands to execute.\n    count : ClassVar[int]\n        Class variable tracking the number of PyDMShellCommand instances.\n    \"\"\"\n\n    show_confirm_dialog: Optional[bool] = None\n    confirm_message: Optional[str] = None\n    run_commands_in_full_shell: Optional[bool] = None\n    environment_variables: Optional[str] = None\n    show_icon: Optional[bool] = None\n    redirect_command_output: Optional[bool] = None\n    allow_multiple_executions: Optional[bool] = None\n    titles: Optional[List[str]] = None\n    command: Optional[List[str]] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMShellCommand-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the PyDMShellCommand properties.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n        if self.show_confirm_dialog is not None:\n            properties.append(Bool(\"showConfirmDialog\", self.show_confirm_dialog).to_xml())\n        if self.confirm_message is not None:\n            properties.append(Str(\"confirmMessage\", self.confirm_message).to_xml())\n        if self.run_commands_in_full_shell is not None:\n            properties.append(Bool(\"runCommandsInFullShell\", self.run_commands_in_full_shell).to_xml())\n        if self.environment_variables is not None:\n            properties.append(Str(\"environmentVariables\", self.environment_variables).to_xml())\n        if self.show_icon is not None:\n            properties.append(Bool(\"showIcon\", self.show_icon).to_xml())\n        else:\n            properties.append(Bool(\"showIcon\", False).to_xml())\n        if self.redirect_command_output is not None:\n            properties.append(Bool(\"redirectCommandOutput\", self.redirect_command_output).to_xml())\n        if self.allow_multiple_executions is not None:\n            properties.append(Bool(\"allowMultipleExecutions\", self.allow_multiple_executions).to_xml())\n        if self.command is not None:\n            # Generate commands property if command is set\n            properties.append(StringList(\"commands\", self.command).to_xml())\n            # Generate titles property if titles is set, otherwise PyDM will use default titles\n            if self.titles is not None:\n                properties.append(StringList(\"titles\", self.titles).to_xml())\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMShellCommand.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMShellCommand-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.PyDMShellCommand.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the PyDMShellCommand properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMShellCommand-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the PyDMShellCommand properties.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n    if self.show_confirm_dialog is not None:\n        properties.append(Bool(\"showConfirmDialog\", self.show_confirm_dialog).to_xml())\n    if self.confirm_message is not None:\n        properties.append(Str(\"confirmMessage\", self.confirm_message).to_xml())\n    if self.run_commands_in_full_shell is not None:\n        properties.append(Bool(\"runCommandsInFullShell\", self.run_commands_in_full_shell).to_xml())\n    if self.environment_variables is not None:\n        properties.append(Str(\"environmentVariables\", self.environment_variables).to_xml())\n    if self.show_icon is not None:\n        properties.append(Bool(\"showIcon\", self.show_icon).to_xml())\n    else:\n        properties.append(Bool(\"showIcon\", False).to_xml())\n    if self.redirect_command_output is not None:\n        properties.append(Bool(\"redirectCommandOutput\", self.redirect_command_output).to_xml())\n    if self.allow_multiple_executions is not None:\n        properties.append(Bool(\"allowMultipleExecutions\", self.allow_multiple_executions).to_xml())\n    if self.command is not None:\n        # Generate commands property if command is set\n        properties.append(StringList(\"commands\", self.command).to_xml())\n        # Generate titles property if titles is set, otherwise PyDM will use default titles\n        if self.titles is not None:\n            properties.append(StringList(\"titles\", self.titles).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMSlider","title":"<code>PyDMSlider</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code></p> <p>Represents a PyDM slider widget for adjusting values interactively.</p>"},{"location":"reference/widgets/#widgets.PyDMSlider--attributes","title":"Attributes","text":"<p>orientation : Optional[str]     Slider orientation (\"Horizontal\" or \"Vertical\").</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMSlider(Alarmable):\n    \"\"\"\n    Represents a PyDM slider widget for adjusting values interactively.\n\n    Attributes\n    ----------\n    orientation : Optional[str]\n        Slider orientation (\"Horizontal\" or \"Vertical\").\n    \"\"\"\n\n    orientation: Optional[Str] = None\n    limitsFromDb: Optional[bool] = None\n    showLimitLabels: Optional[bool] = None\n    showValueLabel: Optional[bool] = None\n    min: Optional[int] = None\n    max: Optional[int] = None\n\n    def generate_properties(self):\n        \"\"\"\n        Generates a list of XML elements representing the slider's properties.\n\n        Returns\n        -------\n        List[ET.Element]\n            List of XML elements for serialization.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n\n        if self.orientation is not None:\n            properties.append(Enum(\"orientation\", f\"Qt::{self.orientation.capitalize()}\").to_xml())\n        if self.limitsFromDb is not None:\n            properties.append(Bool(\"userDefinedLimits\", not self.limitsFromDb).to_xml())\n        if not self.showLimitLabels:\n            properties.append(Bool(\"showLimitLabels\", False).to_xml())\n        if not self.showValueLabel:\n            properties.append(Bool(\"showValueLabel\", False).to_xml())\n        if self.min is not None:\n            properties.append(Int(\"userMinimum\", self.min).to_xml())\n        if self.max is not None:\n            properties.append(Int(\"userMaximum\", self.max).to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMSlider.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generates a list of XML elements representing the slider's properties.</p>"},{"location":"reference/widgets/#widgets.PyDMSlider.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     List of XML elements for serialization.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self):\n    \"\"\"\n    Generates a list of XML elements representing the slider's properties.\n\n    Returns\n    -------\n    List[ET.Element]\n        List of XML elements for serialization.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n\n    if self.orientation is not None:\n        properties.append(Enum(\"orientation\", f\"Qt::{self.orientation.capitalize()}\").to_xml())\n    if self.limitsFromDb is not None:\n        properties.append(Bool(\"userDefinedLimits\", not self.limitsFromDb).to_xml())\n    if not self.showLimitLabels:\n        properties.append(Bool(\"showLimitLabels\", False).to_xml())\n    if not self.showValueLabel:\n        properties.append(Bool(\"showValueLabel\", False).to_xml())\n    if self.min is not None:\n        properties.append(Int(\"userMinimum\", self.min).to_xml())\n    if self.max is not None:\n        properties.append(Int(\"userMaximum\", self.max).to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMWaveformPlot","title":"<code>PyDMWaveformPlot</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code>, <code>StyleSheetObject</code></p> <p>Represents a PyDM widget that displays a waveform plot (XY graph).</p> <p>This widget can be bound to one or more X and Y data channels.</p>"},{"location":"reference/widgets/#widgets.PyDMWaveformPlot--attributes","title":"Attributes","text":"<p>x_channel : Optional[List[str]]     List of process variable (PV) names for the X-axis data. y_channel : Optional[List[str]]     List of PV names for the Y-axis data. plot_name : Optional[str]     Title of the plot. color : Optional[RGBA]     Default RGBA color for the plot. minXRange : Optional[int]     Minimum value for the X-axis. minYRange : Optional[int]     Minimum value for the Y-axis. maxXRange : Optional[int]     Maximum value for the X-axis. maxYRange : Optional[int]     Maximum value for the Y-axis. plotColor : Optional[List[RGBA]]     List of colors for individual curves. xLabel : Optional[str]     Label for the X-axis. yLabel : Optional[str]     Label for the Y-axis. axisColor : Optional[RGBA]     Color of the axis lines. pointsize : Optional[int]     Font size for labels and titles. font : Optional[dict]     Font properties (e.g., {\"pointsize\": 12}). yAxisSrc : Optional[str]     Source of Y-axis scaling (\"fromUser\" disables auto-range). xAxisSrc : Optional[str]     Source of X-axis scaling.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMWaveformPlot(Alarmable, StyleSheetObject):\n    \"\"\"\n    Represents a PyDM widget that displays a waveform plot (XY graph).\n\n    This widget can be bound to one or more X and Y data channels.\n\n    Attributes\n    ----------\n    x_channel : Optional[List[str]]\n        List of process variable (PV) names for the X-axis data.\n    y_channel : Optional[List[str]]\n        List of PV names for the Y-axis data.\n    plot_name : Optional[str]\n        Title of the plot.\n    color : Optional[RGBA]\n        Default RGBA color for the plot.\n    minXRange : Optional[int]\n        Minimum value for the X-axis.\n    minYRange : Optional[int]\n        Minimum value for the Y-axis.\n    maxXRange : Optional[int]\n        Maximum value for the X-axis.\n    maxYRange : Optional[int]\n        Maximum value for the Y-axis.\n    plotColor : Optional[List[RGBA]]\n        List of colors for individual curves.\n    xLabel : Optional[str]\n        Label for the X-axis.\n    yLabel : Optional[str]\n        Label for the Y-axis.\n    axisColor : Optional[RGBA]\n        Color of the axis lines.\n    pointsize : Optional[int]\n        Font size for labels and titles.\n    font : Optional[dict]\n        Font properties (e.g., {\"pointsize\": 12}).\n    yAxisSrc : Optional[str]\n        Source of Y-axis scaling (\"fromUser\" disables auto-range).\n    xAxisSrc : Optional[str]\n        Source of X-axis scaling.\n    \"\"\"\n\n    x_channel: Optional[List[str]] = field(default_factory=list)\n    y_channel: Optional[List[str]] = field(default_factory=list)\n    plot_name: Optional[str] = None\n    color: Optional[RGBA] = None\n    minXRange: Optional[float] = 0\n    minYRange: Optional[float] = 0\n    maxXRange: Optional[float] = None\n    maxYRange: Optional[float] = None\n    plotColor: Optional[List[RGBA]] = field(default_factory=list)\n    xLabel: Optional[str] = None\n    yLabel: Optional[str] = None\n    axisColor: Optional[RGBA] = None\n    pointsize: Optional[int] = None\n    font = None\n    yAxisSrc: Optional[str] = None\n    xAxisSrc: Optional[str] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generates a list of XML elements representing the waveform plot's properties.\n\n        Returns:\n            List[ET.Element]: List of XML elements for serialization.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n\n        if self.plot_name is not None:\n            properties.append(\n                Str(\"name\", self.plot_name).to_xml()\n            )  # Possibly overrides other name (may need to remove other name for plots)\n        if self.color is not None:\n            properties.append(ColorObject(\"color\", *self.color).to_xml())\n        if self.minXRange is not None:\n            properties.append(Double(\"minXRange\", self.minXRange).to_xml())\n        if self.minYRange is not None:\n            properties.append(Double(\"minYRange\", self.minYRange).to_xml())\n        if self.maxXRange is not None:\n            properties.append(Double(\"maxXRange\", self.maxXRange).to_xml())\n        if self.maxYRange is not None:\n            properties.append(Double(\"maxYRange\", self.maxYRange).to_xml())\n        if self.yAxisSrc is not None and self.yAxisSrc == \"fromUser\":\n            self.auto_range = \"false\"\n        else:\n            self.auto_range = \"true\"\n        if (\n            self.yLabel is not None and self.maxYRange is not None\n        ):  # NOTE: The axes must be generated before the curves for the curves to display\n            yAxisString = (\n                \"{\"\n                '\"name\": \"Axis 1\", '\n                '\"orientation\": \"left\", '\n                f'\"label\": \"{self.yLabel}\", '\n                f'\"minRange\": {self.minYRange}, '\n                f'\"maxRange\": {self.maxYRange}, '\n                f'\"autoRange\": {self.auto_range}, '\n                '\"logMode\": false'\n                \"}\"\n            )\n            properties.append(StringList(\"yAxes\", [yAxisString]).to_xml())\n        elif self.auto_range == \"false\" and self.minXRange is not None and self.minYRange is not None:\n            yAxisString = (\n                \"{\"\n                '\"name\": \"Axis 1\", '\n                '\"orientation\": \"left\", '\n                f'\"minRange\": {self.minYRange}, '\n                f'\"maxRange\": {self.maxYRange}, '\n                f'\"autoRange\": {self.auto_range}, '\n                '\"logMode\": false'\n                \"}\"\n            )\n            properties.append(StringList(\"yAxes\", [yAxisString]).to_xml())\n        if self.x_channel or self.y_channel:\n            properties.append(StringList(\"curves\", self.get_curve_strings()).to_xml())\n        if self.plot_name is not None:\n            color = self.color or self.axisColor or (175, 175, 175, 255)\n            if self.font is not None:\n                size = self.font[\"pointsize\"]\n            else:\n                size = 12\n            properties.append(\n                Str(\n                    \"title\",\n                    (\n                        f'&lt;div style=\"text-align:center; color:{self.rgba_to_hex(*color)}; font-size:{size}pt;\"&gt;'\n                        f\"{self.plot_name}\"\n                        \"&lt;/div&gt;\"\n                    ),\n                ).to_xml()\n            )\n        if self.axisColor is not None:\n            properties.append(ColorObject(\"axisColor\", *self.axisColor).to_xml())\n        if self.xLabel is not None:\n            properties.append(StringList(\"xLabels\", [self.xLabel]).to_xml())\n\n        properties.append(Bool(\"useSharedAxis\", True).to_xml())\n        return properties\n\n    def get_curve_strings(self) -&gt; List[str]:\n        \"\"\"\n        Build JSON-like strings representing individual curve configurations.\n\n        Ensures that the x_channel, y_channel, and plotColor lists are padded\n        to equal length before constructing curve entries.\n\n        Returns\n        -------\n        List[str]\n            A list of JSON-style strings, one for each curve in the plot.\n        \"\"\"\n\n        lists = [self.x_channel, self.y_channel, self.plotColor]\n        max_len = max(len(lst) for lst in lists)\n        for i in range(max_len):\n            if len(self.x_channel) &lt;= i:\n                self.x_channel.append(\"\")\n            if len(self.y_channel) &lt;= i:\n                self.y_channel.append(\"\")\n            if len(self.plotColor) &lt;= i:\n                self.plotColor.append(\"\")\n\n        curve_string_list = []\n        for i in range(max_len):\n            curve_string = (\n                \"{\"\n                f'\"name\": \"\", '\n                f'\"x_channel\": \"{self.x_channel[i]}\", '\n                f'\"y_channel\": \"{self.y_channel[i]}\", '\n                f'\"color\": \"{self.rgba_to_hex(*self.plotColor[i])}\", '\n                f'\"yAxisName\": \"Axis 1\"'\n                \"}\"\n            )\n            curve_string_list.append(curve_string)\n        return curve_string_list\n\n    def rgba_to_hex(self, r, g, b, a=255) -&gt; str:\n        \"\"\"\n        Convert RGBA or RGB to a hex string in #RRGGBBAA format.\n\n        Parameters\n        ----------\n        r : int\n            Red component (0\u2013255)\n        g : int\n            Green component (0\u2013255)\n        b : int\n            Blue component (0\u2013255)\n        a : int, optional\n            Alpha component (0\u2013255), default is 255 (opaque)\n\n        Returns\n        -------\n        str\n            Hex color string like \"#00e0e0\"\n        \"\"\"\n        return f\"#{r:02x}{g:02x}{b:02x}\"\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMWaveformPlot.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generates a list of XML elements representing the waveform plot's properties.</p> <p>Returns:</p> Type Description <code>List[Element]</code> <p>List[ET.Element]: List of XML elements for serialization.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generates a list of XML elements representing the waveform plot's properties.\n\n    Returns:\n        List[ET.Element]: List of XML elements for serialization.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n\n    if self.plot_name is not None:\n        properties.append(\n            Str(\"name\", self.plot_name).to_xml()\n        )  # Possibly overrides other name (may need to remove other name for plots)\n    if self.color is not None:\n        properties.append(ColorObject(\"color\", *self.color).to_xml())\n    if self.minXRange is not None:\n        properties.append(Double(\"minXRange\", self.minXRange).to_xml())\n    if self.minYRange is not None:\n        properties.append(Double(\"minYRange\", self.minYRange).to_xml())\n    if self.maxXRange is not None:\n        properties.append(Double(\"maxXRange\", self.maxXRange).to_xml())\n    if self.maxYRange is not None:\n        properties.append(Double(\"maxYRange\", self.maxYRange).to_xml())\n    if self.yAxisSrc is not None and self.yAxisSrc == \"fromUser\":\n        self.auto_range = \"false\"\n    else:\n        self.auto_range = \"true\"\n    if (\n        self.yLabel is not None and self.maxYRange is not None\n    ):  # NOTE: The axes must be generated before the curves for the curves to display\n        yAxisString = (\n            \"{\"\n            '\"name\": \"Axis 1\", '\n            '\"orientation\": \"left\", '\n            f'\"label\": \"{self.yLabel}\", '\n            f'\"minRange\": {self.minYRange}, '\n            f'\"maxRange\": {self.maxYRange}, '\n            f'\"autoRange\": {self.auto_range}, '\n            '\"logMode\": false'\n            \"}\"\n        )\n        properties.append(StringList(\"yAxes\", [yAxisString]).to_xml())\n    elif self.auto_range == \"false\" and self.minXRange is not None and self.minYRange is not None:\n        yAxisString = (\n            \"{\"\n            '\"name\": \"Axis 1\", '\n            '\"orientation\": \"left\", '\n            f'\"minRange\": {self.minYRange}, '\n            f'\"maxRange\": {self.maxYRange}, '\n            f'\"autoRange\": {self.auto_range}, '\n            '\"logMode\": false'\n            \"}\"\n        )\n        properties.append(StringList(\"yAxes\", [yAxisString]).to_xml())\n    if self.x_channel or self.y_channel:\n        properties.append(StringList(\"curves\", self.get_curve_strings()).to_xml())\n    if self.plot_name is not None:\n        color = self.color or self.axisColor or (175, 175, 175, 255)\n        if self.font is not None:\n            size = self.font[\"pointsize\"]\n        else:\n            size = 12\n        properties.append(\n            Str(\n                \"title\",\n                (\n                    f'&lt;div style=\"text-align:center; color:{self.rgba_to_hex(*color)}; font-size:{size}pt;\"&gt;'\n                    f\"{self.plot_name}\"\n                    \"&lt;/div&gt;\"\n                ),\n            ).to_xml()\n        )\n    if self.axisColor is not None:\n        properties.append(ColorObject(\"axisColor\", *self.axisColor).to_xml())\n    if self.xLabel is not None:\n        properties.append(StringList(\"xLabels\", [self.xLabel]).to_xml())\n\n    properties.append(Bool(\"useSharedAxis\", True).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMWaveformPlot.get_curve_strings","title":"<code>get_curve_strings()</code>","text":"<p>Build JSON-like strings representing individual curve configurations.</p> <p>Ensures that the x_channel, y_channel, and plotColor lists are padded to equal length before constructing curve entries.</p>"},{"location":"reference/widgets/#widgets.PyDMWaveformPlot.get_curve_strings--returns","title":"Returns","text":"<p>List[str]     A list of JSON-style strings, one for each curve in the plot.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def get_curve_strings(self) -&gt; List[str]:\n    \"\"\"\n    Build JSON-like strings representing individual curve configurations.\n\n    Ensures that the x_channel, y_channel, and plotColor lists are padded\n    to equal length before constructing curve entries.\n\n    Returns\n    -------\n    List[str]\n        A list of JSON-style strings, one for each curve in the plot.\n    \"\"\"\n\n    lists = [self.x_channel, self.y_channel, self.plotColor]\n    max_len = max(len(lst) for lst in lists)\n    for i in range(max_len):\n        if len(self.x_channel) &lt;= i:\n            self.x_channel.append(\"\")\n        if len(self.y_channel) &lt;= i:\n            self.y_channel.append(\"\")\n        if len(self.plotColor) &lt;= i:\n            self.plotColor.append(\"\")\n\n    curve_string_list = []\n    for i in range(max_len):\n        curve_string = (\n            \"{\"\n            f'\"name\": \"\", '\n            f'\"x_channel\": \"{self.x_channel[i]}\", '\n            f'\"y_channel\": \"{self.y_channel[i]}\", '\n            f'\"color\": \"{self.rgba_to_hex(*self.plotColor[i])}\", '\n            f'\"yAxisName\": \"Axis 1\"'\n            \"}\"\n        )\n        curve_string_list.append(curve_string)\n    return curve_string_list\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMWaveformPlot.rgba_to_hex","title":"<code>rgba_to_hex(r, g, b, a=255)</code>","text":"<p>Convert RGBA or RGB to a hex string in #RRGGBBAA format.</p>"},{"location":"reference/widgets/#widgets.PyDMWaveformPlot.rgba_to_hex--parameters","title":"Parameters","text":"<p>r : int     Red component (0\u2013255) g : int     Green component (0\u2013255) b : int     Blue component (0\u2013255) a : int, optional     Alpha component (0\u2013255), default is 255 (opaque)</p>"},{"location":"reference/widgets/#widgets.PyDMWaveformPlot.rgba_to_hex--returns","title":"Returns","text":"<p>str     Hex color string like \"#00e0e0\"</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def rgba_to_hex(self, r, g, b, a=255) -&gt; str:\n    \"\"\"\n    Convert RGBA or RGB to a hex string in #RRGGBBAA format.\n\n    Parameters\n    ----------\n    r : int\n        Red component (0\u2013255)\n    g : int\n        Green component (0\u2013255)\n    b : int\n        Blue component (0\u2013255)\n    a : int, optional\n        Alpha component (0\u2013255), default is 255 (opaque)\n\n    Returns\n    -------\n    str\n        Hex color string like \"#00e0e0\"\n    \"\"\"\n    return f\"#{r:02x}{g:02x}{b:02x}\"\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMWaveformTable","title":"<code>PyDMWaveformTable</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code></p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass PyDMWaveformTable(Alarmable):\n    rowLabels: Optional[Str] = None\n    font: dict = field(default_factory=dict)\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generates a list of XML elements representing the pydmwaveformtable's properties.\n\n        Returns:\n            List[ET.Element]: List of XML elements for serialization.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n\n        if self.rowLabels is not None:\n            rowList = self.rowLabels.split(\", \")\n            for row in rowList:\n                properties.append(Row(row, self.font).to_xml())\n            properties.append(Column().to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.PyDMWaveformTable.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generates a list of XML elements representing the pydmwaveformtable's properties.</p> <p>Returns:</p> Type Description <code>List[Element]</code> <p>List[ET.Element]: List of XML elements for serialization.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generates a list of XML elements representing the pydmwaveformtable's properties.\n\n    Returns:\n        List[ET.Element]: List of XML elements for serialization.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n\n    if self.rowLabels is not None:\n        rowList = self.rowLabels.split(\", \")\n        for row in rowList:\n            properties.append(Row(row, self.font).to_xml())\n        properties.append(Column().to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.QComboBox","title":"<code>QComboBox</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Legible</code></p> <p>QComboBox represents a combo box widget with various configurable properties.</p>"},{"location":"reference/widgets/#widgets.QComboBox--attributes","title":"Attributes","text":"<p>editable : Optional[bool]     If True, the combo box is editable. current_text : Optional[str]     The current text displayed in the combo box. max_visible_items : Optional[int]     Maximum number of visible items in the dropdown. max_count : Optional[int]     Maximum number of items allowed. insert_policy : Optional[str]     The policy for inserting new items. size_adjust_policy : Optional[str]     The policy for adjusting the size. minimum_contents_length : Optional[int]     The minimum content length. icon_size : Optional[str]     The size for the icons. duplicates_enabled : Optional[bool]     If True, duplicate items are allowed. frame : Optional[bool]     If True, the combo box is framed. model_column : Optional[int]     The model column used. count : ClassVar[int]     Class variable tracking the number of QComboBox instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass QComboBox(Legible):\n    \"\"\"\n    QComboBox represents a combo box widget with various configurable properties.\n\n    Attributes\n    ----------\n    editable : Optional[bool]\n        If True, the combo box is editable.\n    current_text : Optional[str]\n        The current text displayed in the combo box.\n    max_visible_items : Optional[int]\n        Maximum number of visible items in the dropdown.\n    max_count : Optional[int]\n        Maximum number of items allowed.\n    insert_policy : Optional[str]\n        The policy for inserting new items.\n    size_adjust_policy : Optional[str]\n        The policy for adjusting the size.\n    minimum_contents_length : Optional[int]\n        The minimum content length.\n    icon_size : Optional[str]\n        The size for the icons.\n    duplicates_enabled : Optional[bool]\n        If True, duplicate items are allowed.\n    frame : Optional[bool]\n        If True, the combo box is framed.\n    model_column : Optional[int]\n        The model column used.\n    count : ClassVar[int]\n        Class variable tracking the number of QComboBox instances.\n    \"\"\"\n\n    editable: Optional[bool] = None\n    current_text: Optional[str] = None\n    max_visible_items: Optional[int] = None\n    max_count: Optional[int] = None\n    insert_policy: Optional[str] = None\n    size_adjust_policy: Optional[str] = None\n    minimum_contents_length: Optional[int] = None\n    icon_size: Optional[str] = None\n    duplicates_enabled: Optional[bool] = None\n    frame: Optional[bool] = None\n    model_column: Optional[int] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate QComboBox-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the QComboBox properties.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n        if self.editable is not None:\n            properties.append(Bool(\"editable\", self.editable).to_xml())\n        if self.current_text is not None:\n            properties.append(Str(\"currentText\", self.current_text).to_xml())\n        if self.max_visible_items is not None:\n            properties.append(Int(\"maxVisibleItems\", self.max_visible_items).to_xml())\n        if self.max_count is not None:\n            properties.append(Int(\"maxCount\", self.max_count).to_xml())\n        if self.insert_policy is not None:\n            properties.append(Str(\"insertPolicy\", self.insert_policy).to_xml())\n        if self.size_adjust_policy is not None:\n            properties.append(Str(\"sizeAdjustPolicy\", self.size_adjust_policy).to_xml())\n        if self.minimum_contents_length is not None:\n            properties.append(Int(\"minimumContentsLength\", self.minimum_contents_length).to_xml())\n        if self.icon_size is not None:\n            properties.append(Str(\"iconSize\", self.icon_size).to_xml())\n        if self.duplicates_enabled is not None:\n            properties.append(Bool(\"duplicatesEnabled\", self.duplicates_enabled).to_xml())\n        if self.frame is not None:\n            properties.append(Bool(\"frame\", self.frame).to_xml())\n        if self.model_column is not None:\n            properties.append(Int(\"modelColumn\", self.model_column).to_xml())\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.QComboBox.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate QComboBox-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.QComboBox.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the QComboBox properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate QComboBox-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the QComboBox properties.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n    if self.editable is not None:\n        properties.append(Bool(\"editable\", self.editable).to_xml())\n    if self.current_text is not None:\n        properties.append(Str(\"currentText\", self.current_text).to_xml())\n    if self.max_visible_items is not None:\n        properties.append(Int(\"maxVisibleItems\", self.max_visible_items).to_xml())\n    if self.max_count is not None:\n        properties.append(Int(\"maxCount\", self.max_count).to_xml())\n    if self.insert_policy is not None:\n        properties.append(Str(\"insertPolicy\", self.insert_policy).to_xml())\n    if self.size_adjust_policy is not None:\n        properties.append(Str(\"sizeAdjustPolicy\", self.size_adjust_policy).to_xml())\n    if self.minimum_contents_length is not None:\n        properties.append(Int(\"minimumContentsLength\", self.minimum_contents_length).to_xml())\n    if self.icon_size is not None:\n        properties.append(Str(\"iconSize\", self.icon_size).to_xml())\n    if self.duplicates_enabled is not None:\n        properties.append(Bool(\"duplicatesEnabled\", self.duplicates_enabled).to_xml())\n    if self.frame is not None:\n        properties.append(Bool(\"frame\", self.frame).to_xml())\n    if self.model_column is not None:\n        properties.append(Int(\"modelColumn\", self.model_column).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.QLabel","title":"<code>QLabel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Legible</code>, <code>StyleSheetObject</code></p> <p>QLabel is a label widget that supports numerical precision, unit display, tool tip text, and a configurable frame shape.</p>"},{"location":"reference/widgets/#widgets.QLabel--attributes","title":"Attributes","text":"<p>precision : Optional[int]     The numerical precision to display (if applicable). show_units : Optional[bool]     Flag to indicate if units should be displayed. tool_tip : Optional[str]     The tooltip text for the label. frame_shape : Optional[str]     The frame shape style for the label. count : ClassVar[int]     Class variable tracking the number of QLabel instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass QLabel(Legible, StyleSheetObject):\n    \"\"\"\n    QLabel is a label widget that supports numerical precision, unit display,\n    tool tip text, and a configurable frame shape.\n\n    Attributes\n    ----------\n    precision : Optional[int]\n        The numerical precision to display (if applicable).\n    show_units : Optional[bool]\n        Flag to indicate if units should be displayed.\n    tool_tip : Optional[str]\n        The tooltip text for the label.\n    frame_shape : Optional[str]\n        The frame shape style for the label.\n    count : ClassVar[int]\n        Class variable tracking the number of QLabel instances.\n    \"\"\"\n\n    precision: Optional[int] = None\n    show_units: Optional[bool] = None\n    tool_tip: Optional[str] = None\n    frame_shape: Optional[str] = None\n    alignment: Optional[str] = None\n    useDisplayBg: Optional[bool] = None\n    filename: Optional[str] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate QLabel-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the properties of the QLabel.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n        if self.precision is not None:\n            properties.append(Int(\"precision\", self.precision).to_xml())\n        if self.show_units is not None:\n            properties.append(Bool(\"showUnits\", self.show_units).to_xml())\n        if self.tool_tip is not None:\n            properties.append(Str(\"toolTip\", self.tool_tip).to_xml())\n        if self.frame_shape is not None:\n            properties.append(Str(\"frameShape\", self.frame_shape).to_xml())\n        if self.alignment is not None:\n            properties.append(Alignment(self.alignment).to_xml())\n        if self.filename is not None and self.name.startswith(\"activePngClass\"):\n            properties.append(PixMap(self.filename).to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.QLabel.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate QLabel-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.QLabel.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the properties of the QLabel.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate QLabel-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the properties of the QLabel.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n    if self.precision is not None:\n        properties.append(Int(\"precision\", self.precision).to_xml())\n    if self.show_units is not None:\n        properties.append(Bool(\"showUnits\", self.show_units).to_xml())\n    if self.tool_tip is not None:\n        properties.append(Str(\"toolTip\", self.tool_tip).to_xml())\n    if self.frame_shape is not None:\n        properties.append(Str(\"frameShape\", self.frame_shape).to_xml())\n    if self.alignment is not None:\n        properties.append(Alignment(self.alignment).to_xml())\n    if self.filename is not None and self.name.startswith(\"activePngClass\"):\n        properties.append(PixMap(self.filename).to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.QPushButton","title":"<code>QPushButton</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Legible</code>, <code>StyleSheetObject</code></p> <p>QPushButton is a button widget that supports text, icons, and various behavioral properties.</p>"},{"location":"reference/widgets/#widgets.QPushButton--attributes","title":"Attributes","text":"<p>text : Optional[str]     The label text displayed on the button. auto_default : Optional[bool]     Determines if the button should automatically become the default button. default : Optional[bool]     Indicates if the button is the default action. flat : Optional[bool]     If True, the button is drawn with a flat appearance. tool_tip : Optional[str]     The tooltip text that appears when hovering over the button. icon : Optional[str]     The icon name or path displayed on the button. checkable : Optional[bool]     Specifies whether the button supports a toggled (checked/unchecked) state. checked : Optional[bool]     The initial checked state of the button. count : ClassVar[int]     A class variable tracking the number of QPushButton instances.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass QPushButton(\n    Legible, StyleSheetObject\n):  # TODO: This creates a stylesheet for children classes but is overriden later (may need to remove to prevent repeated properties)\n    \"\"\"\n    QPushButton is a button widget that supports text, icons, and various behavioral properties.\n\n    Attributes\n    ----------\n    text : Optional[str]\n        The label text displayed on the button.\n    auto_default : Optional[bool]\n        Determines if the button should automatically become the default button.\n    default : Optional[bool]\n        Indicates if the button is the default action.\n    flat : Optional[bool]\n        If True, the button is drawn with a flat appearance.\n    tool_tip : Optional[str]\n        The tooltip text that appears when hovering over the button.\n    icon : Optional[str]\n        The icon name or path displayed on the button.\n    checkable : Optional[bool]\n        Specifies whether the button supports a toggled (checked/unchecked) state.\n    checked : Optional[bool]\n        The initial checked state of the button.\n    count : ClassVar[int]\n        A class variable tracking the number of QPushButton instances.\n    \"\"\"\n\n    auto_default: Optional[bool] = None\n    default: Optional[bool] = None\n    flat: Optional[bool] = None\n    tool_tip: Optional[str] = None\n    icon: Optional[str] = None\n    checkable: Optional[bool] = None\n    checked: Optional[bool] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate QPushButton-specific properties for XML serialization.\n\n        This method extends the properties generated by the superclass by appending\n        QPushButton-specific properties if they are set.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the QPushButton properties.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n\n        if self.auto_default is not None:\n            properties.append(Bool(\"autoDefault\", self.auto_default).to_xml())\n        if self.default is not None:\n            properties.append(Bool(\"default\", self.default).to_xml())\n        if self.flat is not None:\n            properties.append(Bool(\"flat\", self.flat).to_xml())\n        if self.tool_tip is not None:\n            properties.append(Str(\"toolTip\", self.tool_tip).to_xml())\n        if self.icon is not None:\n            properties.append(Str(\"icon\", self.icon).to_xml())\n        if self.checkable is not None:\n            properties.append(Bool(\"checkable\", self.checkable).to_xml())\n        if self.checked is not None:\n            properties.append(Bool(\"checked\", self.checked).to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.QPushButton.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate QPushButton-specific properties for XML serialization.</p> <p>This method extends the properties generated by the superclass by appending QPushButton-specific properties if they are set.</p>"},{"location":"reference/widgets/#widgets.QPushButton.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the QPushButton properties.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate QPushButton-specific properties for XML serialization.\n\n    This method extends the properties generated by the superclass by appending\n    QPushButton-specific properties if they are set.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the QPushButton properties.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n\n    if self.auto_default is not None:\n        properties.append(Bool(\"autoDefault\", self.auto_default).to_xml())\n    if self.default is not None:\n        properties.append(Bool(\"default\", self.default).to_xml())\n    if self.flat is not None:\n        properties.append(Bool(\"flat\", self.flat).to_xml())\n    if self.tool_tip is not None:\n        properties.append(Str(\"toolTip\", self.tool_tip).to_xml())\n    if self.icon is not None:\n        properties.append(Str(\"icon\", self.icon).to_xml())\n    if self.checkable is not None:\n        properties.append(Bool(\"checkable\", self.checkable).to_xml())\n    if self.checked is not None:\n        properties.append(Bool(\"checked\", self.checked).to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.QTabWidget","title":"<code>QTabWidget</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code></p> <p>PyDMTabWidget is a container widget that can hold tabWidgets. It inherits from Alarmable to support alarm-related features.</p>"},{"location":"reference/widgets/#widgets.QTabWidget--attributes","title":"Attributes","text":"<p>frameShape : Optional[str]     The shape of the frame. frameShadow : Optional[str]     The shadow style of the frame. lineWidth : Optional[int]     The width of the frame's line. midLineWidth : Optional[int]     The width of the mid-line of the frame. disableOnDisconnect : Optional[bool]     If True, disables the frame on disconnect. tabs : List[str]     A list of child tab widgets.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass QTabWidget(Alarmable):\n    \"\"\"\n    PyDMTabWidget is a container widget that can hold tabWidgets.\n    It inherits from Alarmable to support alarm-related features.\n\n    Attributes\n    ----------\n    frameShape : Optional[str]\n        The shape of the frame.\n    frameShadow : Optional[str]\n        The shadow style of the frame.\n    lineWidth : Optional[int]\n        The width of the frame's line.\n    midLineWidth : Optional[int]\n        The width of the mid-line of the frame.\n    disableOnDisconnect : Optional[bool]\n        If True, disables the frame on disconnect.\n    tabs : List[str]\n        A list of child tab widgets.\n    \"\"\"\n\n    frameShape: Optional[str] = None\n    frameShadow: Optional[str] = None\n    lineWidth: Optional[int] = None\n    midLineWidth: Optional[int] = None\n    disableOnDisconnect: Optional[bool] = None\n\n    tabs: List[str] = field(default_factory=list)\n    children: List[\"PyDMFrame\"] = field(default_factory=list)\n    embeddedHeight: Optional[int] = None\n    embeddedWidth: Optional[int] = None\n\n    def add_child(self, child) -&gt; None:\n        \"\"\"\n        Add a child widget to this frame's internal list.\n\n        Parameters\n        ----------\n        child : PyDMFrame\n            The child widget to add.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.children.append(child)\n\n    def to_xml(self) -&gt; ET.Element:\n        \"\"\"\n        Serialize the PyDMTabWidget and its children to an XML element.\n\n        Returns\n        -------\n        ET.Element\n            The XML element representing this PyDMFrame and its children.\n        \"\"\"\n        widget_el: ET.Element = super().to_xml()\n\n        for child in self.children:\n            widget_el.append(child.to_xml())\n\n        return widget_el\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate PyDMFrame-specific properties for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the properties of this PyDMFrame.\n        \"\"\"\n        if self.embeddedHeight is not None:\n            self.height += self.embeddedHeight\n\n        properties: List[ET.Element] = super().generate_properties()\n\n        if self.frameShape is not None:\n            properties.append(Str(\"frameShape\", self.frameShape).to_xml())\n        if self.frameShadow is not None:\n            properties.append(Str(\"frameShadow\", self.frameShadow).to_xml())\n        if self.lineWidth is not None:\n            properties.append(Int(\"lineWidth\", self.lineWidth).to_xml())\n        if self.midLineWidth is not None:\n            properties.append(Int(\"midLineWidth\", self.midLineWidth).to_xml())\n        if self.disableOnDisconnect is not None:\n            properties.append(Bool(\"disableOnDisconnect\", self.disableOnDisconnect).to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.QTabWidget.add_child","title":"<code>add_child(child)</code>","text":"<p>Add a child widget to this frame's internal list.</p>"},{"location":"reference/widgets/#widgets.QTabWidget.add_child--parameters","title":"Parameters","text":"<p>child : PyDMFrame     The child widget to add.</p>"},{"location":"reference/widgets/#widgets.QTabWidget.add_child--returns","title":"Returns","text":"<p>None</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def add_child(self, child) -&gt; None:\n    \"\"\"\n    Add a child widget to this frame's internal list.\n\n    Parameters\n    ----------\n    child : PyDMFrame\n        The child widget to add.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.children.append(child)\n</code></pre>"},{"location":"reference/widgets/#widgets.QTabWidget.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate PyDMFrame-specific properties for XML serialization.</p>"},{"location":"reference/widgets/#widgets.QTabWidget.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the properties of this PyDMFrame.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate PyDMFrame-specific properties for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the properties of this PyDMFrame.\n    \"\"\"\n    if self.embeddedHeight is not None:\n        self.height += self.embeddedHeight\n\n    properties: List[ET.Element] = super().generate_properties()\n\n    if self.frameShape is not None:\n        properties.append(Str(\"frameShape\", self.frameShape).to_xml())\n    if self.frameShadow is not None:\n        properties.append(Str(\"frameShadow\", self.frameShadow).to_xml())\n    if self.lineWidth is not None:\n        properties.append(Int(\"lineWidth\", self.lineWidth).to_xml())\n    if self.midLineWidth is not None:\n        properties.append(Int(\"midLineWidth\", self.midLineWidth).to_xml())\n    if self.disableOnDisconnect is not None:\n        properties.append(Bool(\"disableOnDisconnect\", self.disableOnDisconnect).to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.QTabWidget.to_xml","title":"<code>to_xml()</code>","text":"<p>Serialize the PyDMTabWidget and its children to an XML element.</p>"},{"location":"reference/widgets/#widgets.QTabWidget.to_xml--returns","title":"Returns","text":"<p>ET.Element     The XML element representing this PyDMFrame and its children.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def to_xml(self) -&gt; ET.Element:\n    \"\"\"\n    Serialize the PyDMTabWidget and its children to an XML element.\n\n    Returns\n    -------\n    ET.Element\n        The XML element representing this PyDMFrame and its children.\n    \"\"\"\n    widget_el: ET.Element = super().to_xml()\n\n    for child in self.children:\n        widget_el.append(child.to_xml())\n\n    return widget_el\n</code></pre>"},{"location":"reference/widgets/#widgets.QTableWidget","title":"<code>QTableWidget</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code>, <code>Drawable</code>, <code>StyleSheetObject</code></p> <p>Represents a table widget with optional frame and line styling properties.</p> <p>Attributes:</p> Name Type Description <code>frameShape</code> <code>Optional[str]</code> <p>Shape of the frame (e.g., 'Box', 'Panel').</p> <code>frameShadow</code> <code>Optional[str]</code> <p>Style of the frame's shadow (e.g., 'Raised').</p> <code>lineWidth</code> <code>Optional[int]</code> <p>Width of the outer frame lines.</p> <code>midLineWidth</code> <code>Optional[int]</code> <p>Width of the mid-line frame.</p> <code>disableOnDisconnect</code> <code>Optional[bool]</code> <p>Whether to disable the widget if disconnected.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass QTableWidget(Alarmable, Drawable, StyleSheetObject):\n    \"\"\"\n    Represents a table widget with optional frame and line styling properties.\n\n    Attributes:\n        frameShape (Optional[str]): Shape of the frame (e.g., 'Box', 'Panel').\n        frameShadow (Optional[str]): Style of the frame's shadow (e.g., 'Raised').\n        lineWidth (Optional[int]): Width of the outer frame lines.\n        midLineWidth (Optional[int]): Width of the mid-line frame.\n        disableOnDisconnect (Optional[bool]): Whether to disable the widget if disconnected.\n    \"\"\"\n\n    frameShape: Optional[str] = None\n    frameShadow: Optional[str] = None\n    lineWidth: Optional[int] = None\n    midLineWidth: Optional[int] = None\n    disableOnDisconnect: Optional[bool] = None\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generates a list of XML elements representing the widget's properties.\n\n        Returns:\n            List[ET.Element]: List of XML elements for serialization.\n        \"\"\"\n\n        properties: List[ET.Element] = super().generate_properties()\n\n        if self.frameShape is not None:\n            properties.append(Str(\"frameShape\", self.frameShape).to_xml())\n        if self.frameShadow is not None:\n            properties.append(Str(\"frameShadow\", self.frameShadow).to_xml())\n        if self.lineWidth is not None:\n            properties.append(Int(\"lineWidth\", self.lineWidth).to_xml())\n        if self.midLineWidth is not None:\n            properties.append(Int(\"midLineWidth\", self.midLineWidth).to_xml())\n        if self.disableOnDisconnect is not None:\n            properties.append(Bool(\"disableOnDisconnect\", self.disableOnDisconnect).to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.QTableWidget.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generates a list of XML elements representing the widget's properties.</p> <p>Returns:</p> Type Description <code>List[Element]</code> <p>List[ET.Element]: List of XML elements for serialization.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generates a list of XML elements representing the widget's properties.\n\n    Returns:\n        List[ET.Element]: List of XML elements for serialization.\n    \"\"\"\n\n    properties: List[ET.Element] = super().generate_properties()\n\n    if self.frameShape is not None:\n        properties.append(Str(\"frameShape\", self.frameShape).to_xml())\n    if self.frameShadow is not None:\n        properties.append(Str(\"frameShadow\", self.frameShadow).to_xml())\n    if self.lineWidth is not None:\n        properties.append(Int(\"lineWidth\", self.lineWidth).to_xml())\n    if self.midLineWidth is not None:\n        properties.append(Int(\"midLineWidth\", self.midLineWidth).to_xml())\n    if self.disableOnDisconnect is not None:\n        properties.append(Bool(\"disableOnDisconnect\", self.disableOnDisconnect).to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.QWidget","title":"<code>QWidget</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Alarmable</code></p> <p>QWidget is a base class for creating a QWidget that can be used as a child in other PyDM widgets like PyDMTabWidget.</p>"},{"location":"reference/widgets/#widgets.QWidget--attributes","title":"Attributes","text":"<p>title : Optional[str]     The title of the tab associated with this QWidget. children : List[Alarmable]     The list of child widgets within this QWidget.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>@dataclass\nclass QWidget(Alarmable):\n    \"\"\"\n    QWidget is a base class for creating a QWidget that can be used\n    as a child in other PyDM widgets like PyDMTabWidget.\n\n    Attributes\n    ----------\n    title : Optional[str]\n        The title of the tab associated with this QWidget.\n    children : List[Alarmable]\n        The list of child widgets within this QWidget.\n    \"\"\"\n\n    title: Optional[str] = None\n    children: List[Alarmable] = field(default_factory=list)\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate properties specific to the QWidget for XML serialization.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing the properties of this QWidget.\n        \"\"\"\n        # properties: List[ET.Element] = super().generate_properties()\n        properties: List[ET.Element] = []\n\n        if self.title is not None:\n            title_element = ET.Element(\"attribute\", name=\"title\")\n            title_string_element = ET.Element(\"string\")\n            title_string_element.text = self.title\n            title_element.append(title_string_element)\n            properties.append(title_element)\n\n        return properties\n\n    def add_child(self, child) -&gt; None:\n        \"\"\"\n        Add a child widget to this frame's internal list.\n\n        Parameters\n        ----------\n        child : PyDMFrame\n            The child widget to add.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.children.append(child)\n\n    def to_xml(self) -&gt; ET.Element:\n        \"\"\"\n        Serialize the PyDMTabWidget and its children to an XML element.\n\n        Returns\n        -------\n        ET.Element\n            The XML element representing this PyDMFrame and its children.\n        \"\"\"\n        widget_el: ET.Element = super().to_xml()\n\n        for child in self.children:\n            widget_el.append(child.to_xml())\n\n        return widget_el\n</code></pre>"},{"location":"reference/widgets/#widgets.QWidget.add_child","title":"<code>add_child(child)</code>","text":"<p>Add a child widget to this frame's internal list.</p>"},{"location":"reference/widgets/#widgets.QWidget.add_child--parameters","title":"Parameters","text":"<p>child : PyDMFrame     The child widget to add.</p>"},{"location":"reference/widgets/#widgets.QWidget.add_child--returns","title":"Returns","text":"<p>None</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def add_child(self, child) -&gt; None:\n    \"\"\"\n    Add a child widget to this frame's internal list.\n\n    Parameters\n    ----------\n    child : PyDMFrame\n        The child widget to add.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.children.append(child)\n</code></pre>"},{"location":"reference/widgets/#widgets.QWidget.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate properties specific to the QWidget for XML serialization.</p>"},{"location":"reference/widgets/#widgets.QWidget.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing the properties of this QWidget.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate properties specific to the QWidget for XML serialization.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing the properties of this QWidget.\n    \"\"\"\n    # properties: List[ET.Element] = super().generate_properties()\n    properties: List[ET.Element] = []\n\n    if self.title is not None:\n        title_element = ET.Element(\"attribute\", name=\"title\")\n        title_string_element = ET.Element(\"string\")\n        title_string_element.text = self.title\n        title_element.append(title_string_element)\n        properties.append(title_element)\n\n    return properties\n</code></pre>"},{"location":"reference/widgets/#widgets.QWidget.to_xml","title":"<code>to_xml()</code>","text":"<p>Serialize the PyDMTabWidget and its children to an XML element.</p>"},{"location":"reference/widgets/#widgets.QWidget.to_xml--returns","title":"Returns","text":"<p>ET.Element     The XML element representing this PyDMFrame and its children.</p> Source code in <code>pydmconverter/widgets.py</code> <pre><code>def to_xml(self) -&gt; ET.Element:\n    \"\"\"\n    Serialize the PyDMTabWidget and its children to an XML element.\n\n    Returns\n    -------\n    ET.Element\n        The XML element representing this PyDMFrame and its children.\n    \"\"\"\n    widget_el: ET.Element = super().to_xml()\n\n    for child in self.children:\n        widget_el.append(child.to_xml())\n\n    return widget_el\n</code></pre>"},{"location":"reference/widgets_helpers/","title":"Widgets Helpers","text":""},{"location":"reference/widgets_helpers/#widgets_helpers.Alarmable","title":"<code>Alarmable</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Controllable</code></p> <p>Represents a widget that changes appearance based on an EPICS alarm state.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Alarmable--attributes","title":"Attributes","text":"<p>alarm_sensitive_content : bool     Whether the content is alarm sensitive. alarm_sensitive_border : bool     Whether the border is alarm sensitive.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Alarmable(Controllable):\n    \"\"\"\n    Represents a widget that changes appearance based on an EPICS alarm state.\n\n    Attributes\n    ----------\n    alarm_sensitive_content : bool\n        Whether the content is alarm sensitive.\n    alarm_sensitive_border : bool\n        Whether the border is alarm sensitive.\n    \"\"\"\n\n    alarm_sensitive_content: bool = ALARM_CONTENT_DEFAULT\n    alarm_sensitive_border: bool = ALARM_BORDER_DEFAULT\n    useDisplayBg: Optional[bool] = None\n\n    def generate_properties(self) -&gt; List[etree.Element]:\n        \"\"\"\n        Generate XML properties for the alarmable widget.\n\n        Returns\n        -------\n        List[etree.Element]\n            A list containing geometry, channel, tooltip, and alarm properties.\n        \"\"\"\n        properties: List[etree.Element] = super().generate_properties()\n        properties.append(Bool(\"alarmSensitiveContent\", self.alarm_sensitive_content).to_xml())\n        properties.append(Bool(\"alarmSensitiveBorder\", self.alarm_sensitive_border).to_xml())\n        if self.useDisplayBg is not None:\n            properties.append(Bool(\"useDisplayBg\", self.useDisplayBg).to_xml())\n        return properties\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Alarmable.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate XML properties for the alarmable widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Alarmable.generate_properties--returns","title":"Returns","text":"<p>List[etree.Element]     A list containing geometry, channel, tooltip, and alarm properties.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def generate_properties(self) -&gt; List[etree.Element]:\n    \"\"\"\n    Generate XML properties for the alarmable widget.\n\n    Returns\n    -------\n    List[etree.Element]\n        A list containing geometry, channel, tooltip, and alarm properties.\n    \"\"\"\n    properties: List[etree.Element] = super().generate_properties()\n    properties.append(Bool(\"alarmSensitiveContent\", self.alarm_sensitive_content).to_xml())\n    properties.append(Bool(\"alarmSensitiveBorder\", self.alarm_sensitive_border).to_xml())\n    if self.useDisplayBg is not None:\n        properties.append(Bool(\"useDisplayBg\", self.useDisplayBg).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Alignment","title":"<code>Alignment</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents alignment properties for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Alignment--attributes","title":"Attributes","text":"<p>alignment : str     The alignment value (e.g., 'left', 'center').</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Alignment(XMLConvertible):\n    \"\"\"\n    Represents alignment properties for a widget.\n\n    Attributes\n    ----------\n    alignment : str\n        The alignment value (e.g., 'left', 'center').\n    \"\"\"\n\n    alignment: str\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the alignment property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the alignment.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"alignment\"})\n        set_tag: etree.Element = etree.SubElement(prop, \"set\")\n        if self.alignment == \"center\":\n            set_tag.text = \"Qt::AlignHCenter|Qt::AlignVCenter\"\n        else:\n            set_tag.text = f\"Qt::Align{self.alignment.capitalize()}|Qt::AlignVCenter\"\n        if self.alignment == \"center\":\n            set_tag.text = \"Qt::AlignHCenter|Qt::AlignVCenter\"\n        else:\n            set_tag.text = f\"Qt::Align{self.alignment.capitalize()}|Qt::AlignVCenter\"\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Alignment.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the alignment property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Alignment.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the alignment.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the alignment property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the alignment.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"alignment\"})\n    set_tag: etree.Element = etree.SubElement(prop, \"set\")\n    if self.alignment == \"center\":\n        set_tag.text = \"Qt::AlignHCenter|Qt::AlignVCenter\"\n    else:\n        set_tag.text = f\"Qt::Align{self.alignment.capitalize()}|Qt::AlignVCenter\"\n    if self.alignment == \"center\":\n        set_tag.text = \"Qt::AlignHCenter|Qt::AlignVCenter\"\n    else:\n        set_tag.text = f\"Qt::Align{self.alignment.capitalize()}|Qt::AlignVCenter\"\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Bool","title":"<code>Bool</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a boolean property.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Bool--attributes","title":"Attributes","text":"<p>name : str     The name of the property. value : bool     The boolean value.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Bool(XMLConvertible):\n    \"\"\"\n    Represents a boolean property.\n\n    Attributes\n    ----------\n    name : str\n        The name of the property.\n    value : bool\n        The boolean value.\n    \"\"\"\n\n    name: str\n    value: bool\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the boolean property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the boolean.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n        bool_tag: etree.Element = etree.SubElement(prop, \"bool\")\n        bool_tag.text = \"true\" if self.value else \"false\"\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Bool.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the boolean property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Bool.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the boolean.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the boolean property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the boolean.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n    bool_tag: etree.Element = etree.SubElement(prop, \"bool\")\n    bool_tag.text = \"true\" if self.value else \"false\"\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.BoolRule","title":"<code>BoolRule</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a simple boolean rule for widget properties.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.BoolRule--attributes","title":"Attributes","text":"<p>rule_type : str     The type of rule (e.g., \"Visible\", \"Enable\"). channel : str     The channel address used as input for the rule. initial_value : bool, optional     The default value for the rule when no condition is met. Defaults to True. show_on_true : bool, optional     Determines whether the rule evaluates to true when the condition is satisfied. Defaults to True. visMin : int, optional     Minimum threshold value for a channel to be considered \"active\". Used for range-based visibility rules. visMax : int, optional     Maximum threshold value for a channel to be considered \"active\". Used for range-based visibility rules. notes : str, optional     Additional metadata or notes about the rule.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass BoolRule(XMLConvertible):\n    \"\"\"\n    Represents a simple boolean rule for widget properties.\n\n    Attributes\n    ----------\n    rule_type : str\n        The type of rule (e.g., \"Visible\", \"Enable\").\n    channel : str\n        The channel address used as input for the rule.\n    initial_value : bool, optional\n        The default value for the rule when no condition is met. Defaults to True.\n    show_on_true : bool, optional\n        Determines whether the rule evaluates to true when the condition is satisfied. Defaults to True.\n    visMin : int, optional\n        Minimum threshold value for a channel to be considered \"active\". Used for range-based visibility rules.\n    visMax : int, optional\n        Maximum threshold value for a channel to be considered \"active\". Used for range-based visibility rules.\n    notes : str, optional\n        Additional metadata or notes about the rule.\n    \"\"\"\n\n    rule_type: str\n    channel: str\n    initial_value: Optional[bool] = True\n    show_on_true: Optional[bool] = True\n    visMin: Optional[int] = None\n    visMax: Optional[int] = None\n    notes: Optional[str] = \"\"\n\n    def to_string(self):\n        \"\"\"\n        Convert the rule properties to a string.\n\n        Returns\n        -------\n        str\n            A string representing the rule.\n        \"\"\"\n        if self.visMin is not None and self.visMax is not None:\n            show_on_true_string = f\"True if float(ch[0]) &gt;= {self.visMin} and float(ch[0]) &lt; {self.visMax} else False\"\n            show_on_false_string = f\"False if float(ch[0]) &gt;= {self.visMin} and float(ch[0]) &lt; {self.visMax} else True\"\n        else:\n            show_on_true_string = \"True if ch[0]==1 else False\"\n            show_on_false_string = \"True if ch[0]!=1 else False\"\n        expression = show_on_true_string if self.show_on_true else show_on_false_string\n\n        output_string = (\n            \"{\"\n            f'\"name\": \"{self.rule_type}_{self.channel}\", '\n            f'\"property\": \"{self.rule_type}\", '\n            f'\"initial_value\": \"{self.initial_value}\", '\n            f'\"expression\": \"{expression}\", '\n            '\"channels\": ['\n            \"{\"\n            f'\"channel\": \"{self.channel}\", '\n            '\"trigger\": true, '\n            '\"use_enum\": false'\n            \"}\"\n            \"], \"\n            '\"notes\": \"{self.notes}\"'\n            \"}\"\n        )\n        return output_string\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.BoolRule.to_string","title":"<code>to_string()</code>","text":"<p>Convert the rule properties to a string.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.BoolRule.to_string--returns","title":"Returns","text":"<p>str     A string representing the rule.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_string(self):\n    \"\"\"\n    Convert the rule properties to a string.\n\n    Returns\n    -------\n    str\n        A string representing the rule.\n    \"\"\"\n    if self.visMin is not None and self.visMax is not None:\n        show_on_true_string = f\"True if float(ch[0]) &gt;= {self.visMin} and float(ch[0]) &lt; {self.visMax} else False\"\n        show_on_false_string = f\"False if float(ch[0]) &gt;= {self.visMin} and float(ch[0]) &lt; {self.visMax} else True\"\n    else:\n        show_on_true_string = \"True if ch[0]==1 else False\"\n        show_on_false_string = \"True if ch[0]!=1 else False\"\n    expression = show_on_true_string if self.show_on_true else show_on_false_string\n\n    output_string = (\n        \"{\"\n        f'\"name\": \"{self.rule_type}_{self.channel}\", '\n        f'\"property\": \"{self.rule_type}\", '\n        f'\"initial_value\": \"{self.initial_value}\", '\n        f'\"expression\": \"{expression}\", '\n        '\"channels\": ['\n        \"{\"\n        f'\"channel\": \"{self.channel}\", '\n        '\"trigger\": true, '\n        '\"use_enum\": false'\n        \"}\"\n        \"], \"\n        '\"notes\": \"{self.notes}\"'\n        \"}\"\n    )\n    return output_string\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Brush","title":"<code>Brush</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a brush property for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Brush--attributes","title":"Attributes","text":"<p>red : int     The red component. green : int     The green component. blue : int     The blue component. alpha : int, optional     The alpha component, default is 255. fill : bool, optional     Whether the brush is filled, default is True.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Brush(XMLConvertible):\n    \"\"\"\n    Represents a brush property for a widget.\n\n    Attributes\n    ----------\n    red : int\n        The red component.\n    green : int\n        The green component.\n    blue : int\n        The blue component.\n    alpha : int, optional\n        The alpha component, default is 255.\n    fill : bool, optional\n        Whether the brush is filled, default is True.\n    \"\"\"\n\n    red: int\n    green: int\n    blue: int\n    alpha: int = 255\n    fill: bool = True\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the brush property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the brush.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"brush\", \"stdset\": \"0\"})\n        brush_elem: etree.Element = etree.SubElement(\n            prop, \"brush\", attrib={\"brushstyle\": \"SolidPattern\" if self.fill else \"NoBrush\"}\n        )\n        color: Color = Color(self.red, self.green, self.blue, self.alpha)\n        brush_elem.append(color.to_xml())\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Brush.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the brush property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Brush.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the brush.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the brush property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the brush.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"brush\", \"stdset\": \"0\"})\n    brush_elem: etree.Element = etree.SubElement(\n        prop, \"brush\", attrib={\"brushstyle\": \"SolidPattern\" if self.fill else \"NoBrush\"}\n    )\n    color: Color = Color(self.red, self.green, self.blue, self.alpha)\n    brush_elem.append(color.to_xml())\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Channel","title":"<code>Channel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a channel property for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Channel--attributes","title":"Attributes","text":"<p>channel : str     The channel name.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Channel(XMLConvertible):\n    \"\"\"\n    Represents a channel property for a widget.\n\n    Attributes\n    ----------\n    channel : str\n        The channel name.\n    \"\"\"\n\n    channel: str\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the channel property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the channel.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"channel\", \"stdset\": \"0\"})\n        string_elem: etree.Element = etree.SubElement(prop, \"string\")\n        string_elem.text = self.channel\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Channel.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the channel property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Channel.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the channel.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the channel property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the channel.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"channel\", \"stdset\": \"0\"})\n    string_elem: etree.Element = etree.SubElement(prop, \"string\")\n    string_elem.text = self.channel\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Color","title":"<code>Color</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a color.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Color--attributes","title":"Attributes","text":"<p>red : int     The red component (0-255). green : int     The green component (0-255). blue : int     The blue component (0-255). alpha : int, optional     The alpha component (0-255), default is 255.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Color(XMLConvertible):\n    \"\"\"\n    Represents a color.\n\n    Attributes\n    ----------\n    red : int\n        The red component (0-255).\n    green : int\n        The green component (0-255).\n    blue : int\n        The blue component (0-255).\n    alpha : int, optional\n        The alpha component (0-255), default is 255.\n    \"\"\"\n\n    red: int\n    green: int\n    blue: int\n    alpha: int = 255\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the color to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the color.\n        \"\"\"\n        color_elem: etree.Element = etree.Element(\"color\", attrib={\"alpha\": str(self.alpha)})\n        red_elem: etree.Element = etree.SubElement(color_elem, \"red\")\n        red_elem.text = str(self.red)\n        green_elem: etree.Element = etree.SubElement(color_elem, \"green\")\n        green_elem.text = str(self.green)\n        blue_elem: etree.Element = etree.SubElement(color_elem, \"blue\")\n        blue_elem.text = str(self.blue)\n        return color_elem\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Color.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the color to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Color.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the color.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the color to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the color.\n    \"\"\"\n    color_elem: etree.Element = etree.Element(\"color\", attrib={\"alpha\": str(self.alpha)})\n    red_elem: etree.Element = etree.SubElement(color_elem, \"red\")\n    red_elem.text = str(self.red)\n    green_elem: etree.Element = etree.SubElement(color_elem, \"green\")\n    green_elem.text = str(self.green)\n    blue_elem: etree.Element = etree.SubElement(color_elem, \"blue\")\n    blue_elem.text = str(self.blue)\n    return color_elem\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.ColorObject","title":"<code>ColorObject</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass ColorObject(XMLConvertible):\n    name: str\n    red: int\n    green: int\n    blue: int\n    alpha: int = 255\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the color property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the color.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n        color: Color = Color(self.red, self.green, self.blue, alpha=self.alpha)\n        prop.append(color.to_xml())\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.ColorObject.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the color property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.ColorObject.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the color.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the color property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the color.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n    color: Color = Color(self.red, self.green, self.blue, alpha=self.alpha)\n    prop.append(color.to_xml())\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Column","title":"<code>Column</code>  <code>dataclass</code>","text":"<p>Represents end  tag for tables.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Column:\n    \"\"\"\n    Represents end &lt;/column&gt; tag for tables.\n    \"\"\"\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Generates a Column XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing a column.\n        \"\"\"\n        return etree.Element(\"column\")\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Column.to_xml","title":"<code>to_xml()</code>","text":"<p>Generates a Column XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Column.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing a column.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Generates a Column XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing a column.\n    \"\"\"\n    return etree.Element(\"column\")\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Controllable","title":"<code>Controllable</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Tangible</code></p> <p>Represents a widget that uses an EPICS PV.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Controllable--attributes","title":"Attributes","text":"<p>channel : Optional[str]     The EPICS channel. pydm_tool_tip : Optional[str]     The tooltip text for the widget.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Controllable(Tangible):\n    \"\"\"\n    Represents a widget that uses an EPICS PV.\n\n    Attributes\n    ----------\n    channel : Optional[str]\n        The EPICS channel.\n    pydm_tool_tip : Optional[str]\n        The tooltip text for the widget.\n    \"\"\"\n\n    channel: Optional[str] = None\n    pydm_tool_tip: Optional[str] = None\n    visPvList: Optional[List[Tuple[str, int, int]]] = None\n    visPv: Optional[str] = None\n    visInvert: Optional[bool] = None\n    rules: Optional[List[str]] = field(default_factory=list)\n    visMin: Optional[int] = None\n    visMax: Optional[int] = None\n    text = None\n    hide_on_disconnect_channel: Optional[str] = None\n    isSymbol: Optional[bool] = None\n    symbolChannel: Optional[str] = None\n\n    def generate_properties(self) -&gt; List[etree.Element]:\n        \"\"\"\n        Generate XML properties for the controllable widget.\n\n        Returns\n        -------\n        List[etree.Element]\n            A list containing geometry, channel, and tooltip properties.\n        \"\"\"\n        properties: List[etree.Element] = super().generate_properties()\n        if self.channel is not None:\n            if isinstance(self.channel, List):\n                if len(self.channel) &gt; 1:\n                    logger.warning(f\"This channel was given multiple pvs: {self.channel}, using the first channel\")\n                self.channel = self.channel[0]\n\n            properties.append(Channel(self.channel).to_xml())\n        if self.pydm_tool_tip is not None:\n            properties.append(PyDMToolTip(self.pydm_tool_tip).to_xml())\n        if self.visPvList is not None:\n            for elem in self.visPvList:\n                group_channel, group_min, group_max = elem\n                self.rules.append(\n                    RuleArguments(\n                        \"Visible\",\n                        group_channel,\n                        False,\n                        not self.visInvert if self.visInvert is not None else True,\n                        group_min,\n                        group_max,\n                    )\n                )\n\n        if self.visPv is not None:\n            self.rules.append(\n                RuleArguments(\n                    \"Visible\",\n                    self.visPv,\n                    False,\n                    not self.visInvert if self.visInvert is not None else True,\n                    self.visMin,\n                    self.visMax,\n                )\n            )\n\n        hidden_widgets = [\n            \"activextextdspclassnoedit\",\n            \"activechoicebuttonclass, activextextclass\",\n            \"mzxygraphclass\",\n            \"activerampbuttonclass\",\n        ]\n        is_hidden = False\n\n        for elem in hidden_widgets:\n            if self.name.lower().startswith(elem):\n                is_hidden = True\n        if is_hidden:\n            hidden_channel = self.channel\n        elif self.isSymbol is not None:\n            hidden_channel = self.symbolChannel\n        else:\n            hidden_channel = None\n        properties.append(Rules(self.rules, hidden_channel).to_xml())\n        return properties\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Controllable.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate XML properties for the controllable widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Controllable.generate_properties--returns","title":"Returns","text":"<p>List[etree.Element]     A list containing geometry, channel, and tooltip properties.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def generate_properties(self) -&gt; List[etree.Element]:\n    \"\"\"\n    Generate XML properties for the controllable widget.\n\n    Returns\n    -------\n    List[etree.Element]\n        A list containing geometry, channel, and tooltip properties.\n    \"\"\"\n    properties: List[etree.Element] = super().generate_properties()\n    if self.channel is not None:\n        if isinstance(self.channel, List):\n            if len(self.channel) &gt; 1:\n                logger.warning(f\"This channel was given multiple pvs: {self.channel}, using the first channel\")\n            self.channel = self.channel[0]\n\n        properties.append(Channel(self.channel).to_xml())\n    if self.pydm_tool_tip is not None:\n        properties.append(PyDMToolTip(self.pydm_tool_tip).to_xml())\n    if self.visPvList is not None:\n        for elem in self.visPvList:\n            group_channel, group_min, group_max = elem\n            self.rules.append(\n                RuleArguments(\n                    \"Visible\",\n                    group_channel,\n                    False,\n                    not self.visInvert if self.visInvert is not None else True,\n                    group_min,\n                    group_max,\n                )\n            )\n\n    if self.visPv is not None:\n        self.rules.append(\n            RuleArguments(\n                \"Visible\",\n                self.visPv,\n                False,\n                not self.visInvert if self.visInvert is not None else True,\n                self.visMin,\n                self.visMax,\n            )\n        )\n\n    hidden_widgets = [\n        \"activextextdspclassnoedit\",\n        \"activechoicebuttonclass, activextextclass\",\n        \"mzxygraphclass\",\n        \"activerampbuttonclass\",\n    ]\n    is_hidden = False\n\n    for elem in hidden_widgets:\n        if self.name.lower().startswith(elem):\n            is_hidden = True\n    if is_hidden:\n        hidden_channel = self.channel\n    elif self.isSymbol is not None:\n        hidden_channel = self.symbolChannel\n    else:\n        hidden_channel = None\n    properties.append(Rules(self.rules, hidden_channel).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Curves","title":"<code>Curves</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a curve for a PyDMWaveformPlot.</p> <p>Attributes:</p> Name Type Description <code>x_channel</code> <p>str The channel for x values</p> <code>y_channel</code> <p>str The channel for y values</p> <code>plotColor</code> <p>RGBA The color given to the curve</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Curves(XMLConvertible):\n    \"\"\"\n    Represents a curve for a PyDMWaveformPlot.\n\n    Attributes:\n        x_channel : str\n            The channel for x values\n        y_channel : str\n            The channel for y values\n        plotColor : RGBA\n            The color given to the curve\n    \"\"\"\n\n    x_channel: Optional[str] = None\n    y_channel: Optional[str] = None\n    plotColor: Optional[RGBA] = None\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.CustomWidget","title":"<code>CustomWidget</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a custom widget configuration.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.CustomWidget--attributes","title":"Attributes","text":"<p>cls : str     The class name of the custom widget. base : str     The base class that this widget extends. header : str     The header file for the widget. container : str, optional     The container information (default is an empty string).</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass CustomWidget(XMLConvertible):\n    \"\"\"\n    Represents a custom widget configuration.\n\n    Attributes\n    ----------\n    cls : str\n        The class name of the custom widget.\n    base : str\n        The base class that this widget extends.\n    header : str\n        The header file for the widget.\n    container : str, optional\n        The container information (default is an empty string).\n    \"\"\"\n\n    cls: str\n    base: str\n    header: str\n    container: str = \"\"\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the custom widget configuration to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the custom widget.\n        \"\"\"\n        top: etree.Element = etree.Element(\"customwidget\")\n        cls_elem: etree.Element = etree.SubElement(top, \"class\")\n        cls_elem.text = self.cls\n        extends: etree.Element = etree.SubElement(top, \"extends\")\n        extends.text = self.base\n        header_elem: etree.Element = etree.SubElement(top, \"header\")\n        header_elem.text = self.header\n        if self.container:\n            container_elem: etree.Element = etree.SubElement(top, \"container\")\n            container_elem.text = self.container\n        return top\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.CustomWidget.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the custom widget configuration to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.CustomWidget.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the custom widget.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the custom widget configuration to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the custom widget.\n    \"\"\"\n    top: etree.Element = etree.Element(\"customwidget\")\n    cls_elem: etree.Element = etree.SubElement(top, \"class\")\n    cls_elem.text = self.cls\n    extends: etree.Element = etree.SubElement(top, \"extends\")\n    extends.text = self.base\n    header_elem: etree.Element = etree.SubElement(top, \"header\")\n    header_elem.text = self.header\n    if self.container:\n        container_elem: etree.Element = etree.SubElement(top, \"container\")\n        container_elem.text = self.container\n    return top\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Double","title":"<code>Double</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a double/float property.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Double--attributes","title":"Attributes","text":"<p>name : str     The name of the property. value : float     The decimal value.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Double(XMLConvertible):\n    \"\"\"\n    Represents a double/float property.\n\n    Attributes\n    ----------\n    name : str\n        The name of the property.\n    value : float\n        The decimal value.\n    \"\"\"\n\n    name: str\n    value: float = 0.0\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the float property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the float (converted to double).\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n        double_tag: etree.Element = etree.SubElement(prop, \"double\")  # Need to use double because float is unsupported\n        double_tag.text = str(self.value)\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Double.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the float property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Double.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the float (converted to double).</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the float property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the float (converted to double).\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n    double_tag: etree.Element = etree.SubElement(prop, \"double\")  # Need to use double because float is unsupported\n    double_tag.text = str(self.value)\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Drawable","title":"<code>Drawable</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Tangible</code></p> <p>Represents a widget that can be drawn with pen and brush properties.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Drawable--attributes","title":"Attributes","text":"<p>penStyle : Optional[str]     The style of the pen ('dash' for dashed, otherwise solid). penColor : Optional[RGBA]     A tuple representing the pen color (red, green, blue, alpha). penWidth : Optional[int]     The width of the pen. brushColor : Optional[RGBA]     A tuple representing the brush color (red, green, blue, alpha). brushFill : Optional[bool]     Whether the brush should fill. rotation : Optional[float]     The rotation angle.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Drawable(Tangible):\n    \"\"\"\n    Represents a widget that can be drawn with pen and brush properties.\n\n    Attributes\n    ----------\n    penStyle : Optional[str]\n        The style of the pen ('dash' for dashed, otherwise solid).\n    penColor : Optional[RGBA]\n        A tuple representing the pen color (red, green, blue, alpha).\n    penWidth : Optional[int]\n        The width of the pen.\n    brushColor : Optional[RGBA]\n        A tuple representing the brush color (red, green, blue, alpha).\n    brushFill : Optional[bool]\n        Whether the brush should fill.\n    rotation : Optional[float]\n        The rotation angle.\n    \"\"\"\n\n    penStyle: Optional[str] = None\n    penColor: Optional[RGBA] = None\n    penWidth: Optional[int] = None\n    brushColor: Optional[RGBA] = None\n    brushFill: Optional[bool] = None\n    rotation: Optional[float] = None\n\n    def generate_properties(self) -&gt; List[etree.Element]:\n        \"\"\"\n        Generate XML properties for the drawable widget.\n\n        Returns\n        -------\n        List[etree.Element]\n            A list containing geometry, pen, brush, and rotation properties.\n        \"\"\"\n        properties: List[etree.Element] = super().generate_properties()\n        if self.penColor is not None:\n            properties.append(PenColor(*self.penColor).to_xml())\n        if self.penStyle is not None or self.penColor is not None:\n            properties.append(PenStyle(style=self.penStyle).to_xml())\n        if self.penWidth is not None:\n            properties.append(PenWidth(width=self.penWidth).to_xml())\n        if self.brushColor is not None:\n            properties.append(Brush(*self.brushColor, fill=self.brushFill).to_xml())\n        if self.brushFill is None:\n            properties.append(TransparentBackground().to_xml())\n        if self.rotation is not None:\n            properties.append(Rotation(\"rotation\", self.rotation).to_xml())\n        return properties\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Drawable.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate XML properties for the drawable widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Drawable.generate_properties--returns","title":"Returns","text":"<p>List[etree.Element]     A list containing geometry, pen, brush, and rotation properties.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def generate_properties(self) -&gt; List[etree.Element]:\n    \"\"\"\n    Generate XML properties for the drawable widget.\n\n    Returns\n    -------\n    List[etree.Element]\n        A list containing geometry, pen, brush, and rotation properties.\n    \"\"\"\n    properties: List[etree.Element] = super().generate_properties()\n    if self.penColor is not None:\n        properties.append(PenColor(*self.penColor).to_xml())\n    if self.penStyle is not None or self.penColor is not None:\n        properties.append(PenStyle(style=self.penStyle).to_xml())\n    if self.penWidth is not None:\n        properties.append(PenWidth(width=self.penWidth).to_xml())\n    if self.brushColor is not None:\n        properties.append(Brush(*self.brushColor, fill=self.brushFill).to_xml())\n    if self.brushFill is None:\n        properties.append(TransparentBackground().to_xml())\n    if self.rotation is not None:\n        properties.append(Rotation(\"rotation\", self.rotation).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Enum","title":"<code>Enum</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents an enumeration property.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Enum--attributes","title":"Attributes","text":"<p>name : str     The name of the property. value : str     The enum value.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Enum(XMLConvertible):\n    \"\"\"\n    Represents an enumeration property.\n\n    Attributes\n    ----------\n    name : str\n        The name of the property.\n    value : str\n        The enum value.\n    \"\"\"\n\n    name: str\n    value: str\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the enum property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the enum.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n        enum_elem: etree.Element = etree.SubElement(prop, \"enum\")\n        enum_elem.text = self.value\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Enum.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the enum property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Enum.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the enum.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the enum property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the enum.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n    enum_elem: etree.Element = etree.SubElement(prop, \"enum\")\n    enum_elem.text = self.value\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Font","title":"<code>Font</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents font properties for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Font--attributes","title":"Attributes","text":"<p>pointsize : Optional[int]     The size of the font. weight : Optional[int]     The weight of the font. bold : Optional[bool]     Whether the font is bold. italic : Optional[bool]     Whether the font is italic.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Font(XMLConvertible):\n    \"\"\"\n    Represents font properties for a widget.\n\n    Attributes\n    ----------\n    pointsize : Optional[int]\n        The size of the font.\n    weight : Optional[int]\n        The weight of the font.\n    bold : Optional[bool]\n        Whether the font is bold.\n    italic : Optional[bool]\n        Whether the font is italic.\n    \"\"\"\n\n    family: Optional[str] = None\n    family: Optional[str] = None\n    pointsize: Optional[int] = None\n    weight: Optional[int] = None\n    bold: Optional[bool] = None\n    italic: Optional[bool] = None\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the font properties to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the font.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"font\"})\n        font: etree.Element = etree.SubElement(prop, \"font\")\n        if self.family is not None:\n            family_tag: etree.Element = etree.SubElement(font, \"family\")\n            family_tag.text = str(self.family)\n        if self.family is not None:\n            family_tag: etree.Element = etree.SubElement(font, \"family\")\n            family_tag.text = str(self.family)\n        if self.pointsize is not None:\n            pointsize_tag: etree.Element = etree.SubElement(font, \"pointsize\")\n            pointsize_tag.text = str(self.pointsize)\n        if self.weight is not None:\n            weight_tag: etree.Element = etree.SubElement(font, \"weight\")\n            weight_tag.text = str(self.weight)\n        if self.bold is not None:\n            bold_tag: etree.Element = etree.SubElement(font, \"bold\")\n            bold_tag.text = \"true\" if self.bold else \"false\"\n        if self.italic is not None:\n            italic_tag: etree.Element = etree.SubElement(font, \"italic\")\n            italic_tag.text = \"true\" if self.italic else \"false\"\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Font.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the font properties to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Font.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the font.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the font properties to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the font.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"font\"})\n    font: etree.Element = etree.SubElement(prop, \"font\")\n    if self.family is not None:\n        family_tag: etree.Element = etree.SubElement(font, \"family\")\n        family_tag.text = str(self.family)\n    if self.family is not None:\n        family_tag: etree.Element = etree.SubElement(font, \"family\")\n        family_tag.text = str(self.family)\n    if self.pointsize is not None:\n        pointsize_tag: etree.Element = etree.SubElement(font, \"pointsize\")\n        pointsize_tag.text = str(self.pointsize)\n    if self.weight is not None:\n        weight_tag: etree.Element = etree.SubElement(font, \"weight\")\n        weight_tag.text = str(self.weight)\n    if self.bold is not None:\n        bold_tag: etree.Element = etree.SubElement(font, \"bold\")\n        bold_tag.text = \"true\" if self.bold else \"false\"\n    if self.italic is not None:\n        italic_tag: etree.Element = etree.SubElement(font, \"italic\")\n        italic_tag.text = \"true\" if self.italic else \"false\"\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Geometry","title":"<code>Geometry</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents geometry properties for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Geometry--attributes","title":"Attributes","text":"<p>x : Union[int, str]     The x-coordinate. y : Union[int, str]     The y-coordinate. width : Union[int, str]     The width of the widget. height : Union[int, str]     The height of the widget.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Geometry(XMLConvertible):\n    \"\"\"\n    Represents geometry properties for a widget.\n\n    Attributes\n    ----------\n    x : Union[int, str]\n        The x-coordinate.\n    y : Union[int, str]\n        The y-coordinate.\n    width : Union[int, str]\n        The width of the widget.\n    height : Union[int, str]\n        The height of the widget.\n    \"\"\"\n\n    x: Union[int, str]\n    y: Union[int, str]\n    width: Union[int, str]\n    height: Union[int, str]\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the geometry properties to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the geometry.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"geometry\"})\n        rect: etree.Element = etree.SubElement(prop, \"rect\")\n\n        for field_def in fields(self):\n            value = getattr(self, field_def.name)\n            elem: etree.Element = etree.SubElement(rect, field_def.name)\n\n            if value is None:\n                default_values = {\"x\": 0, \"y\": 0, \"width\": 100, \"height\": 100}\n                value = default_values.get(field_def.name, 0)\n            else:\n                try:\n                    if isinstance(value, str) and \".\" in value:\n                        value = int(float(value))\n                    else:\n                        value = int(value)\n                except (ValueError, TypeError):\n                    default_values = {\"x\": 0, \"y\": 0, \"width\": 100, \"height\": 100}\n                    value = default_values.get(field_def.name, 0)\n\n            elem.text = str(value)\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Geometry.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the geometry properties to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Geometry.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the geometry.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the geometry properties to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the geometry.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"geometry\"})\n    rect: etree.Element = etree.SubElement(prop, \"rect\")\n\n    for field_def in fields(self):\n        value = getattr(self, field_def.name)\n        elem: etree.Element = etree.SubElement(rect, field_def.name)\n\n        if value is None:\n            default_values = {\"x\": 0, \"y\": 0, \"width\": 100, \"height\": 100}\n            value = default_values.get(field_def.name, 0)\n        else:\n            try:\n                if isinstance(value, str) and \".\" in value:\n                    value = int(float(value))\n                else:\n                    value = int(value)\n            except (ValueError, TypeError):\n                default_values = {\"x\": 0, \"y\": 0, \"width\": 100, \"height\": 100}\n                value = default_values.get(field_def.name, 0)\n\n        elem.text = str(value)\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Hidable","title":"<code>Hidable</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Tangible</code></p> <p>Represents a widget that can be hidden.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Hidable--attributes","title":"Attributes","text":"<p>visibility_pv : Optional[str]     The visibility process variable. visibility_max : Optional[str]     The maximum visibility value. visibility_min : Optional[str]     The minimum visibility value. visibility_invert : bool     Whether the visibility is inverted.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Hidable(Tangible):\n    \"\"\"\n    Represents a widget that can be hidden.\n\n    Attributes\n    ----------\n    visibility_pv : Optional[str]\n        The visibility process variable.\n    visibility_max : Optional[str]\n        The maximum visibility value.\n    visibility_min : Optional[str]\n        The minimum visibility value.\n    visibility_invert : bool\n        Whether the visibility is inverted.\n    \"\"\"\n\n    visibility_pv: Optional[str] = None\n    visibility_max: Optional[str] = None\n    visibility_min: Optional[str] = None\n    visibility_invert: bool = False\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Int","title":"<code>Int</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents an integer property.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Int--attributes","title":"Attributes","text":"<p>name : str     The name of the property. value : int     The integer value.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Int(XMLConvertible):\n    \"\"\"\n    Represents an integer property.\n\n    Attributes\n    ----------\n    name : str\n        The name of the property.\n    value : int\n        The integer value.\n    \"\"\"\n\n    name: str\n    value: int = 0\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the integer property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the integer.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n        int_tag: etree.Element = etree.SubElement(prop, \"number\")\n        # Convert through float first to handle scientific notation (e.g., '-2e+08')\n        # PyQt's uic parser cannot handle scientific notation in &lt;number&gt; elements\n        try:\n            int_value = int(float(self.value))\n        except (ValueError, TypeError):\n            int_value = 0\n        int_tag.text = str(int_value)\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Int.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the integer property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Int.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the integer.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the integer property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the integer.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n    int_tag: etree.Element = etree.SubElement(prop, \"number\")\n    # Convert through float first to handle scientific notation (e.g., '-2e+08')\n    # PyQt's uic parser cannot handle scientific notation in &lt;number&gt; elements\n    try:\n        int_value = int(float(self.value))\n    except (ValueError, TypeError):\n        int_value = 0\n    int_tag.text = str(int_value)\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Layout","title":"<code>Layout</code>","text":"<p>Represents a layout configuration for widgets.</p> <p>This is a placeholder class for layout-related properties.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>class Layout:\n    \"\"\"\n    Represents a layout configuration for widgets.\n\n    This is a placeholder class for layout-related properties.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Legible","title":"<code>Legible</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Tangible</code></p> <p>Represents a widget that displays text.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Legible--attributes","title":"Attributes","text":"<p>text : Optional[str]     The text to display. font : dict     A dictionary containing font properties. alignment : Optional[str]     The text alignment.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Legible(Tangible):\n    \"\"\"\n    Represents a widget that displays text.\n\n    Attributes\n    ----------\n    text : Optional[str]\n        The text to display.\n    font : dict\n        A dictionary containing font properties.\n    alignment : Optional[str]\n        The text alignment.\n    \"\"\"\n\n    text: Optional[str] = None\n    font: dict = field(default_factory=dict)\n    alignment: Optional[str] = None\n\n    def generate_properties(self) -&gt; List[etree.Element]:\n        \"\"\"\n        Generate XML properties for the legible widget.\n\n        Returns\n        -------\n        List[etree.Element]\n            A list containing geometry, text, font, and alignment properties.\n        \"\"\"\n        properties: List[etree.Element] = super().generate_properties()\n        if self.text is not None:\n            properties.append(Text(\"text\", self.text).to_xml())\n        if self.font:\n            properties.append(Font(**self.font).to_xml())\n        if self.alignment is not None:\n            properties.append(Alignment(self.alignment).to_xml())\n        return properties\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Legible.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate XML properties for the legible widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Legible.generate_properties--returns","title":"Returns","text":"<p>List[etree.Element]     A list containing geometry, text, font, and alignment properties.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def generate_properties(self) -&gt; List[etree.Element]:\n    \"\"\"\n    Generate XML properties for the legible widget.\n\n    Returns\n    -------\n    List[etree.Element]\n        A list containing geometry, text, font, and alignment properties.\n    \"\"\"\n    properties: List[etree.Element] = super().generate_properties()\n    if self.text is not None:\n        properties.append(Text(\"text\", self.text).to_xml())\n    if self.font:\n        properties.append(Font(**self.font).to_xml())\n    if self.alignment is not None:\n        properties.append(Alignment(self.alignment).to_xml())\n    return properties\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.MultiRule","title":"<code>MultiRule</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a compound rule composed of multiple conditions.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.MultiRule--attributes","title":"Attributes","text":"<p>rule_type : str     The type of rule (e.g., \"Visible\", \"Enable\"). rule_list : list of RuleArguments, optional     A list of rule argument tuples, where each tuple contains:     (rule_type, channel, initial_value, show_on_true, visMin, visMax). hide_on_disconnect_channel : str, optional     An additional channel used to hide the widget if it disconnects. initial_value : bool, optional     Default value for the rule when no conditions are satisfied. Defaults to False. notes : str, optional     Additional metadata or notes about the rule.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass MultiRule(XMLConvertible):\n    \"\"\"\n    Represents a compound rule composed of multiple conditions.\n\n    Attributes\n    ----------\n    rule_type : str\n        The type of rule (e.g., \"Visible\", \"Enable\").\n    rule_list : list of RuleArguments, optional\n        A list of rule argument tuples, where each tuple contains:\n        (rule_type, channel, initial_value, show_on_true, visMin, visMax).\n    hide_on_disconnect_channel : str, optional\n        An additional channel used to hide the widget if it disconnects.\n    initial_value : bool, optional\n        Default value for the rule when no conditions are satisfied. Defaults to False.\n    notes : str, optional\n        Additional metadata or notes about the rule.\n    \"\"\"\n\n    rule_type: str\n    rule_list: Optional[List[RuleArguments]] = None\n    hide_on_disconnect_channel: Optional[str] = None\n    initial_value: Optional[bool] = False\n    notes: Optional[str] = \"\"\n\n    def to_string(self):\n        \"\"\"\n        Convert the rule properties to a string.\n\n        Returns\n        -------\n        str\n            A string representing the rule.\n        \"\"\"\n\n        channel_list = []\n        expression_list = []\n        if self.rule_list is not None:\n            for i, rule in enumerate(self.rule_list):\n                rule_type, channel, initial_value, show_on_true, visMin, visMax = rule\n                replacement_init = None\n                if channel.startswith(\"loc://\") and \"init=${\" in channel:\n                    replacement_init = channel[channel.find(\"init=\") + len(\"init=\") :]\n                    replacement_init = replacement_init[: replacement_init.find(\"}\") + 1]\n                channel_list.append(f'{{\"channel\": \"{channel}\", \"trigger\": true, \"use_enum\": false}}')\n                expression_list.append(self.get_expression(i, show_on_true, visMin, visMax, replacement_init))\n        if self.hide_on_disconnect_channel is not None:\n            new_index = len(self.rule_list)\n            replacement_init = None\n            if self.hide_on_disconnect_channel.startswith(\"loc://\") and \"init=${\" in self.hide_on_disconnect_channel:\n                replacement_init = self.hide_on_disconnect_channel[\n                    self.hide_on_disconnect_channel.find(\"init=\") + len(\"init=\") :\n                ]\n                replacement_init = replacement_init[: replacement_init.find(\"}\") + 1]\n            expression_list.append(self.get_hide_on_disconnect_expression(new_index, replacement_init))\n            channel_list.append(\n                f'{{\"channel\": \"{self.hide_on_disconnect_channel}\", \"trigger\": true, \"use_enum\": false}}'\n            )\n        if not expression_list:\n            return \"\"\n        expression_str = \"(\" + \") and (\".join(expression_list) + \")\"\n\n        output_string = (\n            \"{\"\n            f'\"name\": \"{self.rule_type}\", '\n            f'\"property\": \"{self.rule_type}\", '\n            f'\"initial_value\": \"false\", '\n            f'\"expression\": \"{expression_str}\", '\n            f'\"channels\": [{\", \".join(channel_list)}], '\n            f'\"notes\": \"{self.notes}\"'\n            \"}\"\n        )\n        return output_string\n\n    def get_expression(self, index, show_on_true, visMin, visMax, init):  # TODO: Can clean up with fstrings\n        \"\"\"\n        Build a conditional expression string for a specific channel.\n\n        Parameters\n        ----------\n        index : int\n            The index of the channel in the rule list.\n        show_on_true : bool\n            Whether the expression should evaluate to true on match.\n        visMin : int, optional\n            Minimum threshold value for range-based conditions.\n        visMax : int, optional\n            Maximum threshold value for range-based conditions.\n        init : str, optional\n            Replacement initialization value for the channel, if applicable.\n\n        Returns\n        -------\n        str\n            A string representing the conditional expression for the given channel.\n        \"\"\"\n\n        ch = f\"ch[{index}]\"\n\n        if visMin is not None and visMax is not None:\n            show_on_true_string = f\"float({ch}) &gt;= {visMin} and float({ch}) &lt; {visMax}\"\n            show_on_false_string = f\"float({ch}) &lt; {visMin} or float({ch}) &gt;= {visMax}\"\n        else:\n            show_on_true_string = f\"{ch}==1\"\n            show_on_false_string = f\"{ch}!=1\"  # TODO: maybe need to change from specifically 1 (== 0 or != 0)?\n\n        return show_on_true_string if show_on_true else show_on_false_string\n\n    def get_hide_on_disconnect_expression(self, index, init):\n        \"\"\"\n        Build an expression that ensures the widget is hidden if a channel disconnects.\n\n        Parameters\n        ----------\n        index : int\n            The index of the disconnect channel in the channel list.\n\n        Returns\n        -------\n        str\n            An expression string that evaluates true when the channel is connected.\n        \"\"\"\n\n        ch = f\"ch[{index}]\"\n\n        return f\"{ch} is not None\"\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.MultiRule.get_expression","title":"<code>get_expression(index, show_on_true, visMin, visMax, init)</code>","text":"<p>Build a conditional expression string for a specific channel.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.MultiRule.get_expression--parameters","title":"Parameters","text":"<p>index : int     The index of the channel in the rule list. show_on_true : bool     Whether the expression should evaluate to true on match. visMin : int, optional     Minimum threshold value for range-based conditions. visMax : int, optional     Maximum threshold value for range-based conditions. init : str, optional     Replacement initialization value for the channel, if applicable.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.MultiRule.get_expression--returns","title":"Returns","text":"<p>str     A string representing the conditional expression for the given channel.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def get_expression(self, index, show_on_true, visMin, visMax, init):  # TODO: Can clean up with fstrings\n    \"\"\"\n    Build a conditional expression string for a specific channel.\n\n    Parameters\n    ----------\n    index : int\n        The index of the channel in the rule list.\n    show_on_true : bool\n        Whether the expression should evaluate to true on match.\n    visMin : int, optional\n        Minimum threshold value for range-based conditions.\n    visMax : int, optional\n        Maximum threshold value for range-based conditions.\n    init : str, optional\n        Replacement initialization value for the channel, if applicable.\n\n    Returns\n    -------\n    str\n        A string representing the conditional expression for the given channel.\n    \"\"\"\n\n    ch = f\"ch[{index}]\"\n\n    if visMin is not None and visMax is not None:\n        show_on_true_string = f\"float({ch}) &gt;= {visMin} and float({ch}) &lt; {visMax}\"\n        show_on_false_string = f\"float({ch}) &lt; {visMin} or float({ch}) &gt;= {visMax}\"\n    else:\n        show_on_true_string = f\"{ch}==1\"\n        show_on_false_string = f\"{ch}!=1\"  # TODO: maybe need to change from specifically 1 (== 0 or != 0)?\n\n    return show_on_true_string if show_on_true else show_on_false_string\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.MultiRule.get_hide_on_disconnect_expression","title":"<code>get_hide_on_disconnect_expression(index, init)</code>","text":"<p>Build an expression that ensures the widget is hidden if a channel disconnects.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.MultiRule.get_hide_on_disconnect_expression--parameters","title":"Parameters","text":"<p>index : int     The index of the disconnect channel in the channel list.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.MultiRule.get_hide_on_disconnect_expression--returns","title":"Returns","text":"<p>str     An expression string that evaluates true when the channel is connected.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def get_hide_on_disconnect_expression(self, index, init):\n    \"\"\"\n    Build an expression that ensures the widget is hidden if a channel disconnects.\n\n    Parameters\n    ----------\n    index : int\n        The index of the disconnect channel in the channel list.\n\n    Returns\n    -------\n    str\n        An expression string that evaluates true when the channel is connected.\n    \"\"\"\n\n    ch = f\"ch[{index}]\"\n\n    return f\"{ch} is not None\"\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.MultiRule.to_string","title":"<code>to_string()</code>","text":"<p>Convert the rule properties to a string.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.MultiRule.to_string--returns","title":"Returns","text":"<p>str     A string representing the rule.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_string(self):\n    \"\"\"\n    Convert the rule properties to a string.\n\n    Returns\n    -------\n    str\n        A string representing the rule.\n    \"\"\"\n\n    channel_list = []\n    expression_list = []\n    if self.rule_list is not None:\n        for i, rule in enumerate(self.rule_list):\n            rule_type, channel, initial_value, show_on_true, visMin, visMax = rule\n            replacement_init = None\n            if channel.startswith(\"loc://\") and \"init=${\" in channel:\n                replacement_init = channel[channel.find(\"init=\") + len(\"init=\") :]\n                replacement_init = replacement_init[: replacement_init.find(\"}\") + 1]\n            channel_list.append(f'{{\"channel\": \"{channel}\", \"trigger\": true, \"use_enum\": false}}')\n            expression_list.append(self.get_expression(i, show_on_true, visMin, visMax, replacement_init))\n    if self.hide_on_disconnect_channel is not None:\n        new_index = len(self.rule_list)\n        replacement_init = None\n        if self.hide_on_disconnect_channel.startswith(\"loc://\") and \"init=${\" in self.hide_on_disconnect_channel:\n            replacement_init = self.hide_on_disconnect_channel[\n                self.hide_on_disconnect_channel.find(\"init=\") + len(\"init=\") :\n            ]\n            replacement_init = replacement_init[: replacement_init.find(\"}\") + 1]\n        expression_list.append(self.get_hide_on_disconnect_expression(new_index, replacement_init))\n        channel_list.append(\n            f'{{\"channel\": \"{self.hide_on_disconnect_channel}\", \"trigger\": true, \"use_enum\": false}}'\n        )\n    if not expression_list:\n        return \"\"\n    expression_str = \"(\" + \") and (\".join(expression_list) + \")\"\n\n    output_string = (\n        \"{\"\n        f'\"name\": \"{self.rule_type}\", '\n        f'\"property\": \"{self.rule_type}\", '\n        f'\"initial_value\": \"false\", '\n        f'\"expression\": \"{expression_str}\", '\n        f'\"channels\": [{\", \".join(channel_list)}], '\n        f'\"notes\": \"{self.notes}\"'\n        \"}\"\n    )\n    return output_string\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.OnOffColor","title":"<code>OnOffColor</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents the on/offColor property for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.OnOffColor--attributes","title":"Attributes","text":"<p>onOff : str     The prefix for _color (either on or off). red : int     The red component. green : int     The green component. blue : int     The blue component. alpha : int, optional     The alpha component, default is 255.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass OnOffColor(XMLConvertible):\n    \"\"\"\n    Represents the on/offColor property for a widget.\n\n    Attributes\n    ----------\n    onOff : str\n        The prefix for _color (either on or off).\n    red : int\n        The red component.\n    green : int\n        The green component.\n    blue : int\n        The blue component.\n    alpha : int, optional\n        The alpha component, default is 255.\n    \"\"\"\n\n    onOff: str  # TODO: Make this an enum?\n    red: int\n    green: int\n    blue: int\n    alpha: int = 255\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the onOff color property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the on//offcolor.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": f\"{self.onOff}Color\", \"stdset\": \"0\"})\n        color: Color = Color(self.red, self.green, self.blue, alpha=self.alpha)\n        prop.append(color.to_xml())\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.OnOffColor.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the onOff color property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.OnOffColor.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the on//offcolor.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the onOff color property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the on//offcolor.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": f\"{self.onOff}Color\", \"stdset\": \"0\"})\n    color: Color = Color(self.red, self.green, self.blue, alpha=self.alpha)\n    prop.append(color.to_xml())\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.PenColor","title":"<code>PenColor</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a pen color property for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.PenColor--attributes","title":"Attributes","text":"<p>red : int     The red component. green : int     The green component. blue : int     The blue component. alpha : int, optional     The alpha component, default is 255.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass PenColor(XMLConvertible):\n    \"\"\"\n    Represents a pen color property for a widget.\n\n    Attributes\n    ----------\n    red : int\n        The red component.\n    green : int\n        The green component.\n    blue : int\n        The blue component.\n    alpha : int, optional\n        The alpha component, default is 255.\n    \"\"\"\n\n    red: int\n    green: int\n    blue: int\n    alpha: int = 255\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the pen color property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the pen color.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"penColor\", \"stdset\": \"0\"})\n        color: Color = Color(self.red, self.green, self.blue, alpha=self.alpha)\n        prop.append(color.to_xml())\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.PenColor.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the pen color property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.PenColor.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the pen color.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the pen color property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the pen color.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"penColor\", \"stdset\": \"0\"})\n    color: Color = Color(self.red, self.green, self.blue, alpha=self.alpha)\n    prop.append(color.to_xml())\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.PenStyle","title":"<code>PenStyle</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a pen style property for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.PenStyle--attributes","title":"Attributes","text":"<p>style : Optional[str]     The style of the pen ('dash' for dashed, otherwise solid).</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass PenStyle(XMLConvertible):\n    \"\"\"\n    Represents a pen style property for a widget.\n\n    Attributes\n    ----------\n    style : Optional[str]\n        The style of the pen ('dash' for dashed, otherwise solid).\n    \"\"\"\n\n    style: Optional[str] = None\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the pen style property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the pen style.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"penStyle\", \"stdset\": \"0\"})\n        enum: etree.Element = etree.SubElement(prop, \"enum\")\n        enum.text = \"Qt::DashLine\" if self.style == \"dash\" else \"Qt::SolidLine\"\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.PenStyle.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the pen style property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.PenStyle.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the pen style.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the pen style property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the pen style.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"penStyle\", \"stdset\": \"0\"})\n    enum: etree.Element = etree.SubElement(prop, \"enum\")\n    enum.text = \"Qt::DashLine\" if self.style == \"dash\" else \"Qt::SolidLine\"\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.PenWidth","title":"<code>PenWidth</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a pen width property for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.PenWidth--attributes","title":"Attributes","text":"<p>width : Optional[int]     The width of the pen.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass PenWidth(XMLConvertible):\n    \"\"\"\n    Represents a pen width property for a widget.\n\n    Attributes\n    ----------\n    width : Optional[int]\n        The width of the pen.\n    \"\"\"\n\n    width: Optional[int] = None\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the pen width property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the pen width.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"penWidth\", \"stdset\": \"0\"})\n        double_elem: etree.Element = etree.SubElement(prop, \"double\")\n        double_elem.text = str(self.width)\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.PenWidth.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the pen width property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.PenWidth.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the pen width.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the pen width property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the pen width.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"penWidth\", \"stdset\": \"0\"})\n    double_elem: etree.Element = etree.SubElement(prop, \"double\")\n    double_elem.text = str(self.width)\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.PixMap","title":"<code>PixMap</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents an image widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.PixMap--attributes","title":"Attributes","text":"<p>filename : str     The filename of the imported image.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass PixMap(XMLConvertible):\n    \"\"\"\n    Represents an image widget.\n\n    Attributes\n    ----------\n    filename : str\n        The filename of the imported image.\n    \"\"\"\n\n    filename: str\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the filename property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the image.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"pixmap\"})\n        pixmap_tag: etree.Element = etree.SubElement(prop, \"pixmap\")\n        pixmap_tag.text = self.filename\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.PixMap.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the filename property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.PixMap.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the image.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the filename property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the image.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"pixmap\"})\n    pixmap_tag: etree.Element = etree.SubElement(prop, \"pixmap\")\n    pixmap_tag.text = self.filename\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.PyDMRule","title":"<code>PyDMRule</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a PyDM rule for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.PyDMRule--attributes","title":"Attributes","text":"<p>name : str     The name of the rule. rule_property : str     The property the rule affects. expression : str     The expression for the rule. channel : str     The channel associated with the rule. initial_value : Any, optional     The initial value for the rule.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass PyDMRule(XMLConvertible):\n    \"\"\"\n    Represents a PyDM rule for a widget.\n\n    Attributes\n    ----------\n    name : str\n        The name of the rule.\n    rule_property : str\n        The property the rule affects.\n    expression : str\n        The expression for the rule.\n    channel : str\n        The channel associated with the rule.\n    initial_value : Any, optional\n        The initial value for the rule.\n    \"\"\"\n\n    name: str\n    rule_property: str\n    expression: str\n    channel: str\n    initial_value: Any = None\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the PyDM rule to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the rule.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"rules\", \"stdset\": \"0\"})\n        rules_struct: list[dict[str, Any]] = [\n            {\n                \"name\": self.name,\n                \"property\": self.rule_property,\n                \"initialValue\": self.initial_value,\n                \"expression\": self.expression,\n                \"channel\": [\n                    {\n                        \"channel\": self.channel,\n                        \"trigger\": True,\n                        \"use_enum\": False,\n                    },\n                ],\n            },\n        ]\n        rules: etree.Element = etree.SubElement(prop, \"rules\")\n        rules.text = str(rules_struct)\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.PyDMRule.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the PyDM rule to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.PyDMRule.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the rule.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the PyDM rule to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the rule.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"rules\", \"stdset\": \"0\"})\n    rules_struct: list[dict[str, Any]] = [\n        {\n            \"name\": self.name,\n            \"property\": self.rule_property,\n            \"initialValue\": self.initial_value,\n            \"expression\": self.expression,\n            \"channel\": [\n                {\n                    \"channel\": self.channel,\n                    \"trigger\": True,\n                    \"use_enum\": False,\n                },\n            ],\n        },\n    ]\n    rules: etree.Element = etree.SubElement(prop, \"rules\")\n    rules.text = str(rules_struct)\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.PyDMToolTip","title":"<code>PyDMToolTip</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a tooltip for a PyDM widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.PyDMToolTip--attributes","title":"Attributes","text":"<p>PyDMToolTip : str     The tooltip text.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass PyDMToolTip(XMLConvertible):\n    \"\"\"\n    Represents a tooltip for a PyDM widget.\n\n    Attributes\n    ----------\n    PyDMToolTip : str\n        The tooltip text.\n    \"\"\"\n\n    PyDMToolTip: str\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the tooltip to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the tooltip.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"PyDMToolTip\", \"stdset\": \"0\"})\n        string_elem: etree.Element = etree.SubElement(prop, \"string\")\n        string_elem.text = self.PyDMToolTip\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.PyDMToolTip.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the tooltip to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.PyDMToolTip.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the tooltip.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the tooltip to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the tooltip.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"PyDMToolTip\", \"stdset\": \"0\"})\n    string_elem: etree.Element = etree.SubElement(prop, \"string\")\n    string_elem.text = self.PyDMToolTip\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.RGBABackgroundSheet","title":"<code>RGBABackgroundSheet</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a background style sheet with an RGBA (Red, Green, Blue, Alpha) color.</p> <p>Attributes:</p> Name Type Description <code>red</code> <p>int Red component of the background color (0\u2013255).</p> <code>green</code> <p>int Green component of the background color (0\u2013255).</p> <code>blue</code> <p>int Blue component of the background color (0\u2013255).</p> <code>alpha</code> <p>int Alpha transparency value (0\u2013255).</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass RGBABackgroundSheet(XMLConvertible):  # eventually combine with rgbastylesheet\n    \"\"\"\n    Represents a background style sheet with an RGBA (Red, Green, Blue, Alpha) color.\n\n    Attributes:\n        red : int\n            Red component of the background color (0\u2013255).\n        green : int\n            Green component of the background color (0\u2013255).\n        blue : int\n            Blue component of the background color (0\u2013255).\n        alpha : int\n            Alpha transparency value (0\u2013255).\n    \"\"\"\n\n    red: int\n    green: int\n    blue: int\n    alpha: int = 255\n\n    def to_xml(self):\n        \"\"\"\n        Convert the stylesheet to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the background stylesheet.\n        \"\"\"\n        style = f\"background-color: rgba({self.red}, {self.green}, {self.blue}, {round(self.alpha / 255, 2)});\"\n        prop = ET.Element(\"property\", {\"name\": \"styleSheet\"})\n        string_elem = ET.SubElement(prop, \"string\")\n        string_elem.text = style\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.RGBABackgroundSheet.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the stylesheet to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.RGBABackgroundSheet.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the background stylesheet.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self):\n    \"\"\"\n    Convert the stylesheet to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the background stylesheet.\n    \"\"\"\n    style = f\"background-color: rgba({self.red}, {self.green}, {self.blue}, {round(self.alpha / 255, 2)});\"\n    prop = ET.Element(\"property\", {\"name\": \"styleSheet\"})\n    string_elem = ET.SubElement(prop, \"string\")\n    string_elem.text = style\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.RGBAStyleSheet","title":"<code>RGBAStyleSheet</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a background style sheet with an RGBA (Red, Green, Blue, Alpha) color.</p> <p>Attributes:</p> Name Type Description <code>red</code> <p>int Red component of the background color (0\u2013255).</p> <code>green</code> <p>int Green component of the background color (0\u2013255).</p> <code>blue</code> <p>int Blue component of the background color (0\u2013255).</p> <code>alpha</code> <p>int Alpha transparency value (0\u2013255).</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass RGBAStyleSheet(XMLConvertible):\n    \"\"\"\n    Represents a background style sheet with an RGBA (Red, Green, Blue, Alpha) color.\n\n    Attributes:\n        red : int\n            Red component of the background color (0\u2013255).\n        green : int\n            Green component of the background color (0\u2013255).\n        blue : int\n            Blue component of the background color (0\u2013255).\n        alpha : int\n            Alpha transparency value (0\u2013255).\n    \"\"\"\n\n    red: int\n    green: int\n    blue: int\n    alpha: int = 255\n\n    def to_xml(self):\n        \"\"\"\n        Convert the stylesheet into an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the image.\n        \"\"\"\n\n        style = f\"color: rgba({self.red}, {self.green}, {self.blue}, {round(self.alpha / 255, 2)}); background-color: transparent;\"\n        prop = ET.Element(\"property\", {\"name\": \"styleSheet\"})\n        string_elem = ET.SubElement(prop, \"string\")\n        string_elem.text = style\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.RGBAStyleSheet.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the stylesheet into an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.RGBAStyleSheet.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the image.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self):\n    \"\"\"\n    Convert the stylesheet into an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the image.\n    \"\"\"\n\n    style = f\"color: rgba({self.red}, {self.green}, {self.blue}, {round(self.alpha / 255, 2)}); background-color: transparent;\"\n    prop = ET.Element(\"property\", {\"name\": \"styleSheet\"})\n    string_elem = ET.SubElement(prop, \"string\")\n    string_elem.text = style\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Rotation","title":"<code>Rotation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a rotation property for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Rotation--attributes","title":"Attributes","text":"<p>name : str     The name of the rotation property. value : float     The rotation angle.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Rotation(XMLConvertible):\n    \"\"\"\n    Represents a rotation property for a widget.\n\n    Attributes\n    ----------\n    name : str\n        The name of the rotation property.\n    value : float\n        The rotation angle.\n    \"\"\"\n\n    name: str\n    value: float\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the rotation property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the rotation.\n        \"\"\"\n        element: etree.Element = etree.Element(self.name)\n        element.text = str(self.value)\n        return element\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Rotation.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the rotation property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Rotation.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the rotation.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the rotation property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the rotation.\n    \"\"\"\n    element: etree.Element = etree.Element(self.name)\n    element.text = str(self.value)\n    return element\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Row","title":"<code>Row</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Row(XMLConvertible):\n    value: Optional[str]\n    font: dict = field(default_factory=dict)\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the Row properties to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the font.\n        \"\"\"\n        row: etree.Element = etree.Element(\"row\")\n        prop: etree.Element = etree.SubElement(row, \"property\", attrib={\"name\": \"text\"})\n        string_tag: etree.Element = etree.SubElement(prop, \"string\")\n        string_tag.text = self.value\n        row.append(Font(**self.font).to_xml())\n        return row\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Row.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the Row properties to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Row.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the font.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the Row properties to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the font.\n    \"\"\"\n    row: etree.Element = etree.Element(\"row\")\n    prop: etree.Element = etree.SubElement(row, \"property\", attrib={\"name\": \"text\"})\n    string_tag: etree.Element = etree.SubElement(prop, \"string\")\n    string_tag.text = self.value\n    row.append(Font(**self.font).to_xml())\n    return row\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Rules","title":"<code>Rules</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a collection of rules grouped by type.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Rules--attributes","title":"Attributes","text":"<p>rules : list of RuleArguments     A list of rule argument tuples, where each tuple contains:     (rule_type, channel, initial_value, show_on_true, visMin, visMax). hide_on_disconnect_channel : str, optional     An additional channel used to hide widgets if it disconnects.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Rules(XMLConvertible):\n    \"\"\"\n    Represents a collection of rules grouped by type.\n\n    Attributes\n    ----------\n    rules : list of RuleArguments\n        A list of rule argument tuples, where each tuple contains:\n        (rule_type, channel, initial_value, show_on_true, visMin, visMax).\n    hide_on_disconnect_channel : str, optional\n        An additional channel used to hide widgets if it disconnects.\n    \"\"\"\n\n    rules: List[RuleArguments]\n    hide_on_disconnect_channel: Optional[str] = None\n\n    def to_xml(self):\n        \"\"\"\n        Convert the collection of rules into an XML element.\n\n        Returns\n        -------\n        etree.Element\n            An XML element representing all grouped rules.\n        \"\"\"\n\n        rule_list = []\n        rule_variables = self.group_by_rules()\n\n        for rule_type, rule_var_list in rule_variables.items():\n            if rule_var_list:\n                rule_string = MultiRule(rule_type, rule_var_list, self.hide_on_disconnect_channel).to_string()\n                rule_list.append(rule_string)\n            elif rule_type == \"Visible\":\n                rule_string = MultiRule(rule_type, [], self.hide_on_disconnect_channel).to_string()\n                rule_list.append(rule_string)\n        output_string = f\"[{', '.join(rule_list)}]\"\n        return Str(\"rules\", output_string).to_xml()\n\n    def group_by_rules(self):\n        \"\"\"\n        Group rules by their rule type, removing duplicates.\n\n        Returns\n        -------\n        dict of str to list of RuleArguments\n            A dictionary where the keys are rule types (e.g., \"Visible\", \"Enable\"),\n            and the values are lists of unique rules for that type.\n        \"\"\"\n\n        bool_rule_types = [\"Visible\", \"Enable\"]\n        rule_variables = {key: [] for key in bool_rule_types}\n        for rule in self.rules:\n            if rule.rule_type in rule_variables:\n                rule_variables[rule.rule_type].append(rule)\n        for rule_name in rule_variables.keys():  # removes repeated tuples\n            rule_variables[rule_name] = list(set(rule_variables[rule_name]))\n        return rule_variables\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Rules.group_by_rules","title":"<code>group_by_rules()</code>","text":"<p>Group rules by their rule type, removing duplicates.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Rules.group_by_rules--returns","title":"Returns","text":"<p>dict of str to list of RuleArguments     A dictionary where the keys are rule types (e.g., \"Visible\", \"Enable\"),     and the values are lists of unique rules for that type.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def group_by_rules(self):\n    \"\"\"\n    Group rules by their rule type, removing duplicates.\n\n    Returns\n    -------\n    dict of str to list of RuleArguments\n        A dictionary where the keys are rule types (e.g., \"Visible\", \"Enable\"),\n        and the values are lists of unique rules for that type.\n    \"\"\"\n\n    bool_rule_types = [\"Visible\", \"Enable\"]\n    rule_variables = {key: [] for key in bool_rule_types}\n    for rule in self.rules:\n        if rule.rule_type in rule_variables:\n            rule_variables[rule.rule_type].append(rule)\n    for rule_name in rule_variables.keys():  # removes repeated tuples\n        rule_variables[rule_name] = list(set(rule_variables[rule_name]))\n    return rule_variables\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Rules.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the collection of rules into an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Rules.to_xml--returns","title":"Returns","text":"<p>etree.Element     An XML element representing all grouped rules.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self):\n    \"\"\"\n    Convert the collection of rules into an XML element.\n\n    Returns\n    -------\n    etree.Element\n        An XML element representing all grouped rules.\n    \"\"\"\n\n    rule_list = []\n    rule_variables = self.group_by_rules()\n\n    for rule_type, rule_var_list in rule_variables.items():\n        if rule_var_list:\n            rule_string = MultiRule(rule_type, rule_var_list, self.hide_on_disconnect_channel).to_string()\n            rule_list.append(rule_string)\n        elif rule_type == \"Visible\":\n            rule_string = MultiRule(rule_type, [], self.hide_on_disconnect_channel).to_string()\n            rule_list.append(rule_string)\n    output_string = f\"[{', '.join(rule_list)}]\"\n    return Str(\"rules\", output_string).to_xml()\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Size","title":"<code>Size</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a size property for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Size--attributes","title":"Attributes","text":"<p>name : str     The name of the property. width : str     The width value. height : str     The height value.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Size(XMLConvertible):\n    \"\"\"\n    Represents a size property for a widget.\n\n    Attributes\n    ----------\n    name : str\n        The name of the property.\n    width : str\n        The width value.\n    height : str\n        The height value.\n    \"\"\"\n\n    name: str\n    width: str\n    height: str\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the size properties to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the size.\n        \"\"\"\n        top: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name})\n        size_elem: etree.Element = etree.SubElement(top, \"size\")\n        width_elem: etree.Element = etree.SubElement(size_elem, \"width\")\n        width_elem.text = self.width\n        height_elem: etree.Element = etree.SubElement(size_elem, \"height\")\n        height_elem.text = self.height\n        return top\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Size.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the size properties to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Size.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the size.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the size properties to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the size.\n    \"\"\"\n    top: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name})\n    size_elem: etree.Element = etree.SubElement(top, \"size\")\n    width_elem: etree.Element = etree.SubElement(size_elem, \"width\")\n    width_elem.text = self.width\n    height_elem: etree.Element = etree.SubElement(size_elem, \"height\")\n    height_elem.text = self.height\n    return top\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.SizePolicy","title":"<code>SizePolicy</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents the size policy for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.SizePolicy--attributes","title":"Attributes","text":"<p>hsizetype : str     The horizontal size type. vsizetype : str     The vertical size type.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass SizePolicy(XMLConvertible):\n    \"\"\"\n    Represents the size policy for a widget.\n\n    Attributes\n    ----------\n    hsizetype : str\n        The horizontal size type.\n    vsizetype : str\n        The vertical size type.\n    \"\"\"\n\n    hsizetype: str\n    vsizetype: str\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the size policy to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the size policy.\n        \"\"\"\n        top: etree.Element = etree.Element(\"property\", attrib={\"name\": \"sizePolicy\"})\n        sizePolicy_elem: etree.Element = etree.SubElement(\n            top,\n            \"sizepolicy\",\n            attrib={\n                \"hsizetype\": self.hsizetype,\n                \"vsizetype\": self.vsizetype,\n            },\n        )\n        horstretch: etree.Element = etree.SubElement(sizePolicy_elem, \"horstretch\")\n        horstretch.text = \"0\"\n        verstretch: etree.Element = etree.SubElement(sizePolicy_elem, \"verstretch\")\n        verstretch.text = \"0\"\n        return top\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.SizePolicy.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the size policy to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.SizePolicy.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the size policy.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the size policy to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the size policy.\n    \"\"\"\n    top: etree.Element = etree.Element(\"property\", attrib={\"name\": \"sizePolicy\"})\n    sizePolicy_elem: etree.Element = etree.SubElement(\n        top,\n        \"sizepolicy\",\n        attrib={\n            \"hsizetype\": self.hsizetype,\n            \"vsizetype\": self.vsizetype,\n        },\n    )\n    horstretch: etree.Element = etree.SubElement(sizePolicy_elem, \"horstretch\")\n    horstretch.text = \"0\"\n    verstretch: etree.Element = etree.SubElement(sizePolicy_elem, \"verstretch\")\n    verstretch.text = \"0\"\n    return top\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Str","title":"<code>Str</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a string property.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Str--attributes","title":"Attributes","text":"<p>name : str     The name of the property. string : str     The string value.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Str(XMLConvertible):\n    \"\"\"\n    Represents a string property.\n\n    Attributes\n    ----------\n    name : str\n        The name of the property.\n    string : str\n        The string value.\n    \"\"\"\n\n    name: str\n    string: str | bool\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the string property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the string.\n        \"\"\"\n        if (\n            isinstance(self.string, bool) and self.string\n        ):  # This came from edgecases with strings having empty values and were converted into bool True\n            self.string = \"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n        string_tag: etree.Element = etree.SubElement(prop, \"string\")\n        if isinstance(self.string, list):\n            raise TypeError(f\"Element &lt;{self.string}&gt; has list as .text: {self.string}\")\n        if isinstance(self.string, list):\n            raise TypeError(f\"Element &lt;{self.string}&gt; has list as .text: {self.string}\")\n        string_tag.text = self.string\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Str.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the string property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Str.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the string.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the string property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the string.\n    \"\"\"\n    if (\n        isinstance(self.string, bool) and self.string\n    ):  # This came from edgecases with strings having empty values and were converted into bool True\n        self.string = \"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n    string_tag: etree.Element = etree.SubElement(prop, \"string\")\n    if isinstance(self.string, list):\n        raise TypeError(f\"Element &lt;{self.string}&gt; has list as .text: {self.string}\")\n    if isinstance(self.string, list):\n        raise TypeError(f\"Element &lt;{self.string}&gt; has list as .text: {self.string}\")\n    string_tag.text = self.string\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.StringList","title":"<code>StringList</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a property containing a list of strings.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.StringList--attributes","title":"Attributes","text":"<p>name : str     The name of the property. items : List[str]     A list of string values.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass StringList(XMLConvertible):\n    \"\"\"\n    Represents a property containing a list of strings.\n\n    Attributes\n    ----------\n    name : str\n        The name of the property.\n    items : List[str]\n        A list of string values.\n    \"\"\"\n\n    name: str\n    items: List[str]\n\n    def to_xml(self) -&gt; etree.Element:\n        prop = etree.Element(\"property\", attrib={\"name\": self.name, \"stdset\": \"0\"})\n        stringlist = etree.SubElement(prop, \"stringlist\")\n\n        for item in self.items:\n            if not isinstance(item, str):\n                raise TypeError(f\"Expected string in StringList.items, got {type(item)}: {item}\")\n            string_el = etree.SubElement(stringlist, \"string\")\n            string_el.text = item\n        return prop\n\n    def escape_for_stringlist(self, s: str) -&gt; str:\n        return s.replace(\"&amp;\", \"&amp;amp;\").replace('\"', \"&amp;quot;\").replace(\"&lt;\", \"&amp;lt;\").replace(\"&gt;\", \"&amp;gt;\")\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.StyleSheet","title":"<code>StyleSheet</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a stylesheet for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.StyleSheet--attributes","title":"Attributes","text":"<p>lines : List[str]     A list of stylesheet lines.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass StyleSheet(XMLConvertible):\n    \"\"\"\n    Represents a stylesheet for a widget.\n\n    Attributes\n    ----------\n    lines : List[str]\n        A list of stylesheet lines.\n    \"\"\"\n\n    styles: Dict[str, Any]\n\n    def _format_value(self, key: str, value: Any) -&gt; str:\n        if isinstance(value, RGBA) and key in (\"color\", \"background-color\"):\n            r, g, b, *a = value\n            alpha = a[0] if a else 1.0\n            return f\"{key}: rgba({r}, {g}, {b}, {round(alpha, 2)});\"\n        return f\"{key}: {value};\"\n\n    def to_style_string(self) -&gt; str:\n        return \" \".join(self._format_value(k, v) for k, v in self.styles.items())\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the stylesheet to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the stylesheet.\n        \"\"\"\n        prop = ET.Element(\"property\", {\"name\": \"styleSheet\"})\n        string_elem = ET.SubElement(prop, \"string\")\n        style_str: str = self.to_style_string()\n        if \"background-color\" not in self.styles:\n            style_str += \"background-color: none;\"\n        string_elem.text = style_str\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.StyleSheet.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the stylesheet to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.StyleSheet.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the stylesheet.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the stylesheet to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the stylesheet.\n    \"\"\"\n    prop = ET.Element(\"property\", {\"name\": \"styleSheet\"})\n    string_elem = ET.SubElement(prop, \"string\")\n    style_str: str = self.to_style_string()\n    if \"background-color\" not in self.styles:\n        style_str += \"background-color: none;\"\n    string_elem.text = style_str\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.StyleSheetObject","title":"<code>StyleSheetObject</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Tangible</code></p> <p>A base class for UI elements that support stylesheet-based customization.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.StyleSheetObject--attributes","title":"Attributes","text":"<p>foreground_color : Optional[RGBA]     RGBA color tuple for the foreground (text) color. background_color : Optional[RGBA]     RGBA color tuple for the background color.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass StyleSheetObject(Tangible):\n    \"\"\"\n    A base class for UI elements that support stylesheet-based customization.\n\n    Attributes\n    ----------\n    foreground_color : Optional[RGBA]\n        RGBA color tuple for the foreground (text) color.\n    background_color : Optional[RGBA]\n        RGBA color tuple for the background color.\n    \"\"\"\n\n    foreground_color: Optional[RGBA] = None\n    background_color: Optional[RGBA] = None\n    useDisplayBg: Optional[bool] = None\n    name: Optional[str] = \"\"\n\n    def generate_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Generate a list of XML property elements for this object, including\n        any stylesheets derived from foreground or background color settings.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of XML elements representing properties, including inherited\n            ones from the base class and additional style properties if specified.\n        \"\"\"\n        properties: List[ET.Element] = super().generate_properties()\n\n        # if self.background_color is not None or self.foreground_color is not None:\n        styles: Dict[str, Any] = {}\n        if self.background_color is not None and self.useDisplayBg is None:\n            styles[\"background-color\"] = self.background_color\n        if self.foreground_color is not None:\n            styles[\"color\"] = self.foreground_color\n        if self.name.startswith(\"activeMenuButtonClass\") or self.name.startswith(\"activeMessageButtonClass\"):\n            styles[\"border\"] = \"1px solid black\"\n        properties.append(StyleSheet(styles).to_xml())\n\n        return properties\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.StyleSheetObject.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate a list of XML property elements for this object, including any stylesheets derived from foreground or background color settings.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.StyleSheetObject.generate_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of XML elements representing properties, including inherited     ones from the base class and additional style properties if specified.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def generate_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Generate a list of XML property elements for this object, including\n    any stylesheets derived from foreground or background color settings.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of XML elements representing properties, including inherited\n        ones from the base class and additional style properties if specified.\n    \"\"\"\n    properties: List[ET.Element] = super().generate_properties()\n\n    # if self.background_color is not None or self.foreground_color is not None:\n    styles: Dict[str, Any] = {}\n    if self.background_color is not None and self.useDisplayBg is None:\n        styles[\"background-color\"] = self.background_color\n    if self.foreground_color is not None:\n        styles[\"color\"] = self.foreground_color\n    if self.name.startswith(\"activeMenuButtonClass\") or self.name.startswith(\"activeMessageButtonClass\"):\n        styles[\"border\"] = \"1px solid black\"\n    properties.append(StyleSheet(styles).to_xml())\n\n    return properties\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Tangible","title":"<code>Tangible</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLSerializableMixin</code></p> <p>Represents a tangible widget that occupies space on a screen.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Tangible--attributes","title":"Attributes","text":"<p>x : int     The x-coordinate. y : int     The y-coordinate. width : int     The width of the widget. height : int     The height of the widget.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Tangible(XMLSerializableMixin):\n    \"\"\"\n    Represents a tangible widget that occupies space on a screen.\n\n    Attributes\n    ----------\n    x : int\n        The x-coordinate.\n    y : int\n        The y-coordinate.\n    width : int\n        The width of the widget.\n    height : int\n        The height of the widget.\n    \"\"\"\n\n    x: int = 0\n    y: int = 0\n    width: int = 0\n    height: int = 0\n    secretId: str = None\n\n    def generate_properties(self) -&gt; List[etree.Element]:\n        \"\"\"\n        Generate XML properties for the tangible widget.\n\n        Returns\n        -------\n        List[etree.Element]\n            A list containing the geometry property.\n        \"\"\"\n        properties: List[etree.Element] = []\n        properties.append(Geometry(self.x, self.y, max(self.width, 2), max(self.height, 2)).to_xml())\n        if self.secretId is not None:\n            properties.append(Str(\"secretId\", self.secretId).to_xml())\n            breakpoint()\n        return properties\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Tangible.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate XML properties for the tangible widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Tangible.generate_properties--returns","title":"Returns","text":"<p>List[etree.Element]     A list containing the geometry property.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def generate_properties(self) -&gt; List[etree.Element]:\n    \"\"\"\n    Generate XML properties for the tangible widget.\n\n    Returns\n    -------\n    List[etree.Element]\n        A list containing the geometry property.\n    \"\"\"\n    properties: List[etree.Element] = []\n    properties.append(Geometry(self.x, self.y, max(self.width, 2), max(self.height, 2)).to_xml())\n    if self.secretId is not None:\n        properties.append(Str(\"secretId\", self.secretId).to_xml())\n        breakpoint()\n    return properties\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Text","title":"<code>Text</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a text property for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Text--attributes","title":"Attributes","text":"<p>name : str     The name of the text property. string : str     The text content.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass Text(XMLConvertible):\n    \"\"\"\n    Represents a text property for a widget.\n\n    Attributes\n    ----------\n    name : str\n        The name of the text property.\n    string : str\n        The text content.\n    \"\"\"\n\n    name: str\n    string: str\n\n    def to_xml(self) -&gt; ET.Element:\n        \"\"\"\n        Convert the text property to an XML element.\n\n        Returns\n        -------\n        ET.Element\n            The XML element representing the text.\n        \"\"\"\n        prop: ET.Element = ET.Element(\"property\", attrib={\"name\": self.name})\n        string_tag: ET.Element = ET.SubElement(prop, \"string\")\n        string_tag.text = self.string\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.Text.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the text property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.Text.to_xml--returns","title":"Returns","text":"<p>ET.Element     The XML element representing the text.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; ET.Element:\n    \"\"\"\n    Convert the text property to an XML element.\n\n    Returns\n    -------\n    ET.Element\n        The XML element representing the text.\n    \"\"\"\n    prop: ET.Element = ET.Element(\"property\", attrib={\"name\": self.name})\n    string_tag: ET.Element = ET.SubElement(prop, \"string\")\n    string_tag.text = self.string\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.TextFormat","title":"<code>TextFormat</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents text format properties for a widget.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.TextFormat--attributes","title":"Attributes","text":"<p>text_format : str     The text format value.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass TextFormat(XMLConvertible):\n    \"\"\"\n    Represents text format properties for a widget.\n\n    Attributes\n    ----------\n    text_format : str\n        The text format value.\n    \"\"\"\n\n    text_format: str\n\n    def to_xml(self) -&gt; etree.Element:\n        \"\"\"\n        Convert the text format property to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the text format.\n        \"\"\"\n        prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"textFormat\"})\n        set_tag: etree.Element = etree.SubElement(prop, \"enum\")\n        set_tag.text = f\"Qt::{self.text_format.capitalize()}\"\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.TextFormat.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the text format property to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.TextFormat.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the text format.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; etree.Element:\n    \"\"\"\n    Convert the text format property to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the text format.\n    \"\"\"\n    prop: etree.Element = etree.Element(\"property\", attrib={\"name\": \"textFormat\"})\n    set_tag: etree.Element = etree.SubElement(prop, \"enum\")\n    set_tag.text = f\"Qt::{self.text_format.capitalize()}\"\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.TransparentBackground","title":"<code>TransparentBackground</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Represents a stylesheet that gives an object no background.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass TransparentBackground(XMLConvertible):\n    \"\"\"\n    Represents a stylesheet that gives an object no background.\n    \"\"\"\n\n    def to_xml(self):\n        \"\"\"\n        Convert the stylesheet to an XML element.\n\n        Returns\n        -------\n        etree.Element\n            The XML element representing the background stylesheet.\n        \"\"\"\n\n        style = \"background-color: transparent;\"\n        prop = ET.Element(\"property\", {\"name\": \"styleSheet\"})\n        string_elem = ET.SubElement(prop, \"string\")\n        string_elem.text = style\n        return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.TransparentBackground.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the stylesheet to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.TransparentBackground.to_xml--returns","title":"Returns","text":"<p>etree.Element     The XML element representing the background stylesheet.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self):\n    \"\"\"\n    Convert the stylesheet to an XML element.\n\n    Returns\n    -------\n    etree.Element\n        The XML element representing the background stylesheet.\n    \"\"\"\n\n    style = \"background-color: transparent;\"\n    prop = ET.Element(\"property\", {\"name\": \"styleSheet\"})\n    string_elem = ET.SubElement(prop, \"string\")\n    string_elem.text = style\n    return prop\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLConvertible","title":"<code>XMLConvertible</code>","text":"<p>Abstract base class for objects that can be converted to XML.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLConvertible--methods","title":"Methods","text":"<p>to_xml() -&gt; ET.Element     Convert the object to an XML element. to_string() -&gt; str     Return a formatted string representation of the XML element.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>class XMLConvertible:\n    \"\"\"\n    Abstract base class for objects that can be converted to XML.\n\n    Methods\n    -------\n    to_xml() -&gt; ET.Element\n        Convert the object to an XML element.\n    to_string() -&gt; str\n        Return a formatted string representation of the XML element.\n    \"\"\"\n\n    secretId: str = None\n\n    secretId: str = None\n\n    def to_xml(self) -&gt; ET.Element:\n        \"\"\"\n        Convert the object to an XML element.\n\n        Returns\n        -------\n        ET.Element\n            The XML element representation of the object.\n\n        Raises\n        ------\n        NotImplementedError\n            If the method is not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    def to_string(self) -&gt; str:\n        \"\"\"\n        Convert the XML element to a formatted string.\n\n        Returns\n        -------\n        str\n            The formatted string representation of the XML element.\n        \"\"\"\n        element: ET.Element = self.to_xml()\n        etree.indent(element)\n        return etree.tostring(element, encoding=\"unicode\")\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLConvertible.to_string","title":"<code>to_string()</code>","text":"<p>Convert the XML element to a formatted string.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLConvertible.to_string--returns","title":"Returns","text":"<p>str     The formatted string representation of the XML element.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_string(self) -&gt; str:\n    \"\"\"\n    Convert the XML element to a formatted string.\n\n    Returns\n    -------\n    str\n        The formatted string representation of the XML element.\n    \"\"\"\n    element: ET.Element = self.to_xml()\n    etree.indent(element)\n    return etree.tostring(element, encoding=\"unicode\")\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLConvertible.to_xml","title":"<code>to_xml()</code>","text":"<p>Convert the object to an XML element.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLConvertible.to_xml--returns","title":"Returns","text":"<p>ET.Element     The XML element representation of the object.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLConvertible.to_xml--raises","title":"Raises","text":"<p>NotImplementedError     If the method is not implemented by the subclass.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; ET.Element:\n    \"\"\"\n    Convert the object to an XML element.\n\n    Returns\n    -------\n    ET.Element\n        The XML element representation of the object.\n\n    Raises\n    ------\n    NotImplementedError\n        If the method is not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLSerializableMixin","title":"<code>XMLSerializableMixin</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XMLConvertible</code></p> <p>Mixin class that provides a generic XML serialization method.</p> <p>This mixin assumes that the class has a 'name' attribute and a 'generate_properties' method.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLSerializableMixin--attributes","title":"Attributes","text":"<p>name : Optional[str]     The name of the widget. count : ClassVar[int]     A class variable used to generate default names.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>@dataclass\nclass XMLSerializableMixin(XMLConvertible):\n    \"\"\"\n    Mixin class that provides a generic XML serialization method.\n\n    This mixin assumes that the class has a 'name' attribute and a\n    'generate_properties' method.\n\n    Attributes\n    ----------\n    name : Optional[str]\n        The name of the widget.\n    count : ClassVar[int]\n        A class variable used to generate default names.\n    \"\"\"\n\n    name: Optional[str] = None\n    count: ClassVar[int] = 1\n    secretId: str = None\n    secretId: str = None\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"\n        Set a default name if not provided.\n        \"\"\"\n        if not self.name:\n            self.name = f\"{type(self).__name__}{type(self).count}\"\n        type(self).count += 1\n\n    def generate_properties(self) -&gt; List[etree.Element]:\n        \"\"\"\n        Generate a list of XML property elements.\n        Subclasses should override this method to add thier own custom properties.\n\n        Returns\n        -------\n        List[etree.Element]\n            A list of XML elements representing properties.\n        \"\"\"\n        el: etree.Element = etree.Element(\"property\")\n        el.set(\"name\", \"base\")\n        el.text = \"value\"\n        return [el]\n\n    def to_xml(self) -&gt; ET.Element:\n        \"\"\"\n        Generate an XML element representing the object.\n\n        Returns\n        -------\n        ET.Element\n            The XML element representation of the object.\n\n        Raises\n        ------\n        ValueError\n            If the 'name' attribute is not set.\n        \"\"\"\n        if not hasattr(self, \"name\") or not self.name:\n            raise ValueError(f\"The 'name' attribute must be set for {type(self).__name__}.\")\n\n        widget: ET.Element = ET.Element(\n            \"widget\",\n            attrib={\n                \"class\": type(self).__name__,\n                \"name\": self.name,\n            },\n        )\n\n        properties: List[etree.Element] = self.generate_properties()\n        for prop in properties:\n            widget.append(prop)\n\n        additional_properties: List[etree.Element] = (\n            self.get_additional_properties() if hasattr(self, \"get_additional_properties\") else []\n        )\n        for prop in additional_properties:\n            if widget.find(prop.tag) is None:\n                widget.append(prop)\n\n        return widget\n\n    def get_additional_properties(self) -&gt; List[ET.Element]:\n        \"\"\"\n        Provide additional XML properties for the object.\n        Hook method for subclasses to provide additional XML properties.\n        Subclasses can override this method to add custom properties.\n\n        Returns\n        -------\n        List[ET.Element]\n            A list of additional XML elements representing properties.\n        \"\"\"\n        return []\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLSerializableMixin.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Set a default name if not provided.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"\n    Set a default name if not provided.\n    \"\"\"\n    if not self.name:\n        self.name = f\"{type(self).__name__}{type(self).count}\"\n    type(self).count += 1\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLSerializableMixin.generate_properties","title":"<code>generate_properties()</code>","text":"<p>Generate a list of XML property elements. Subclasses should override this method to add thier own custom properties.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLSerializableMixin.generate_properties--returns","title":"Returns","text":"<p>List[etree.Element]     A list of XML elements representing properties.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def generate_properties(self) -&gt; List[etree.Element]:\n    \"\"\"\n    Generate a list of XML property elements.\n    Subclasses should override this method to add thier own custom properties.\n\n    Returns\n    -------\n    List[etree.Element]\n        A list of XML elements representing properties.\n    \"\"\"\n    el: etree.Element = etree.Element(\"property\")\n    el.set(\"name\", \"base\")\n    el.text = \"value\"\n    return [el]\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLSerializableMixin.get_additional_properties","title":"<code>get_additional_properties()</code>","text":"<p>Provide additional XML properties for the object. Hook method for subclasses to provide additional XML properties. Subclasses can override this method to add custom properties.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLSerializableMixin.get_additional_properties--returns","title":"Returns","text":"<p>List[ET.Element]     A list of additional XML elements representing properties.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def get_additional_properties(self) -&gt; List[ET.Element]:\n    \"\"\"\n    Provide additional XML properties for the object.\n    Hook method for subclasses to provide additional XML properties.\n    Subclasses can override this method to add custom properties.\n\n    Returns\n    -------\n    List[ET.Element]\n        A list of additional XML elements representing properties.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLSerializableMixin.to_xml","title":"<code>to_xml()</code>","text":"<p>Generate an XML element representing the object.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLSerializableMixin.to_xml--returns","title":"Returns","text":"<p>ET.Element     The XML element representation of the object.</p>"},{"location":"reference/widgets_helpers/#widgets_helpers.XMLSerializableMixin.to_xml--raises","title":"Raises","text":"<p>ValueError     If the 'name' attribute is not set.</p> Source code in <code>pydmconverter/widgets_helpers.py</code> <pre><code>def to_xml(self) -&gt; ET.Element:\n    \"\"\"\n    Generate an XML element representing the object.\n\n    Returns\n    -------\n    ET.Element\n        The XML element representation of the object.\n\n    Raises\n    ------\n    ValueError\n        If the 'name' attribute is not set.\n    \"\"\"\n    if not hasattr(self, \"name\") or not self.name:\n        raise ValueError(f\"The 'name' attribute must be set for {type(self).__name__}.\")\n\n    widget: ET.Element = ET.Element(\n        \"widget\",\n        attrib={\n            \"class\": type(self).__name__,\n            \"name\": self.name,\n        },\n    )\n\n    properties: List[etree.Element] = self.generate_properties()\n    for prop in properties:\n        widget.append(prop)\n\n    additional_properties: List[etree.Element] = (\n        self.get_additional_properties() if hasattr(self, \"get_additional_properties\") else []\n    )\n    for prop in additional_properties:\n        if widget.find(prop.tag) is None:\n            widget.append(prop)\n\n    return widget\n</code></pre>"},{"location":"reference/edm/converter/","title":"Converter","text":""},{"location":"reference/edm/converter_helpers/","title":"Converter helpers","text":""},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.convert_edm_to_pydm_widgets","title":"<code>convert_edm_to_pydm_widgets(parser)</code>","text":"<p>Converts an EDMFileParser object into a collection of PyDM widget instances.</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.convert_edm_to_pydm_widgets--parameters","title":"Parameters","text":"<p>parser : EDMFileParser     The EDMFileParser instance containing parsed EDM objects and groups.</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.convert_edm_to_pydm_widgets--returns","title":"Returns","text":"<p>List[Union[widgets.PyDMWidgetBase, widgets.PyDMGroup]]     A list of PyDM widget instances representing the EDM UI.</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def convert_edm_to_pydm_widgets(parser: EDMFileParser):\n    \"\"\"\n    Converts an EDMFileParser object into a collection of PyDM widget instances.\n\n    Parameters\n    ----------\n    parser : EDMFileParser\n        The EDMFileParser instance containing parsed EDM objects and groups.\n\n    Returns\n    -------\n    List[Union[widgets.PyDMWidgetBase, widgets.PyDMGroup]]\n        A list of PyDM widget instances representing the EDM UI.\n    \"\"\"\n    pydm_widgets = []\n    used_classes = set()\n    color_list_filepath = search_color_list()\n    color_list_dict = parse_colors_list(color_list_filepath)\n\n    pip_objects = find_objects(parser.ui, \"activepipclass\")  # find tabs and populate tab bars with tabs\n    for pip_object in pip_objects:\n        create_embedded_tabs(pip_object, parser.ui)\n\n    text_objects = find_objects(\n        parser.ui, \"activextextclass\"\n    )  # TODO: If this gets too large, make into a helper function\n    for text_object in text_objects:\n        if should_delete_overlapping(parser.ui, text_object, \"relateddisplayclass\"):\n            delete_object_in_group(parser.ui, text_object)\n\n    def traverse_group(\n        edm_group: EDMGroup,\n        color_list_dict,\n        parent_pydm_group: Optional[PyDMFrame] = None,\n        pydm_widgets=None,\n        container_height: float = None,\n        scale: float = 1.0,\n        offset_x: float = 0,\n        offset_y: float = 0,\n        central_widget: EDMGroup = None,\n        parent_vispvs: Optional[List[Tuple[str, int, int]]] = None,\n        # parent_vis_range: Optional[Tuple[int, int]] = None,\n    ):\n        menu_mux_buttons = []\n        if pydm_widgets is None:\n            pydm_widgets = []\n\n        for obj in edm_group.objects:\n            if isinstance(obj, EDMGroup):\n                if parent_pydm_group is None:\n                    x, y, width, height = transform_edm_to_pydm(\n                        obj.x,\n                        obj.y,\n                        obj.width,\n                        obj.height,\n                        container_height=container_height,\n                        scale=scale,\n                        offset_x=offset_x,\n                        offset_y=offset_y,\n                    )\n                else:\n                    x, y, width, height = transform_nested_widget(\n                        obj.x,\n                        obj.y,\n                        obj.width,\n                        obj.height,\n                        parent_pydm_group.x,  # Add parent x\n                        parent_pydm_group.y,  # Add parent y\n                        parent_pydm_group.height,\n                        scale=scale,\n                    )\n\n                print(\"skipped pydm_group\")\n\n                if \"visPv\" in obj.properties and \"visMin\" in obj.properties and \"visMax\" in obj.properties:\n                    curr_vispv = [(obj.properties[\"visPv\"], obj.properties[\"visMin\"], obj.properties[\"visMax\"])]\n                elif \"visPv\" in obj.properties:\n                    curr_vispv = [(obj.properties[\"visPv\"], None, None)]\n                else:\n                    curr_vispv = []\n\n                if (\n                    \"symbolMin\" in obj.properties\n                    and \"symbolMax\" in obj.properties\n                    and \"symbolChannel\" in obj.properties\n                ):\n                    symbol_vispv = [\n                        (obj.properties[\"symbolChannel\"], obj.properties[\"symbolMin\"], obj.properties[\"symbolMax\"])\n                    ]\n                else:\n                    symbol_vispv = []\n\n                traverse_group(\n                    obj,\n                    color_list_dict,\n                    pydm_widgets=pydm_widgets,\n                    container_height=height,\n                    scale=scale,\n                    offset_x=0,\n                    offset_y=0,\n                    central_widget=central_widget,\n                    parent_vispvs=(parent_vispvs or []) + curr_vispv + symbol_vispv,\n                    # parent_vis_range=(parent_vis_range or []) + curr_vis_range,\n                )\n\n            elif isinstance(obj, EDMObject):\n                if obj.name.lower() == \"activelineclass\":\n                    widget_type = get_polyline_widget_type(obj)\n                elif obj.name.lower() == \"activearcclass\":\n                    widget_type = get_arc_widget_type(obj)\n                else:\n                    widget_type = EDM_TO_PYDM_WIDGETS.get(obj.name.lower())\n\n                if obj.name.lower() == \"menumuxclass\":\n                    menu_mux_buttons.append(obj)\n                if not widget_type:\n                    logger.warning(f\"Unsupported widget type: {obj.name}. Skipping.\")\n                    log_unsupported_widget(obj.name)\n                    continue\n                if obj.name.lower() == \"activechoicebuttonclass\" and (\n                    \"tabs\" not in obj.properties or not obj.properties[\"tabs\"]\n                ):\n                    channel = search_for_edm_attr(obj, \"channel\")\n\n                    if not channel:\n                        logger.warning(\"Could not find channel in object: {obj.name}\")\n                    else:\n                        tab_names = None\n                        # tab_names = get_channel_tabs(channel)\n                        widget_type = PyDMEnumButton\n                        obj.properties[\"tab_names\"] = tab_names\n                        obj.properties[\"hide_on_disconnect_channel\"] = channel\n\n                widget = widget_type(name=obj.name + str(id(obj)) if hasattr(obj, \"name\") else f\"widget_{id(obj)}\")\n                used_classes.add(type(widget).__name__)\n                logger.info(f\"Creating widget: {widget_type.__name__} ({widget.name})\")\n\n                if parent_vispvs:\n                    setattr(widget, \"visPvList\", list(parent_vispvs))\n\n                # Set mapped attributes.\n                for edm_attr, value in obj.properties.items():\n                    pydm_attr = EDM_TO_PYDM_ATTRIBUTES.get(edm_attr)\n\n                    if obj.name.lower() == \"activelineclass\" and edm_attr in [\"xPoints\", \"yPoints\", \"numPoints\"]:\n                        continue\n\n                    if not pydm_attr:\n                        continue\n\n                    if edm_attr == \"font\":\n                        value = parse_font_string(value)\n                    if edm_attr in (\"macro\", \"symbols\"):\n                        if isinstance(value, list):\n                            if isinstance(widget, PyDMEmbeddedDisplay) and len(value) == 1:\n                                macro_dict = parse_edm_macros(value[0])\n                                value = macro_dict\n                                logger.info(f\"Converted single macro to dict: {value}\")\n                            else:\n                                parsed_macros = []\n                                for macro_str in value:\n                                    macro_dict = parse_edm_macros(macro_str)\n                                    parsed_macros.append(json.dumps(macro_dict))\n                                value = \"\\n\".join(parsed_macros) if parsed_macros else None\n                                logger.info(f\"Converted macro list to: {value}\")\n                        elif isinstance(value, str):\n                            macro_dict = parse_edm_macros(value)\n                            if isinstance(widget, PyDMEmbeddedDisplay):\n                                value = macro_dict\n                            else:\n                                value = json.dumps(macro_dict) if macro_dict else None\n                            logger.info(f\"Converted macro string to: {value}\")\n                    if edm_attr == \"fillColor\":\n                        original_value = value\n                        color_tuple = convert_color_property_to_qcolor(value, color_data=color_list_dict)\n                        logger.info(f\"Color conversion: {original_value} -&gt; {color_tuple}\")\n                        if color_tuple:\n                            value = color_tuple\n                            logger.info(f\"Setting fillColor/brushColor to: {value}\")\n                        else:\n                            logger.warning(f\"Could not convert color {value}, skipping\")\n                            continue\n                    if edm_attr == \"value\":\n                        value = get_string_value(value)\n                    if edm_attr in COLOR_ATTRIBUTES:\n                        value = convert_color_property_to_qcolor(value, color_data=color_list_dict)\n                    if edm_attr == \"plotColor\":\n                        color_list = []\n                        for color in value:\n                            color_list.append(convert_color_property_to_qcolor(color, color_data=color_list_dict))\n                        value = color_list\n                    try:\n                        setattr(widget, pydm_attr, value)\n                        logger.info(f\"Set {pydm_attr} to {value} for {widget.name}\")\n                    except Exception as e:\n                        logger.error(f\"Failed to set attribute {pydm_attr} on {widget.name}: {e}\")\n\n                if obj.name.lower() == \"activechoicebuttonclass\" and widget_type == QTabWidget:\n                    populate_tab_bar(obj, widget)\n                if obj.name.lower() == \"activelineclass\" and isinstance(\n                    widget, (PyDMDrawingPolyline, PyDMDrawingIrregularPolygon)\n                ):\n                    if \"xPoints\" in obj.properties and \"yPoints\" in obj.properties:\n                        x_points = obj.properties[\"xPoints\"]\n                        y_points = obj.properties[\"yPoints\"]\n                        abs_pts = [(int(float(x) * scale), int(float(y) * scale)) for x, y in zip(x_points, y_points)]\n                        pen = int(obj.properties.get(\"lineWidth\", 1))\n\n                        arrow_size = 0\n                        if \"arrows\" in obj.properties and obj.properties[\"arrows\"] in (\"to\", \"from\", \"both\"):\n                            arrow_size = int(15 * scale)\n\n                        startCoord = (obj.x, obj.y)\n                        geom, point_strings = geom_and_local_points(abs_pts, startCoord, pen, arrow_size)\n\n                        widget.points = point_strings\n                        widget.penWidth = pen\n                        if widget.penColor is None:\n                            widget.penColor = (0, 0, 0, 255)\n\n                        if isinstance(widget, PyDMDrawingIrregularPolygon):\n                            if widget.brushColor is not None:\n                                widget.brushFill = True\n                                logger.info(f\"IrregularPolygon has explicit brushColor: {widget.brushColor}\")\n                            else:\n                                widget.brushColor = (255, 255, 255, 255)\n                                widget.brushFill = True\n                                logger.info(\n                                    \"Setting default white fill color for IrregularPolygon (no fillColor specified)\"\n                                )\n\n                            widget.alarm_sensitive_content = True\n                            logger.info(\n                                \"Enabled alarm_sensitive_content for IrregularPolygon to ensure fill is visible\"\n                            )\n\n                        widget.x = int(geom[\"x\"] + offset_x)\n                        widget.y = int(geom[\"y\"] + offset_y)\n                        widget.width = int(geom[\"width\"])\n                        widget.height = int(geom[\"height\"])\n                elif not (\n                    obj.name.lower() == \"activelineclass\"\n                    and isinstance(widget, (PyDMDrawingPolyline, PyDMDrawingIrregularPolygon))\n                ):\n                    if parent_pydm_group is None:\n                        x, y, width, height = transform_edm_to_pydm(\n                            obj.x,\n                            obj.y,\n                            obj.width,\n                            obj.height,\n                            container_height=container_height,\n                            scale=scale,\n                            offset_x=offset_x,\n                            offset_y=offset_y,\n                        )\n                    else:\n                        x, y, width, height = transform_nested_widget(\n                            obj.x,\n                            obj.y,\n                            obj.width,\n                            obj.height,\n                            parent_pydm_group.x,  # Add parent x\n                            parent_pydm_group.y,  # Add parent y\n                            parent_pydm_group.height,\n                            scale=scale,\n                        )\n                    widget.x = int(x)\n                    widget.y = int(y)\n                    widget.width = max(1, int(width))\n                    widget.height = max(1, int(height))\n\n                if type(widget).__name__ == \"PyDMPushButton\" and (\n                    \"offLabel\" in obj.properties and \"onLabel\" not in obj.properties\n                ):\n                    setattr(widget, \"text\", obj.properties[\"offLabel\"])\n                elif type(widget).__name__ == \"PyDMPushButton\" and (\n                    (\n                        (\"offLabel\" in obj.properties and obj.properties[\"offLabel\"] != obj.properties[\"onLabel\"])\n                        or (\"offColor\" in obj.properties and obj.properties[\"offColor\"] != obj.properties[\"onColor\"])\n                    )\n                    and hasattr(widget, \"channel\")\n                    and widget.channel is not None\n                ):\n                    off_button = create_off_button(widget)\n                    pydm_widgets.append(off_button)\n                if isinstance(widget, PyDMEmbeddedDisplay) and obj.name.lower() == \"activepipclass\":\n                    if \"displayFileName\" in obj.properties and obj.properties[\"displayFileName\"]:\n                        display_filenames = obj.properties[\"displayFileName\"]\n                        filename_to_set = None\n                        if isinstance(display_filenames, (list, tuple)) and len(display_filenames) &gt; 0:\n                            filename_to_set = display_filenames[0]\n                        elif isinstance(display_filenames, dict) and len(display_filenames) &gt; 0:\n                            filename_to_set = display_filenames[0]\n                        elif isinstance(display_filenames, str):\n                            filename_to_set = display_filenames\n\n                        if isinstance(filename_to_set, str):\n                            if filename_to_set.endswith(\".edl\"):\n                                filename_to_set = filename_to_set[:-4] + \".ui\"\n                            widget.filename = filename_to_set\n                            logger.info(f\"Set PyDMEmbeddedDisplay filename to: {widget.filename}\")\n\n                    # Make LOC variables unique if they had $(!W) marker\n                    if hasattr(widget, \"channel\") and widget.channel and \"__UNIQUE__\" in widget.channel:\n                        # Replace __UNIQUE__ with a unique suffix based on widget ID\n                        widget_id = str(id(widget))[-6:]\n                        widget.channel = widget.channel.replace(\"__UNIQUE__\", widget_id)\n                        logger.info(f\"Made LOC variable unique: {widget.channel}\")\n\n                if obj.name.lower() == \"activefreezebuttonclass\":\n                    freeze_button = create_freeze_button(widget)\n                    pydm_widgets.append(freeze_button)\n\n                if obj.name.lower() == \"mmvclass\":\n                    generated_sliders = create_multi_sliders(widget, obj)\n                    for slider in generated_sliders:\n                        pydm_widgets.append(slider)\n\n                if isinstance(widget, (PyDMDrawingLine, PyDMDrawingPolyline, PyDMDrawingIrregularPolygon)):\n                    pad = widget.penWidth or 1\n\n                    if isinstance(widget, PyDMDrawingIrregularPolygon):\n                        alarm_border_pad = (\n                            4 if hasattr(widget, \"alarm_sensitive_border\") and widget.alarm_sensitive_border else 0\n                        )\n                        pad = pad + alarm_border_pad\n\n                    min_dim = max(pad * 2, 3)\n\n                    if widget.width &lt; min_dim:\n                        widget.width = min_dim\n                    else:\n                        widget.width = int(widget.width) + pad\n\n                    if widget.height &lt; min_dim:\n                        widget.height = min_dim\n                    else:\n                        widget.height = int(widget.height) + pad\n\n                if isinstance(widget, PyDMLabel):\n                    min_width = 20\n                    min_height = 14\n\n                    if widget.width &lt; min_width:\n                        widget.width = min_width\n                    if widget.height &lt; min_height:\n                        widget.height = min_height\n\n                if isinstance(widget, (PyDMDrawingArc, PyDMDrawingPie, PyDMDrawingRectangle, PyDMDrawingEllipse)):\n                    if hasattr(widget, \"brushColor\") and widget.brushColor is not None:\n                        widget.alarm_sensitive_content = True\n                        logger.info(\n                            f\"Enabled alarm_sensitive_content for {type(widget).__name__} to ensure fill is visible\"\n                        )\n\n                if obj.properties.get(\"autoSize\", False) and hasattr(widget, \"autoSize\"):\n                    widget.autoSize = True\n\n                pydm_widgets.append(widget)\n                logger.info(f\"Added {widget.name} to root\")\n            else:\n                logger.warning(f\"Unknown object type: {type(obj)}. Skipping.\")\n\n        return pydm_widgets, menu_mux_buttons\n\n    pydm_widgets, menu_mux_buttons = traverse_group(\n        parser.ui,\n        color_list_dict,\n        None,\n        None,\n        parser.ui.height,\n        central_widget=parser.ui,\n    )\n\n    pydm_widgets = handle_button_polygon_overlaps(pydm_widgets)\n\n    if menu_mux_buttons:\n        generate_menumux_file(menu_mux_buttons, parser.output_file_path)\n    return pydm_widgets, used_classes\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.convert_pointsize","title":"<code>convert_pointsize(pixel_size, dpi=96)</code>","text":"<p>Convert the edm pizelsize to pydm pointsize (multiply by 0.75)</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def convert_pointsize(pixel_size, dpi: float = 96):\n    \"\"\"\n    Convert the edm pizelsize to pydm pointsize (multiply by 0.75)\n    \"\"\"\n    point_size = pixel_size * 72 / dpi\n    return math.floor(point_size)\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.count_loc_variable_instances","title":"<code>count_loc_variable_instances(group, channel_name)</code>","text":"<p>Count how many times a location variable channel appears in the widget tree.</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.count_loc_variable_instances--parameters","title":"Parameters","text":"<p>group : EDMGroup     The group to search within channel_name : str     The channel name to search for (e.g., \"loc://myVar\")</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.count_loc_variable_instances--returns","title":"Returns","text":"<p>int     Number of instances found</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def count_loc_variable_instances(group: EDMGroup, channel_name: str) -&gt; int:\n    \"\"\"\n    Count how many times a location variable channel appears in the widget tree.\n\n    Parameters\n    ----------\n    group : EDMGroup\n        The group to search within\n    channel_name : str\n        The channel name to search for (e.g., \"loc://myVar\")\n\n    Returns\n    -------\n    int\n        Number of instances found\n    \"\"\"\n    count = 0\n\n    def search_recursive(g: EDMGroup):\n        nonlocal count\n        for obj in g.objects:\n            if isinstance(obj, EDMGroup):\n                search_recursive(obj)\n            elif hasattr(obj, \"properties\"):\n                # Check all properties for the channel\n                for key, value in obj.properties.items():\n                    if isinstance(value, str) and channel_name in value:\n                        count += 1\n                        break  # Count this object once\n\n    search_recursive(group)\n    return count\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.create_embedded_tabs","title":"<code>create_embedded_tabs(obj, central_widget)</code>","text":"<p>If needed, creates tabs from local variables of this embedded display.</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.create_embedded_tabs--parameters","title":"Parameters","text":"<p>obj : EDMObject     The activePipClass EDMFileObject instance that will be used to generate tabs and embedded displays. (This object is an activePipClass).</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.create_embedded_tabs--returns","title":"Returns","text":"<p>bool     Returns true if embedded tabs added, returns false if unable to create embedded tabs</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def create_embedded_tabs(obj: EDMObject, central_widget: EDMGroup) -&gt; bool:\n    \"\"\"\n    If needed, creates tabs from local variables of this embedded display.\n\n    Parameters\n    ----------\n    obj : EDMObject\n        The activePipClass EDMFileObject instance that will be used to generate tabs and embedded displays. (This object is an activePipClass).\n\n    Returns\n    -------\n    bool\n        Returns true if embedded tabs added, returns false if unable to create embedded tabs\n    \"\"\"\n    searched_arr = None\n    loc_variable = None\n    channel_name = None\n\n    print(obj.properties.items())\n    for prop_name, prop_val in obj.properties.items():\n        if isinstance(prop_val, str) and (\n            \"loc://\" in prop_val or \"LOC\\\\\" in prop_val\n        ):  # TODO: is it possible to have multiple loc\\\\ in the same embedded display?\n            searched_arr = prop_val.split(\"=\")\n            loc_variable = prop_val  # Save full location variable string\n            channel_name = prop_val.split(\"?\")[0]\n\n    if int(obj.properties[\"numDsps\"]) &lt;= 1 or searched_arr is None:\n        return False\n\n    if loc_variable and channel_name:\n        instance_count = count_loc_variable_instances(central_widget, channel_name)\n\n        if instance_count &lt; 2:\n            logger.info(f\"Location variable {channel_name} only appears {instance_count} time(s)\")\n            logger.info(\"Creating hidden PyDMFrame to satisfy minimum instance requirement\")\n            create_hidden_frame_for_loc_variable(loc_variable, central_widget)\n\n    string_list = searched_arr[-1]\n\n    if string_list.startswith(\"[\") and string_list.endswith(\"]\"):\n        channel_list = string_list[1:-1].split(\", \")\n        tab_names = [item.strip(\"'\") for item in channel_list]\n    else:\n        tab_names = [string_list.strip(\"'\")]\n\n    for i in range(len(tab_names)):\n        if not tab_names[i]:\n            tab_names.pop(i)\n    tab_widget = search_group(central_widget, \"activeChoiceButtonClass\", channel_name, \"Pv\")\n    if tab_widget is None:\n        return False\n\n    tab_widget.properties[\"tabs\"] = tab_names\n    tab_widget.properties[\"displayFileName\"] = obj.properties[\"displayFileName\"]\n    tab_widget.properties[\"embeddedHeight\"] = obj.height\n    tab_widget.properties[\"embeddedWidth\"] = obj.width\n    # tab_widget.properties[\"w\"] = tab_widget.properties[\"w\"] + obj.properties[\"w\"] #prob not use\n    # tab_widget.properties[\"height\"] = tab_widget.properties[\"height\"] + obj.properties[\"height\"]\n    return True\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.create_freeze_button","title":"<code>create_freeze_button(widget)</code>","text":"<p>Given a PyDMPushButton converted from an activefreezebuttonclass, clone it into a \"freeze\" version. Modifies relevant visual attributes and appends a flag to identify it.</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def create_freeze_button(\n    widget: PyDMPushButton,\n):  # TODO: Can find a way to combine with create_off_button to reduce redundancy\n    \"\"\"\n    Given a PyDMPushButton converted from an activefreezebuttonclass, clone it into a \"freeze\" version.\n    Modifies relevant visual attributes and appends a flag to identify it.\n    \"\"\"\n    freeze_button = copy.deepcopy(widget)\n    freeze_button.name = widget.name + \"_freeze\"\n    if hasattr(widget, \"frozenLabel\"):\n        freeze_button.text = widget.frozenLabel\n    if hasattr(widget, \"frozen_background_color\"):\n        freeze_button.background_color = widget.frozen_background_color\n    setattr(freeze_button, \"is_freeze_button\", True)\n    setattr(widget, \"is_freeze_button\", False)\n    logger.info(f\"Created off-button: {freeze_button.name} based on {widget.name}\")\n\n    return freeze_button\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.create_hidden_frame_for_loc_variable","title":"<code>create_hidden_frame_for_loc_variable(loc_variable, central_widget)</code>","text":"<p>Create a hidden PyDMFrame with the location variable to satisfy the minimum 2-instance requirement for embedded tabs.</p> <p>The frame is invisible and positioned at (0,0) with 0 size so it doesn't interfere with clicks or disrupt the UI.</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.create_hidden_frame_for_loc_variable--parameters","title":"Parameters","text":"<p>loc_variable : str     The location variable (e.g., \"loc://myVar?init=['tab1', 'tab2']\") central_widget : EDMGroup     The central widget group to add the hidden frame to</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def create_hidden_frame_for_loc_variable(loc_variable: str, central_widget: EDMGroup) -&gt; None:\n    \"\"\"\n    Create a hidden PyDMFrame with the location variable to satisfy\n    the minimum 2-instance requirement for embedded tabs.\n\n    The frame is invisible and positioned at (0,0) with 0 size so it\n    doesn't interfere with clicks or disrupt the UI.\n\n    Parameters\n    ----------\n    loc_variable : str\n        The location variable (e.g., \"loc://myVar?init=['tab1', 'tab2']\")\n    central_widget : EDMGroup\n        The central widget group to add the hidden frame to\n    \"\"\"\n    channel_name = loc_variable.split(\"?\")[0]\n\n    hidden_frame = EDMObject(\n        name=\"Group\",\n        properties={\n            \"visPv\": channel_name,\n            \"visInvert\": True,\n            \"visMin\": 0,\n            \"visMax\": 1,\n        },\n        x=0,\n        y=0,\n        width=0,\n        height=0,\n    )\n\n    central_widget.add_object(hidden_frame)\n    logger.info(f\"Created hidden PyDMFrame for location variable: {channel_name}\")\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.create_multi_sliders","title":"<code>create_multi_sliders(widget, object)</code>","text":"<p>Given a ActiveSlider converted from a mmvclass, create stacked sliders to show each slider indicator. Modifies the height and channel of the current slider</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def create_multi_sliders(widget: PyDMSlider, object: EDMObject):\n    \"\"\"\n    Given a ActiveSlider converted from a mmvclass, create stacked sliders to show each slider indicator.\n    Modifies the height and channel of the current slider\n    \"\"\"\n    i = 1\n    prevColor = None\n    ctrl_attributes = []\n    extra_sliders = []\n    while f\"ctrl{i}Pv\" in object.properties:\n        if f\"ctrl{i}Color\" in object.properties:\n            currColor = object.properties[f\"ctrl{i}Color\"]\n        else:\n            currColor = prevColor\n        ctrl_attributes.append((object.properties[f\"ctrl{i}Pv\"], currColor))\n        prevColor = currColor\n        i += 1\n    if ctrl_attributes:\n        setattr(widget, \"height\", widget.height // len(ctrl_attributes))\n        setattr(widget, \"channel\", ctrl_attributes[0][0])\n        setattr(widget, \"indicatorColor\", ctrl_attributes[0][1])\n        for j in range(1, len(ctrl_attributes)):\n            curr_slider = copy.deepcopy(widget)\n            curr_slider.name = widget.name + f\"_{j}\"\n            setattr(curr_slider, \"y\", curr_slider.y + curr_slider.height * j)\n            setattr(curr_slider, \"channel\", ctrl_attributes[j][0])\n            setattr(curr_slider, \"indicatorColor\", ctrl_attributes[j][1])\n            logger.info(f\"Created multi-slider: {curr_slider.name} based on {widget.name}\")\n            extra_sliders.append(curr_slider)\n    return extra_sliders\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.create_off_button","title":"<code>create_off_button(widget)</code>","text":"<p>Given a PyDMPushButton with distinct off/on states, clone it into an \"off\" version. Modifies relevant visual attributes and appends a flag to identify it.</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def create_off_button(widget: PyDMPushButton):\n    \"\"\"\n    Given a PyDMPushButton with distinct off/on states, clone it into an \"off\" version.\n    Modifies relevant visual attributes and appends a flag to identify it.\n    \"\"\"\n    off_button = copy.deepcopy(widget)\n    off_button.name = widget.name + \"_off\"\n    if hasattr(widget, \"off_color\"):\n        off_button.on_color = widget.off_color\n    if hasattr(widget, \"off_label\"):\n        off_button.on_label = widget.off_label\n        off_button.text = widget.off_label\n        widget.text = widget.on_label\n    setattr(off_button, \"is_off_button\", True)\n    setattr(widget, \"is_off_button\", False)\n    logger.info(f\"Created off-button: {off_button.name} based on {widget.name}\")\n\n    return off_button\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.find_objects","title":"<code>find_objects(group, obj_name)</code>","text":"<p>Recursively search through an EDMGroup and its nested groups to find all instances of EDMObjects that match a specified name.</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.find_objects--parameters","title":"Parameters","text":"<p>group : EDMGroup     The EDMGroup instance within which to search for objects. obj_name : str     The name of the object to search for (case insensitive)</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.find_objects--returns","title":"Returns","text":"<p>List[EDMObject]     A list of EDMObject instances that match the specified name. If no     matches are found, an empty list is returned.</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def find_objects(group: EDMGroup, obj_name: str) -&gt; List[EDMObject]:\n    \"\"\"\n    Recursively search through an EDMGroup and its nested groups to find all\n    instances of EDMObjects that match a specified name.\n\n    Parameters\n    ----------\n    group : EDMGroup\n        The EDMGroup instance within which to search for objects.\n    obj_name : str\n        The name of the object to search for (case insensitive)\n\n    Returns\n    -------\n    List[EDMObject]\n        A list of EDMObject instances that match the specified name. If no\n        matches are found, an empty list is returned.\n    \"\"\"\n    objects = []\n    for obj in group.objects:\n        if isinstance(obj, EDMGroup):\n            objects += find_objects(obj, obj_name)\n        elif obj.name.lower() == obj_name.lower():\n            objects.append(obj)\n    return objects\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.get_arc_widget_type","title":"<code>get_arc_widget_type(obj)</code>","text":"<p>Determine if an activearcclass should be PyDMDrawingPie or PyDMDrawingArc.</p> <p>Returns PyDMDrawingPie if the arc has fill enabled. Otherwise returns PyDMDrawingArc.</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.get_arc_widget_type--parameters","title":"Parameters","text":"<p>obj : EDMObject     The EDM object to analyze</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.get_arc_widget_type--returns","title":"Returns","text":"<p>type     Either PyDMDrawingPie or PyDMDrawingArc</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def get_arc_widget_type(obj: EDMObject) -&gt; type:\n    \"\"\"\n    Determine if an activearcclass should be PyDMDrawingPie or PyDMDrawingArc.\n\n    Returns PyDMDrawingPie if the arc has fill enabled.\n    Otherwise returns PyDMDrawingArc.\n\n    Parameters\n    ----------\n    obj : EDMObject\n        The EDM object to analyze\n\n    Returns\n    -------\n    type\n        Either PyDMDrawingPie or PyDMDrawingArc\n    \"\"\"\n    has_fill = obj.properties.get(\"fill\") is True or \"fill\" in obj.properties\n    has_fill_color = \"fillColor\" in obj.properties\n\n    if has_fill or has_fill_color:\n        logger.info(\"Converting filled arc to PyDMDrawingPie\")\n        return PyDMDrawingPie\n    else:\n        return PyDMDrawingArc\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.get_polyline_widget_type","title":"<code>get_polyline_widget_type(obj)</code>","text":"<p>Determine if an activelineclass should be PyDMDrawingPolyline or PyDMDrawingIrregularPolygon.</p> <p>Returns PyDMDrawingIrregularPolygon if the polyline is: - Closed (first point == last point OR closePolygon is set) AND - Has fill color</p> <p>Otherwise returns PyDMDrawingPolyline.</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.get_polyline_widget_type--parameters","title":"Parameters","text":"<p>obj : EDMObject     The EDM object to analyze</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.get_polyline_widget_type--returns","title":"Returns","text":"<p>type     Either PyDMDrawingIrregularPolygon or PyDMDrawingPolyline</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def get_polyline_widget_type(obj: EDMObject) -&gt; type:\n    \"\"\"\n    Determine if an activelineclass should be PyDMDrawingPolyline or PyDMDrawingIrregularPolygon.\n\n    Returns PyDMDrawingIrregularPolygon if the polyline is:\n    - Closed (first point == last point OR closePolygon is set) AND\n    - Has fill color\n\n    Otherwise returns PyDMDrawingPolyline.\n\n    Parameters\n    ----------\n    obj : EDMObject\n        The EDM object to analyze\n\n    Returns\n    -------\n    type\n        Either PyDMDrawingIrregularPolygon or PyDMDrawingPolyline\n    \"\"\"\n    has_fill = obj.properties.get(\"fill\") is True or \"fill\" in obj.properties\n    has_fill_color = \"fillColor\" in obj.properties\n    is_closed = obj.properties.get(\"closePolygon\") is True\n\n    if not is_closed and \"xPoints\" in obj.properties and \"yPoints\" in obj.properties:\n        x_pts = obj.properties[\"xPoints\"]\n        y_pts = obj.properties[\"yPoints\"]\n        if len(x_pts) &gt; 1 and len(y_pts) &gt; 1:\n            is_closed = x_pts[0] == x_pts[-1] and y_pts[0] == y_pts[-1]\n\n    if (has_fill or has_fill_color) and is_closed:\n        logger.info(\"Converting closed filled polyline to PyDMDrawingIrregularPolygon\")\n        return PyDMDrawingIrregularPolygon\n    else:\n        return PyDMDrawingPolyline\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.get_string_value","title":"<code>get_string_value(value)</code>","text":"<p>Takes in a value string and joins each element into a string separated by a new line</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def get_string_value(value: list) -&gt; str:\n    \"\"\"\n    Takes in a value string and joins each element into a string separated by a new line\n    \"\"\"\n    return \"\\n\".join(value)\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.handle_button_polygon_overlaps","title":"<code>handle_button_polygon_overlaps(pydm_widgets)</code>","text":"<p>Detect when PyDMRelatedDisplayButton overlaps with PyDMDrawingIrregularPolygon. Set the button's flat property to True to make it transparent, and ensure the button is placed after the polygon in the widget list (on top in z-order).</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.handle_button_polygon_overlaps--parameters","title":"Parameters","text":"<p>pydm_widgets : List     List of PyDM widget instances</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.handle_button_polygon_overlaps--returns","title":"Returns","text":"<p>List     Updated list of PyDM widgets with proper ordering and flat property set</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def handle_button_polygon_overlaps(pydm_widgets):\n    \"\"\"\n    Detect when PyDMRelatedDisplayButton overlaps with PyDMDrawingIrregularPolygon.\n    Set the button's flat property to True to make it transparent, and ensure\n    the button is placed after the polygon in the widget list (on top in z-order).\n\n    Parameters\n    ----------\n    pydm_widgets : List\n        List of PyDM widget instances\n\n    Returns\n    -------\n    List\n        Updated list of PyDM widgets with proper ordering and flat property set\n    \"\"\"\n    from pydmconverter.widgets import PyDMRelatedDisplayButton, PyDMDrawingIrregularPolygon\n\n    buttons = [(i, w) for i, w in enumerate(pydm_widgets) if isinstance(w, PyDMRelatedDisplayButton)]\n    polygons = [(i, w) for i, w in enumerate(pydm_widgets) if isinstance(w, PyDMDrawingIrregularPolygon)]\n\n    buttons_to_move = []\n\n    for btn_idx, button in buttons:\n        for poly_idx, polygon in polygons:\n            if widgets_overlap(button, polygon):\n                logger.info(f\"Detected overlap: {button.name} overlaps with {polygon.name}\")\n                button.flat = True\n\n                if btn_idx &lt; poly_idx:\n                    buttons_to_move.append((btn_idx, button))\n                    logger.info(f\"Button {button.name} will be moved after polygon {polygon.name}\")\n                break\n\n    if buttons_to_move:\n        buttons_to_move.sort(key=lambda x: x[0], reverse=True)\n\n        for btn_idx, button in buttons_to_move:\n            pydm_widgets.pop(btn_idx)\n\n        for _, button in reversed(buttons_to_move):\n            pydm_widgets.append(button)\n\n    return pydm_widgets\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.parse_edm_macros","title":"<code>parse_edm_macros(macro_string)</code>","text":"<p>Parse an EDM macro string into a dictionary for PyDM widgets.</p> <p>EDM macros are in the format: \"KEY1=value1,KEY2=value2,KEY3=value3\" This function converts them to a Python dict: {\"KEY1\": \"value1\", \"KEY2\": \"value2\", \"KEY3\": \"value3\"}</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.parse_edm_macros--parameters","title":"Parameters","text":"<p>macro_string : str     The EDM macro string to parse (e.g., \"P=CAMR:LI20:110,R=:ASYN\")</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.parse_edm_macros--returns","title":"Returns","text":"<p>dict     A dictionary containing the parsed macro key-value pairs.     Returns an empty dict if the input is empty or None.</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.parse_edm_macros--examples","title":"Examples","text":"<p>parse_edm_macros(\"P=CAMR:LI20:110,R=:ASYN\") {'P': 'CAMR:LI20:110', 'R': ':ASYN'} parse_edm_macros(\"DEVICE=IOC:SYS0:1\") {'DEVICE': 'IOC:SYS0:1'} parse_edm_macros(\"\") {}</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def parse_edm_macros(macro_string: str) -&gt; dict:\n    \"\"\"\n    Parse an EDM macro string into a dictionary for PyDM widgets.\n\n    EDM macros are in the format: \"KEY1=value1,KEY2=value2,KEY3=value3\"\n    This function converts them to a Python dict: {\"KEY1\": \"value1\", \"KEY2\": \"value2\", \"KEY3\": \"value3\"}\n\n    Parameters\n    ----------\n    macro_string : str\n        The EDM macro string to parse (e.g., \"P=CAMR:LI20:110,R=:ASYN\")\n\n    Returns\n    -------\n    dict\n        A dictionary containing the parsed macro key-value pairs.\n        Returns an empty dict if the input is empty or None.\n\n    Examples\n    --------\n    &gt;&gt;&gt; parse_edm_macros(\"P=CAMR:LI20:110,R=:ASYN\")\n    {'P': 'CAMR:LI20:110', 'R': ':ASYN'}\n    &gt;&gt;&gt; parse_edm_macros(\"DEVICE=IOC:SYS0:1\")\n    {'DEVICE': 'IOC:SYS0:1'}\n    &gt;&gt;&gt; parse_edm_macros(\"\")\n    {}\n    \"\"\"\n    if not macro_string or not isinstance(macro_string, str):\n        return {}\n\n    macro_dict = {}\n    macro_string = macro_string.strip()\n\n    if not macro_string:\n        return {}\n\n    pairs = macro_string.split(\",\")\n\n    for pair in pairs:\n        pair = pair.strip()\n        if \"=\" in pair:\n            key, value = pair.split(\"=\", 1)\n            key = key.strip()\n            value = value.strip()\n            if value.startswith('\"') and value.endswith('\"'):\n                value = value[1:-1]\n            if value.startswith(\"'\") and value.endswith(\"'\"):\n                value = value[1:-1]\n            macro_dict[key] = value\n        else:\n            logger.warning(f\"Invalid macro pair format: '{pair}' in macro string: '{macro_string}'\")\n\n    return macro_dict\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.parse_font_string","title":"<code>parse_font_string(font_str)</code>","text":"<p>Parse an EDM font string like 'helvetica-bold-r-12.0' into a dictionary for a PyDM widget. This is just an example parser\u2014adjust as needed.</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def parse_font_string(font_str: str) -&gt; dict:\n    \"\"\"\n    Parse an EDM font string like 'helvetica-bold-r-12.0'\n    into a dictionary for a PyDM widget.\n    This is just an example parser\u2014adjust as needed.\n    \"\"\"\n    if not font_str:\n        font_str = \"helvetica-medium-r-12.0\"\n    parts = font_str.split(\"-\")\n    family = parts[0].capitalize()\n    bold = \"bold\" in parts[1].lower()\n    italic = \"i\" in parts[2].lower() or \"o\" in parts[2].lower()\n    size_str = parts[-1]\n    # pointsize = convert_pointsize(float(size_str))\n    # NOTE: This line is commented because of how I observed fastx displays pointsize. In browser mode, the conversion from pixelsize to pointsize is 0.75. In desktop mode, the conversion is ~0.51\n    # TODO: Find which version is accurate to how pydm is used and use that function\n    pointsize = convert_pointsize(float(size_str))\n\n    return {\n        \"family\": family,\n        \"pointsize\": pointsize,\n        \"bold\": bold,\n        \"italic\": italic,\n        \"weight\": 50,\n    }\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.search_group","title":"<code>search_group(group, widget_type, prop_val, prop_name_suffix='Pv')</code>","text":"<p>Recursively search through all nodes in an EDMGroup for a specified widget type and a property-value pair where property names end with a specific suffix.</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.search_group--parameters","title":"Parameters","text":"<p>group : EDMGroup     The EDMGroup to search within. widget_type : str     The type of widget to search for. property_val: str     The expected value. prop_name_suffix : str     The suffix that property names should end with to be checked.</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.search_group--returns","title":"Returns","text":"<p>Optional[EDMObject]     Returns the found EDMObject if it matches the criteria, else None.</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def search_group(\n    group: EDMGroup, widget_type: str, prop_val: str, prop_name_suffix: str = \"Pv\"\n) -&gt; EDMObject:  # TODO: May need to check for edgecases with multiple tabs\n    \"\"\"\n    Recursively search through all nodes in an EDMGroup for a specified widget type\n    and a property-value pair where property names end with a specific suffix.\n\n    Parameters\n    ----------\n    group : EDMGroup\n        The EDMGroup to search within.\n    widget_type : str\n        The type of widget to search for.\n    property_val: str\n        The expected value.\n    prop_name_suffix : str\n        The suffix that property names should end with to be checked.\n\n    Returns\n    -------\n    Optional[EDMObject]\n        Returns the found EDMObject if it matches the criteria, else None.\n    \"\"\"\n    for obj in group.objects:\n        if isinstance(obj, EDMGroup):\n            child_object = search_group(obj, widget_type, prop_val, prop_name_suffix)\n            if child_object is not None:\n                return child_object\n        elif obj.name.lower() == widget_type.lower():\n            for key, value in obj.properties.items():\n                if key.endswith(prop_name_suffix):\n                    if value is not None and prop_val in value:  # prop_val == value\n                        return obj\n\n    return None\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.transform_edm_to_pydm","title":"<code>transform_edm_to_pydm(edm_x, edm_y, edm_width, edm_height, container_height, scale=1.0, offset_x=0, offset_y=0)</code>","text":"<p>Transform coordinates from an EDM coordinate system (bottom-left origin) to a PyDM coordinate system (top-left origin) at the root level.</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def transform_edm_to_pydm(edm_x, edm_y, edm_width, edm_height, container_height, scale=1.0, offset_x=0, offset_y=0):\n    \"\"\"\n    Transform coordinates from an EDM coordinate system (bottom-left origin)\n    to a PyDM coordinate system (top-left origin) at the root level.\n    \"\"\"\n    pydm_x = offset_x + int(edm_x * scale)\n    pydm_width = edm_width * scale\n    pydm_height = edm_height * scale\n    pydm_y = offset_y + int(edm_y * scale)\n\n    logger.debug(\n        f\"Transform: EDM({edm_x}, {edm_y}, {edm_width}, {edm_height}) -&gt; PyDM({pydm_x}, {pydm_y}, {pydm_width}, {pydm_height})\"\n    )\n\n    return int(pydm_x), int(pydm_y), int(pydm_width), int(pydm_height)\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.transform_nested_widget","title":"<code>transform_nested_widget(child_edm_x, child_edm_y, child_edm_width, child_edm_height, parent_edm_x, parent_edm_y, parent_edm_height, scale=1.0)</code>","text":"<p>Transform child widget coordinates relative to its parent. If EDM uses absolute coordinates for nested widgets, subtract parent position.</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def transform_nested_widget(\n    child_edm_x,\n    child_edm_y,\n    child_edm_width,\n    child_edm_height,\n    parent_edm_x,\n    parent_edm_y,\n    parent_edm_height,\n    scale=1.0,\n):\n    \"\"\"\n    Transform child widget coordinates relative to its parent.\n    If EDM uses absolute coordinates for nested widgets, subtract parent position.\n    \"\"\"\n    # Convert to relative coordinates by subtracting parent position\n    relative_x = child_edm_x * scale  # - parent_edm_y\n    relative_y = child_edm_y * scale  # - parent_edm_x\n    child_width = child_edm_width * scale\n    child_height = child_edm_height * scale\n\n    return int(relative_x), int(relative_y), int(child_width), int(child_height)\n</code></pre>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.widgets_overlap","title":"<code>widgets_overlap(widget1, widget2)</code>","text":"<p>Check if two widgets overlap based on their geometry (x, y, width, height).</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.widgets_overlap--parameters","title":"Parameters","text":"<p>widget1, widget2 : PyDM widget instances     Widgets with x, y, width, height attributes</p>"},{"location":"reference/edm/converter_helpers/#edm.converter_helpers.widgets_overlap--returns","title":"Returns","text":"<p>bool     True if widgets overlap, False otherwise</p> Source code in <code>pydmconverter/edm/converter_helpers.py</code> <pre><code>def widgets_overlap(widget1, widget2) -&gt; bool:\n    \"\"\"\n    Check if two widgets overlap based on their geometry (x, y, width, height).\n\n    Parameters\n    ----------\n    widget1, widget2 : PyDM widget instances\n        Widgets with x, y, width, height attributes\n\n    Returns\n    -------\n    bool\n        True if widgets overlap, False otherwise\n    \"\"\"\n    x1, y1 = widget1.x, widget1.y\n    w1, h1 = widget1.width, widget1.height\n\n    x2, y2 = widget2.x, widget2.y\n    w2, h2 = widget2.width, widget2.height\n\n    if x1 + w1 &lt;= x2 or x2 + w2 &lt;= x1:\n        return False\n    if y1 + h1 &lt;= y2 or y2 + h2 &lt;= y1:\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/edm/menumux/","title":"Menumux","text":""},{"location":"reference/edm/parser/","title":"Parser","text":""},{"location":"reference/edm/parser/#edm.parser.EDMFileParser","title":"<code>EDMFileParser</code>","text":"<p>EDMFileParser class parses .edl files and creates a tree of EDMObjects and EDMGroups</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>class EDMFileParser:\n    \"\"\"EDMFileParser class parses .edl files and creates a tree of\n    EDMObjects and EDMGroups\"\"\"\n\n    screen_prop_pattern = re.compile(r\"beginScreenProperties(.*)endScreenProperties\", re.DOTALL)\n    group_pattern = re.compile(r\"object activeGroupClass(.*)endGroup\", re.DOTALL)\n    object_pattern = re.compile(\n        r\"object\\s+(\\w+(?::\\w+)?)\\s*beginObjectProperties\\s*(.*?)\\s*endObjectProperties(?=\\s*(?:#.*?)?(?:object|\\s*$))\",\n        re.DOTALL | re.MULTILINE,\n    )\n    # object_pattern = re.compile(\n    #    r\"object\\s+(\\w+)\\s*beginObjectProperties\\s*(.*?)\\s*endObjectProperties(?=\\s*(?:#.*?)?(?:object|\\s*$))\",\n    #    re.DOTALL | re.MULTILINE,\n    # )\n\n    def __init__(self, file_path: str | Path, output_file_path: str | Path):\n        \"\"\"Creates an instance of EDMFileParser for the given file_path\n\n        Parameters\n        ----------\n        file_path : str | Path\n            EDM file to parse\n        \"\"\"\n        if not Path(file_path).exists():\n            raise FileNotFoundError(f\"File not found: {file_path}\")\n        self.file_path = file_path\n        self.output_file_path = output_file_path\n\n        try:\n            with open(file_path, \"r\") as file:\n                self.text = file.read()\n        except UnicodeDecodeError as e:\n            logger.warning(f\"Could not read file as UTF-8 (bad byte at {e.start}): {e}. Switching to Latin-1...\")\n            with open(file_path, \"r\", encoding=\"latin-1\") as file:\n                self.text = file.read()\n        self.modify_text(file_path)\n\n        self.screen_properties_end = 0\n        self.ui = EDMGroup()\n\n        self.parse_screen_properties()\n        self.parse_objects_and_groups(self.text[self.screen_properties_end :], self.ui)\n\n    def modify_text(self, file_path) -&gt; str:  # unnecessary return\n        # Replace $(!W) with a marker\n        self.text = self.text.replace(\"$(!W)\", \"__UNIQUE__\")\n\n        self.text = self.text.replace(\n            \"$(!A)\", \"\"\n        )  # remove global macros TODO: In edm, these macros (!W) and (!A) are used to specify the scope of the macros (outside of a specific screen) this may need to be resolved more cleanly later\n        pattern = r\"\\\\*\\$\\(([^)]+)\\)\"\n        self.text = re.sub(pattern, r\"${\\1}\", self.text)\n        self.text, _, _ = replace_calc_and_loc_in_edm_content(self.text, file_path)\n        return self.text\n\n    def parse_screen_properties(self) -&gt; None:\n        \"\"\"Get the screen properties from the .edl file and set the UI\n        height and width\n        \"\"\"\n        match = self.screen_prop_pattern.search(self.text)\n        if match:\n            screen_prop_text = match.group(1)\n            self.screen_properties_end = match.end()\n            size_properties = self.get_size_properties(screen_prop_text, strict=True)\n            other_properties = self.get_object_properties(screen_prop_text)\n            if \"bgColor\" in other_properties:\n                color_list_filepath = search_color_list()\n                color_list_dict = parse_colors_list(color_list_filepath)\n\n                edmColor = other_properties[\"bgColor\"]\n                other_properties[\"bgColor\"] = convert_color_property_to_qcolor(edmColor, color_data=color_list_dict)\n            self.ui.properties = other_properties\n\n            self.ui.height = size_properties[\"height\"]\n            self.ui.width = size_properties[\"width\"]\n\n    def parse_objects_and_groups(self, text: str, parent_group: EDMGroup) -&gt; None:\n        \"\"\"Recursively parse the given text into a tree of EDMObjects and\n        EDMGroups. The parsed EDMObjects and EDMGroups are added to the\n        given parent_group, which is the root EDMGroup of the tree.\n        Parameters\n        ----------\n        text : str\n            Text from the file to be parsed\n        parent_group : EDMGroup\n            Parent EDMGroup to add the parsed EDMObjects and EDMGroups to\n        \"\"\"\n        pos = 0\n        while pos &lt; len(text):\n            # Skip whitespace and comments\n            while pos &lt; len(text) and (text[pos].isspace() or text[pos] == \"#\"):\n                if text[pos] == \"#\":\n                    while pos &lt; len(text) and text[pos] != \"\\n\":\n                        pos += 1\n                else:\n                    pos += 1\n            if pos &gt;= len(text):\n                break\n\n            if text[pos:].lstrip().startswith(\"object activeGroupClass\"):\n                group_start = pos\n\n                begin_obj_props = text.find(\"beginObjectProperties\", group_start)\n                begin_group_idx = text.find(\"beginGroup\", begin_obj_props)\n                end_group_idx = self.find_matching_end_group(text, begin_group_idx)\n                end_obj_props = text.find(\"endObjectProperties\", end_group_idx)\n\n                if begin_obj_props == -1 or end_obj_props == -1 or begin_group_idx == -1:\n                    snippet = text[pos : pos + 100].strip()\n                    print(f\"Skipping malformed group at {pos}, snippet: {snippet}\")\n                    pos += 1\n                    continue\n\n                end_group_idx = self.find_matching_end_group(text, begin_group_idx)\n                if end_group_idx == -1:\n                    print(f\"Could not find matching endGroup at {pos}\")\n                    pos += 1\n                    continue\n\n                # get rid of trailing endObjectProperties\n                extra_end_props = text.find(\"endObjectProperties\", end_group_idx)\n                group_end = (\n                    extra_end_props + len(\"endObjectProperties\")\n                    if (extra_end_props != -1 and extra_end_props &lt; text.find(\"object\", end_group_idx))\n                    else end_group_idx + len(\"endGroup\")\n                )\n                group_header = (\n                    text[begin_obj_props + len(\"beginObjectProperties\") : begin_group_idx]\n                    + text[end_group_idx + len(\"endGroup\") : end_obj_props]\n                )\n                group_body = text[begin_group_idx + len(\"beginGroup\") : end_group_idx]\n\n                size_props = self.get_size_properties(group_header)\n                properties = self.get_object_properties(group_header)\n\n                group = EDMGroup(**size_props)\n                group.properties = properties\n\n                self.parse_objects_and_groups(group_body, group)\n                parent_group.add_object(group)\n                pos = group_end\n                continue\n\n            # Try matching a regular object\n            object_match = self.object_pattern.search(text, pos)\n            if object_match:\n                name = object_match.group(1).replace(\":\", \"\")  # remove colons from name (causes issues with PyDM)\n                object_text = object_match.group(2)\n                size_properties = self.get_size_properties(object_text)\n                properties = self.get_object_properties(object_text)\n\n                if name.lower() == \"activesymbolclass\" or name.lower() == \"anasymbolclass\":\n                    obj = self.get_symbol_group(properties=properties, size_properties=size_properties)\n                else:\n                    obj = EDMObject(name=name, properties=properties, **size_properties)\n                parent_group.add_object(obj)\n\n                pos = object_match.end()\n            else:\n                snippet = text[pos : pos + 100]\n                print(f\"Unrecognized text at pos {pos}: '{snippet}'\")\n                pos = text.find(\"\\n\", pos) if \"\\n\" in text[pos:] else len(text)\n\n    def get_symbol_group(\n        self, properties: dict[str, bool | str | list[str]], size_properties: dict[str, int]\n    ) -&gt; EDMGroup:\n        \"\"\"\n        Generate an EDMGroup made up of child EDMGroups each representing a symbol.\n        These EDMGroups are mapped from the inner groups within the activesymbolclass\n        embedded file.\n\n        Parameters\n        ----------\n        properties : dict[str, bool | str | list[str]]\n            The activesymbolclass properties used to generate the output EDM Group\n        size_properties : dict[str, int]\n            The coordinate and size_properties of the activesymbolclass\n\n        Returns\n        ----------\n        EDMGroup\n            A group representing a collection of ActiveSymbolclass groups\n        \"\"\"\n        embedded_file = properties.get(\"file\")\n        if not embedded_file:\n            print(\"No embedded file specified in properties.\")\n            return EDMGroup()\n        if not embedded_file.endswith(\".edl\"):\n            embedded_file += \".edl\"\n        edm_paths = os.environ.get(\"EDMDATAFILES\", \".\").split(\":\")\n        embedded_text = None\n        for path in edm_paths:\n            full_path = Path(path) / embedded_file\n            if full_path.is_file():\n                with open(full_path, \"r\") as file:\n                    embedded_text = file.read()\n                break\n        if embedded_text is None:\n            return EDMGroup()\n\n        temp_group = EDMGroup()\n        match = self.screen_prop_pattern.search(embedded_text)\n        if match:\n            screen_properties_end = match.end()\n\n        num_pvs = properties[\"numPvs\"]\n        self.parse_objects_and_groups(embedded_text[screen_properties_end:], temp_group)\n        self.resize_symbol_groups(temp_group, size_properties)\n        self.add_symbol_properties(temp_group, properties)\n        if \"orientation\" in properties:\n            self.reorient_symbol_groups(temp_group, properties[\"orientation\"], size_properties)\n        if \"minValues\" not in properties or \"maxValues\" not in properties:\n            ranges = None\n        else:\n            ranges = self.generate_pv_ranges(properties)\n        self.remove_extra_groups(temp_group, ranges)\n        if num_pvs == 0 or num_pvs == \"0\":\n            self.remove_symbol_groups(temp_group, ranges)\n        elif ranges is not None:\n            self.populate_symbol_pvs(temp_group, properties, ranges)\n        return temp_group\n\n    def resize_symbol_groups(self, temp_group: EDMGroup, size_properties: dict[str, int]) -&gt; None:\n        \"\"\"\n        Given a group of symbol groups, modify the coordinates of each\n        object within the symbol groupsto be in relation to the coordinates\n        of the new file rather than from the embedded file.\n\n        Parameters\n        ----------\n        temp_group: EDMGroup\n            The EDMGroup making up each symbol group whose objects will be modified\n        size_properties : dict[str, int]\n            The coordinate and size_properties of the activesymbolclass\n        \"\"\"\n        for sub_group in temp_group.objects:\n            for sub_object in sub_group.objects:\n                sub_object.x = sub_object.x - sub_group.x + size_properties[\"x\"]\n                sub_object.y = sub_object.y - sub_group.y + size_properties[\"y\"]\n            sub_group.x = size_properties[\"x\"]\n            sub_group.y = size_properties[\n                \"y\"\n            ]  # The group resizing is needed to reorient symbol groups for rotations later\n\n    def reorient_symbol_groups(self, temp_group: EDMGroup, orientation: str, size_properties: dict[str, int]) -&gt; None:\n        \"\"\"\n        Given a group of symbol groups, change the orientation of each object\n        within the symbol groups (rotateCW, rotateCCW, FlipV, FlipH) either\n        flipping or rotating these objects about their respective symbol group.\n\n        Parameters\n        ----------\n        temp_group: EDMGroup\n            The EDMGroup making up each symbol group whose objects will be modified\n        orientation : str\n            The orientation instruction to flip or rotate\n        size_properties : dict[str, int]\n            The coordinate and size_properties of the activesymbolclass\n\n        Returns\n        ----------\n        EDMGroup\n            A group representing a collection of ActiveSymbolclass groups\n        \"\"\"\n        if orientation == \"FlipV\":\n            for sub_group in temp_group.objects:\n                for sub_object in sub_group.objects:\n                    if sub_object.name.lower() == \"activearcclass\":\n                        sub_object.properties[\"startAngle\"] = str(-int(sub_object.properties[\"startAngle\"]))\n                        sub_object.properties[\"totalAngle\"] = str(-int(sub_object.properties[\"totalAngle\"]))\n                    if sub_object.name.lower() == \"activelineclass\":\n                        for i in range(len(sub_object.properties[\"yPoints\"])):\n                            sub_object.properties[\"yPoints\"][i] = str(\n                                int(sub_object.height) - int(sub_object.properties[\"yPoints\"][i]) + int(sub_object.y)\n                            )\n                    sub_object.y = int(sub_object.height) + int(sub_object.y) - int(sub_group.height)\n\n        if orientation == \"FlipH\":\n            for sub_group in temp_group.objects:\n                for sub_object in sub_group.objects:\n                    if sub_object.name.lower() == \"activearcclass\":\n                        sub_object.properties[\"startAngle\"] = str(-int(sub_object.properties[\"startAngle\"]))\n                    if sub_object.name.lower() == \"activelineclass\":\n                        for i in range(len(sub_object.properties[\"xPoints\"])):\n                            sub_object.properties[\"xPoints\"][i] = str(\n                                int(sub_object.width) - int(sub_object.properties[\"xPoints\"][i]) + int(sub_object.x)\n                            )\n                    sub_object.x = int(size_properties[\"x\"]) - int(sub_object.x)\n        if orientation == \"rotateCW\":\n            for sub_group in temp_group.objects:\n                group_cx = sub_group.x + sub_group.width / 2\n                group_cy = sub_group.y + sub_group.height / 2\n\n                for sub_object in sub_group.objects:\n                    if sub_object.name.lower() == \"activearcclass\":\n                        sub_object.properties[\"startAngle\"] = str((int(sub_object.properties[\"startAngle\"]) - 90) % 360)\n\n                    obj_cx = sub_object.x + sub_object.width / 2\n                    obj_cy = sub_object.y + sub_object.height / 2\n\n                    rel_x = obj_cx - group_cx\n                    rel_y = obj_cy - group_cy\n\n                    new_rel_x = -rel_y\n                    new_rel_y = rel_x\n\n                    new_cx = group_cx + new_rel_x\n                    new_cy = group_cy + new_rel_y\n\n                    sub_object.x = int(new_cx - sub_object.height // 2)  # width/height swap\n                    sub_object.y = int(new_cy - sub_object.width // 2)\n\n                    sub_object.width, sub_object.height = sub_object.height, sub_object.width\n\n                    if \"xPoints\" in sub_object.properties and \"yPoints\" in sub_object.properties:\n                        for i in range(len(sub_object.properties[\"xPoints\"])):\n                            px = int(sub_object.properties[\"xPoints\"][i])\n                            py = int(sub_object.properties[\"yPoints\"][i])\n\n                            rel_px = px - group_cx\n                            rel_py = py - group_cy\n\n                            new_rel_px = rel_py\n                            new_rel_py = -rel_px\n\n                            sub_object.properties[\"xPoints\"][i] = str(group_cx + new_rel_px)\n                            sub_object.properties[\"yPoints\"][i] = str(group_cy + new_rel_py)\n\n        if orientation == \"rotateCCW\":\n            for sub_group in temp_group.objects:\n                group_cx = sub_group.x + sub_group.width / 2\n                group_cy = sub_group.y + sub_group.height / 2\n\n                for sub_object in sub_group.objects:\n                    if sub_object.name.lower() == \"activearcclass\":\n                        sub_object.properties[\"startAngle\"] = str((int(sub_object.properties[\"startAngle\"]) + 90) % 360)\n\n                    obj_cx = sub_object.x + sub_object.width / 2\n                    obj_cy = sub_object.y + sub_object.height / 2\n\n                    rel_x = obj_cx - group_cx\n                    rel_y = obj_cy - group_cy\n\n                    new_rel_x = rel_y\n                    new_rel_y = -rel_x\n\n                    new_cx = group_cx + new_rel_x\n                    new_cy = group_cy + new_rel_y\n\n                    sub_object.x = int(new_cx - sub_object.height // 2)  # width/height swap\n                    sub_object.y = int(new_cy - sub_object.width // 2)\n\n                    sub_object.width, sub_object.height = sub_object.height, sub_object.width\n\n                    if \"xPoints\" in sub_object.properties and \"yPoints\" in sub_object.properties:\n                        for i in range(len(sub_object.properties[\"xPoints\"])):\n                            px = int(sub_object.properties[\"xPoints\"][i])\n                            py = int(sub_object.properties[\"yPoints\"][i])\n\n                            rel_px = px - group_cx\n                            rel_py = py - group_cy\n\n                            new_rel_px = rel_py\n                            new_rel_py = -rel_px\n\n                            sub_object.properties[\"xPoints\"][i] = str(group_cx + new_rel_px)\n                            sub_object.properties[\"yPoints\"][i] = str(group_cy + new_rel_py)\n\n    def remove_extra_groups(self, temp_group: EDMGroup, ranges: list[list[str]]) -&gt; None:\n        \"\"\"\n        Given a group of symbol groups, remove extra groups that are outside\n        of the ranges given. (if there are more groups than ranges, the extra\n        groups are removed) Also, if there are no ranges, only include the first\n        group.\n\n        Parameters\n        ----------\n        temp_group: EDMGroup\n            The EDMGroup making up each symbol group whose objects will be modified\n        ranges: list[list[str]]\n            A list encompassing the ranges (mainly the len(ranges) is important)\n        \"\"\"\n        if ranges is None:\n            temp_group.objects = temp_group.objects[:1]\n            return\n        while len(temp_group.objects) &gt; len(ranges):\n            print(f\"removed symbol group: {temp_group.objects.pop()}\")\n\n    def remove_symbol_groups(self, temp_group: EDMGroup, ranges: list[list[str]]) -&gt; None:\n        \"\"\"\n        Given a group of symbol groups, remove all groups whose ranges do not include 1.\n        (This is done when no pvs are given and only the \"1\" group should be displayed)\n\n        Parameters\n        ----------\n        temp_group: EDMGroup\n            The EDMGroup making up each symbol group whose objects will be modified\n        ranges: list[list[str]]\n            A list encompassing the ranges (mainly the len(ranges) is important)\n        \"\"\"\n        for i in range(\n            len(ranges) - 1, -1, -1\n        ):  # going backwards so I do not need to change indices when deleting objects\n            min_range = ranges[i][0] or float(\"-inf\")\n            max_range = ranges[i][1] or float(\"inf\")\n            if float(min_range) &gt; 1 or float(max_range) &lt;= 1:\n                temp_group.objects.pop(i)\n\n    def generate_pv_ranges(\n        self, properties: dict[str, bool | str | list[str]]\n    ) -&gt; list[list[int, int]]:  # Should pass in minValues, maxValues, num_states in directly instead of properties\n        \"\"\"\n        Given minValues and maxValues (through properties), generate the ranges\n        that the min/maxValues represent.\n\n        Parameters\n        ----------\n        properties: dict[str, bool | str | list[str]]\n            Object properties from the activesymbolclass\n\n        Returns\n        ----------\n        list[list[int, int]]\n            The list of pv ranges\n        \"\"\"\n        min_values = properties[\"minValues\"]\n        max_values = properties[\"maxValues\"]\n        num_states = int(properties[\"numStates\"])\n        ranges = [[None, None] for _ in range(num_states)]\n        for i in range(len(min_values)):\n            separated_value = min_values[i].split(\" \")\n            if len(separated_value) == 1:\n                ranges[i][0] = separated_value[0]\n            elif len(separated_value) == 2:\n                ranges[int(separated_value[0])][0] = separated_value[1]\n            else:\n                raise ValueError(f\"Malformed minValue attribute: {min_values}\")\n        for i in range(len(max_values)):\n            separated_value = max_values[i].split(\" \")\n            if len(separated_value) == 1:\n                ranges[i][1] = separated_value[0]\n            elif len(separated_value) == 2:\n                ranges[int(separated_value[0])][1] = separated_value[1]\n            else:\n                raise ValueError(f\"Malformed maxValue attribute: {max_values}\")\n        return ranges\n\n    def populate_symbol_pvs(\n        self, temp_group: EDMGroup, properties: dict[str, bool | str | list[str]], ranges: list[list[str]]\n    ) -&gt; None:\n        \"\"\"\n        Given a group of symbol groups, add visPvs to each group based on their\n        respective ranges. This will determine which group will appear based on\n        the value of the pv connected to this activeSymbolClass.\n\n        Parameters\n        ----------\n        temp_group: EDMGroup\n            Group of groups whose objects will be modified\n        properties: dict[str, bool | str | list[str]]\n            Object properties from the activesymbolclass\n        ranges: list[list[str]]\n            The ranges taht determine the visPv ranges\n        \"\"\"\n        num_states = int(properties[\"numStates\"])\n        if len(properties[\"controlPvs\"]) &gt; 1:\n            print(f\"This symbol object has more than one pV: {properties}\")\n        for i in range(\n            min(len(temp_group.objects), num_states)\n        ):  # TODO: Figure out what happens when numStates &lt; temp_group.objects\n            temp_group.objects[i].properties[\"symbolMin\"] = ranges[i][0]\n            temp_group.objects[i].properties[\"symbolMax\"] = ranges[i][1]\n\n    def add_symbol_properties(self, temp_group: EDMGroup, properties: dict[str, bool | str | list[str]]) -&gt; None:\n        \"\"\"\n        Add properties to each sub object within a symbol group. (isSymbol and symbolChannel)\n        These are used to determine if the symbol should hide when symbolChannel is disconnected.\n\n        Parameters\n        ----------\n        temp_group: EDMGroup\n            Group of groups whose objects will be modified\n        properties: dict[str, bool | str | list[str]]\n            Object properties from the activesymbolclass\n        \"\"\"\n        if \"controlPvs\" in properties:\n            symbol_channel = properties[\"controlPvs\"][0]\n        else:\n            symbol_channel = None\n\n        for sub_group in temp_group.objects:\n            for sub_object in sub_group.objects:\n                sub_object.properties[\"isSymbol\"] = True\n                sub_object.properties[\"symbolChannel\"] = symbol_channel\n\n    def find_matching_end_group(self, text: str, begin_group_pos: int) -&gt; int:\n        \"\"\"Find the matching endGroup for a beginGroup, handling nested groups\"\"\"\n        pos = begin_group_pos + len(\"beginGroup\")\n        group_depth = 1\n\n        while pos &lt; len(text) and group_depth &gt; 0:\n            # Look for beginGroup\n            begin_group_next = text.find(\"beginGroup\", pos)\n            end_group_next = text.find(\"endGroup\", pos)\n\n            if end_group_next == -1:\n                return -1\n\n            if begin_group_next != -1 and begin_group_next &lt; end_group_next:\n                group_depth += 1\n                pos = begin_group_next + len(\"beginGroup\")\n            else:\n                group_depth -= 1\n                if group_depth == 0:\n                    return end_group_next\n                pos = end_group_next + len(\"endGroup\")\n\n        return -1\n\n    @staticmethod\n    def get_size_properties(text: str, strict: bool = False) -&gt; dict[str, int]:\n        \"\"\"Get the size properties from the given text (x, y, width, height)\n\n        Parameters\n        ----------\n        text : str\n            Text to extract size properties from\n\n        Returns\n        -------\n        dict : str, int\n            A dictionary containing the size properties from the text\n        \"\"\"\n        size_properties = {}\n        for prop in [\"x\", \"y\", \"width\", \"height\"]:\n            match = re.search(rf\"^{prop[0]}\\s+(-?\\d+)\", text, re.M)\n            if not match and strict:\n                raise ValueError(f\"Missing required property '{prop}' in widget.\")\n\n            if not match:\n                \"\"\"match_macro = re.search(rf\"^{prop[0]}\\\\s+(\\\\$\\\\{{[A-Za-z_][A-Za-z0-9_]*\\\\}})\", text, re.M)\n                if not match_macro:\n                    raise ValueError(f\"Missing required property '{prop}' in widget.\")\n                size_properties[prop] = match_macro.group(1)\"\"\"\n                print(\n                    f\"Missing size property (likely a macro): {prop}\"\n                )  # TODO: Come back and use the improved solution\n                size_properties[prop] = 1\n                # raise ValueError(f\"Missing required property '{prop}' in widget.\")\n            else:\n                size_properties[prop] = int(match.group(1))\n\n        return size_properties\n\n    @classmethod\n    def get_object_properties(cls, text: str) -&gt; dict[str, bool | str | list[str]]:\n        \"\"\"Get the object properties from the given text. This can be any\n        property that an EDM Object may use (e.g. fillColor, value, editable).\n        Size properties and version information are ignored.\n\n        Parameters\n        ----------\n        text : str\n            Text to extract properties from\n\n        Returns\n        -------\n        dict : str, bool | str | list[str]\n            A dictionary containing the properties of an object\n        \"\"\"\n        in_multi_line = False\n        multi_line_key = None\n        multi_line_prop = []\n        properties = {}\n\n        for line in text.splitlines():\n            if not line or line.startswith(IGNORED_PROPERTIES):\n                continue\n\n            if in_multi_line:\n                if line == \"}\":\n                    in_multi_line = False\n                    cleaned_prop = cls.remove_prepended_index(multi_line_prop)\n                    properties[multi_line_key] = cleaned_prop\n                    multi_line_prop = []\n                else:\n                    multi_line_prop.append(line.strip(' \"'))\n                continue\n\n            try:\n                k, v = line.split(maxsplit=1)\n                v = v.strip(' \"')\n            except ValueError:\n                k, v = line, True\n\n            if v == \"{\":\n                in_multi_line = True\n                multi_line_key = k\n            else:\n                properties[k] = v\n\n        return properties\n\n    @staticmethod\n    def remove_prepended_index(lines: list[str]) -&gt; list[str]:\n        \"\"\"Removes the prepended indices from the given multi-line property value\n\n        Parameters\n        ----------\n        lines : list[str]\n            List of lines in a multi-line property value to remove the prepended indices from\n\n        Returns\n        -------\n        list[str]\n            Lines of the multi-line property value with the prepended indices removed\n        \"\"\"\n        indices = []\n        values = []\n\n        def check_sequential(indices):\n            \"\"\"Check if the list of indices is sequential starting from 0\"\"\"\n            return indices == list(range(len(indices)))\n\n        for line in lines:\n            try:\n                k, v = line.split(maxsplit=1)\n                indices.append(int(k))\n                values.append(v.strip(' \"'))\n            except ValueError:\n                return lines\n\n        if not check_sequential(indices):\n            return lines\n        return values\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.__init__","title":"<code>__init__(file_path, output_file_path)</code>","text":"<p>Creates an instance of EDMFileParser for the given file_path</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.__init__--parameters","title":"Parameters","text":"<p>file_path : str | Path     EDM file to parse</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>def __init__(self, file_path: str | Path, output_file_path: str | Path):\n    \"\"\"Creates an instance of EDMFileParser for the given file_path\n\n    Parameters\n    ----------\n    file_path : str | Path\n        EDM file to parse\n    \"\"\"\n    if not Path(file_path).exists():\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n    self.file_path = file_path\n    self.output_file_path = output_file_path\n\n    try:\n        with open(file_path, \"r\") as file:\n            self.text = file.read()\n    except UnicodeDecodeError as e:\n        logger.warning(f\"Could not read file as UTF-8 (bad byte at {e.start}): {e}. Switching to Latin-1...\")\n        with open(file_path, \"r\", encoding=\"latin-1\") as file:\n            self.text = file.read()\n    self.modify_text(file_path)\n\n    self.screen_properties_end = 0\n    self.ui = EDMGroup()\n\n    self.parse_screen_properties()\n    self.parse_objects_and_groups(self.text[self.screen_properties_end :], self.ui)\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.add_symbol_properties","title":"<code>add_symbol_properties(temp_group, properties)</code>","text":"<p>Add properties to each sub object within a symbol group. (isSymbol and symbolChannel) These are used to determine if the symbol should hide when symbolChannel is disconnected.</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.add_symbol_properties--parameters","title":"Parameters","text":"<p>temp_group: EDMGroup     Group of groups whose objects will be modified properties: dict[str, bool | str | list[str]]     Object properties from the activesymbolclass</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>def add_symbol_properties(self, temp_group: EDMGroup, properties: dict[str, bool | str | list[str]]) -&gt; None:\n    \"\"\"\n    Add properties to each sub object within a symbol group. (isSymbol and symbolChannel)\n    These are used to determine if the symbol should hide when symbolChannel is disconnected.\n\n    Parameters\n    ----------\n    temp_group: EDMGroup\n        Group of groups whose objects will be modified\n    properties: dict[str, bool | str | list[str]]\n        Object properties from the activesymbolclass\n    \"\"\"\n    if \"controlPvs\" in properties:\n        symbol_channel = properties[\"controlPvs\"][0]\n    else:\n        symbol_channel = None\n\n    for sub_group in temp_group.objects:\n        for sub_object in sub_group.objects:\n            sub_object.properties[\"isSymbol\"] = True\n            sub_object.properties[\"symbolChannel\"] = symbol_channel\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.find_matching_end_group","title":"<code>find_matching_end_group(text, begin_group_pos)</code>","text":"<p>Find the matching endGroup for a beginGroup, handling nested groups</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>def find_matching_end_group(self, text: str, begin_group_pos: int) -&gt; int:\n    \"\"\"Find the matching endGroup for a beginGroup, handling nested groups\"\"\"\n    pos = begin_group_pos + len(\"beginGroup\")\n    group_depth = 1\n\n    while pos &lt; len(text) and group_depth &gt; 0:\n        # Look for beginGroup\n        begin_group_next = text.find(\"beginGroup\", pos)\n        end_group_next = text.find(\"endGroup\", pos)\n\n        if end_group_next == -1:\n            return -1\n\n        if begin_group_next != -1 and begin_group_next &lt; end_group_next:\n            group_depth += 1\n            pos = begin_group_next + len(\"beginGroup\")\n        else:\n            group_depth -= 1\n            if group_depth == 0:\n                return end_group_next\n            pos = end_group_next + len(\"endGroup\")\n\n    return -1\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.generate_pv_ranges","title":"<code>generate_pv_ranges(properties)</code>","text":"<p>Given minValues and maxValues (through properties), generate the ranges that the min/maxValues represent.</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.generate_pv_ranges--parameters","title":"Parameters","text":"<p>properties: dict[str, bool | str | list[str]]     Object properties from the activesymbolclass</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.generate_pv_ranges--returns","title":"Returns","text":"<p>list[list[int, int]]     The list of pv ranges</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>def generate_pv_ranges(\n    self, properties: dict[str, bool | str | list[str]]\n) -&gt; list[list[int, int]]:  # Should pass in minValues, maxValues, num_states in directly instead of properties\n    \"\"\"\n    Given minValues and maxValues (through properties), generate the ranges\n    that the min/maxValues represent.\n\n    Parameters\n    ----------\n    properties: dict[str, bool | str | list[str]]\n        Object properties from the activesymbolclass\n\n    Returns\n    ----------\n    list[list[int, int]]\n        The list of pv ranges\n    \"\"\"\n    min_values = properties[\"minValues\"]\n    max_values = properties[\"maxValues\"]\n    num_states = int(properties[\"numStates\"])\n    ranges = [[None, None] for _ in range(num_states)]\n    for i in range(len(min_values)):\n        separated_value = min_values[i].split(\" \")\n        if len(separated_value) == 1:\n            ranges[i][0] = separated_value[0]\n        elif len(separated_value) == 2:\n            ranges[int(separated_value[0])][0] = separated_value[1]\n        else:\n            raise ValueError(f\"Malformed minValue attribute: {min_values}\")\n    for i in range(len(max_values)):\n        separated_value = max_values[i].split(\" \")\n        if len(separated_value) == 1:\n            ranges[i][1] = separated_value[0]\n        elif len(separated_value) == 2:\n            ranges[int(separated_value[0])][1] = separated_value[1]\n        else:\n            raise ValueError(f\"Malformed maxValue attribute: {max_values}\")\n    return ranges\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.get_object_properties","title":"<code>get_object_properties(text)</code>  <code>classmethod</code>","text":"<p>Get the object properties from the given text. This can be any property that an EDM Object may use (e.g. fillColor, value, editable). Size properties and version information are ignored.</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.get_object_properties--parameters","title":"Parameters","text":"<p>text : str     Text to extract properties from</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.get_object_properties--returns","title":"Returns","text":"<p>dict : str, bool | str | list[str]     A dictionary containing the properties of an object</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>@classmethod\ndef get_object_properties(cls, text: str) -&gt; dict[str, bool | str | list[str]]:\n    \"\"\"Get the object properties from the given text. This can be any\n    property that an EDM Object may use (e.g. fillColor, value, editable).\n    Size properties and version information are ignored.\n\n    Parameters\n    ----------\n    text : str\n        Text to extract properties from\n\n    Returns\n    -------\n    dict : str, bool | str | list[str]\n        A dictionary containing the properties of an object\n    \"\"\"\n    in_multi_line = False\n    multi_line_key = None\n    multi_line_prop = []\n    properties = {}\n\n    for line in text.splitlines():\n        if not line or line.startswith(IGNORED_PROPERTIES):\n            continue\n\n        if in_multi_line:\n            if line == \"}\":\n                in_multi_line = False\n                cleaned_prop = cls.remove_prepended_index(multi_line_prop)\n                properties[multi_line_key] = cleaned_prop\n                multi_line_prop = []\n            else:\n                multi_line_prop.append(line.strip(' \"'))\n            continue\n\n        try:\n            k, v = line.split(maxsplit=1)\n            v = v.strip(' \"')\n        except ValueError:\n            k, v = line, True\n\n        if v == \"{\":\n            in_multi_line = True\n            multi_line_key = k\n        else:\n            properties[k] = v\n\n    return properties\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.get_size_properties","title":"<code>get_size_properties(text, strict=False)</code>  <code>staticmethod</code>","text":"<p>Get the size properties from the given text (x, y, width, height)</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.get_size_properties--parameters","title":"Parameters","text":"<p>text : str     Text to extract size properties from</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.get_size_properties--returns","title":"Returns","text":"<p>dict : str, int     A dictionary containing the size properties from the text</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>@staticmethod\ndef get_size_properties(text: str, strict: bool = False) -&gt; dict[str, int]:\n    \"\"\"Get the size properties from the given text (x, y, width, height)\n\n    Parameters\n    ----------\n    text : str\n        Text to extract size properties from\n\n    Returns\n    -------\n    dict : str, int\n        A dictionary containing the size properties from the text\n    \"\"\"\n    size_properties = {}\n    for prop in [\"x\", \"y\", \"width\", \"height\"]:\n        match = re.search(rf\"^{prop[0]}\\s+(-?\\d+)\", text, re.M)\n        if not match and strict:\n            raise ValueError(f\"Missing required property '{prop}' in widget.\")\n\n        if not match:\n            \"\"\"match_macro = re.search(rf\"^{prop[0]}\\\\s+(\\\\$\\\\{{[A-Za-z_][A-Za-z0-9_]*\\\\}})\", text, re.M)\n            if not match_macro:\n                raise ValueError(f\"Missing required property '{prop}' in widget.\")\n            size_properties[prop] = match_macro.group(1)\"\"\"\n            print(\n                f\"Missing size property (likely a macro): {prop}\"\n            )  # TODO: Come back and use the improved solution\n            size_properties[prop] = 1\n            # raise ValueError(f\"Missing required property '{prop}' in widget.\")\n        else:\n            size_properties[prop] = int(match.group(1))\n\n    return size_properties\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.get_symbol_group","title":"<code>get_symbol_group(properties, size_properties)</code>","text":"<p>Generate an EDMGroup made up of child EDMGroups each representing a symbol. These EDMGroups are mapped from the inner groups within the activesymbolclass embedded file.</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.get_symbol_group--parameters","title":"Parameters","text":"<p>properties : dict[str, bool | str | list[str]]     The activesymbolclass properties used to generate the output EDM Group size_properties : dict[str, int]     The coordinate and size_properties of the activesymbolclass</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.get_symbol_group--returns","title":"Returns","text":"<p>EDMGroup     A group representing a collection of ActiveSymbolclass groups</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>def get_symbol_group(\n    self, properties: dict[str, bool | str | list[str]], size_properties: dict[str, int]\n) -&gt; EDMGroup:\n    \"\"\"\n    Generate an EDMGroup made up of child EDMGroups each representing a symbol.\n    These EDMGroups are mapped from the inner groups within the activesymbolclass\n    embedded file.\n\n    Parameters\n    ----------\n    properties : dict[str, bool | str | list[str]]\n        The activesymbolclass properties used to generate the output EDM Group\n    size_properties : dict[str, int]\n        The coordinate and size_properties of the activesymbolclass\n\n    Returns\n    ----------\n    EDMGroup\n        A group representing a collection of ActiveSymbolclass groups\n    \"\"\"\n    embedded_file = properties.get(\"file\")\n    if not embedded_file:\n        print(\"No embedded file specified in properties.\")\n        return EDMGroup()\n    if not embedded_file.endswith(\".edl\"):\n        embedded_file += \".edl\"\n    edm_paths = os.environ.get(\"EDMDATAFILES\", \".\").split(\":\")\n    embedded_text = None\n    for path in edm_paths:\n        full_path = Path(path) / embedded_file\n        if full_path.is_file():\n            with open(full_path, \"r\") as file:\n                embedded_text = file.read()\n            break\n    if embedded_text is None:\n        return EDMGroup()\n\n    temp_group = EDMGroup()\n    match = self.screen_prop_pattern.search(embedded_text)\n    if match:\n        screen_properties_end = match.end()\n\n    num_pvs = properties[\"numPvs\"]\n    self.parse_objects_and_groups(embedded_text[screen_properties_end:], temp_group)\n    self.resize_symbol_groups(temp_group, size_properties)\n    self.add_symbol_properties(temp_group, properties)\n    if \"orientation\" in properties:\n        self.reorient_symbol_groups(temp_group, properties[\"orientation\"], size_properties)\n    if \"minValues\" not in properties or \"maxValues\" not in properties:\n        ranges = None\n    else:\n        ranges = self.generate_pv_ranges(properties)\n    self.remove_extra_groups(temp_group, ranges)\n    if num_pvs == 0 or num_pvs == \"0\":\n        self.remove_symbol_groups(temp_group, ranges)\n    elif ranges is not None:\n        self.populate_symbol_pvs(temp_group, properties, ranges)\n    return temp_group\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.parse_objects_and_groups","title":"<code>parse_objects_and_groups(text, parent_group)</code>","text":"<p>Recursively parse the given text into a tree of EDMObjects and EDMGroups. The parsed EDMObjects and EDMGroups are added to the given parent_group, which is the root EDMGroup of the tree. Parameters</p> <p>text : str     Text from the file to be parsed parent_group : EDMGroup     Parent EDMGroup to add the parsed EDMObjects and EDMGroups to</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>def parse_objects_and_groups(self, text: str, parent_group: EDMGroup) -&gt; None:\n    \"\"\"Recursively parse the given text into a tree of EDMObjects and\n    EDMGroups. The parsed EDMObjects and EDMGroups are added to the\n    given parent_group, which is the root EDMGroup of the tree.\n    Parameters\n    ----------\n    text : str\n        Text from the file to be parsed\n    parent_group : EDMGroup\n        Parent EDMGroup to add the parsed EDMObjects and EDMGroups to\n    \"\"\"\n    pos = 0\n    while pos &lt; len(text):\n        # Skip whitespace and comments\n        while pos &lt; len(text) and (text[pos].isspace() or text[pos] == \"#\"):\n            if text[pos] == \"#\":\n                while pos &lt; len(text) and text[pos] != \"\\n\":\n                    pos += 1\n            else:\n                pos += 1\n        if pos &gt;= len(text):\n            break\n\n        if text[pos:].lstrip().startswith(\"object activeGroupClass\"):\n            group_start = pos\n\n            begin_obj_props = text.find(\"beginObjectProperties\", group_start)\n            begin_group_idx = text.find(\"beginGroup\", begin_obj_props)\n            end_group_idx = self.find_matching_end_group(text, begin_group_idx)\n            end_obj_props = text.find(\"endObjectProperties\", end_group_idx)\n\n            if begin_obj_props == -1 or end_obj_props == -1 or begin_group_idx == -1:\n                snippet = text[pos : pos + 100].strip()\n                print(f\"Skipping malformed group at {pos}, snippet: {snippet}\")\n                pos += 1\n                continue\n\n            end_group_idx = self.find_matching_end_group(text, begin_group_idx)\n            if end_group_idx == -1:\n                print(f\"Could not find matching endGroup at {pos}\")\n                pos += 1\n                continue\n\n            # get rid of trailing endObjectProperties\n            extra_end_props = text.find(\"endObjectProperties\", end_group_idx)\n            group_end = (\n                extra_end_props + len(\"endObjectProperties\")\n                if (extra_end_props != -1 and extra_end_props &lt; text.find(\"object\", end_group_idx))\n                else end_group_idx + len(\"endGroup\")\n            )\n            group_header = (\n                text[begin_obj_props + len(\"beginObjectProperties\") : begin_group_idx]\n                + text[end_group_idx + len(\"endGroup\") : end_obj_props]\n            )\n            group_body = text[begin_group_idx + len(\"beginGroup\") : end_group_idx]\n\n            size_props = self.get_size_properties(group_header)\n            properties = self.get_object_properties(group_header)\n\n            group = EDMGroup(**size_props)\n            group.properties = properties\n\n            self.parse_objects_and_groups(group_body, group)\n            parent_group.add_object(group)\n            pos = group_end\n            continue\n\n        # Try matching a regular object\n        object_match = self.object_pattern.search(text, pos)\n        if object_match:\n            name = object_match.group(1).replace(\":\", \"\")  # remove colons from name (causes issues with PyDM)\n            object_text = object_match.group(2)\n            size_properties = self.get_size_properties(object_text)\n            properties = self.get_object_properties(object_text)\n\n            if name.lower() == \"activesymbolclass\" or name.lower() == \"anasymbolclass\":\n                obj = self.get_symbol_group(properties=properties, size_properties=size_properties)\n            else:\n                obj = EDMObject(name=name, properties=properties, **size_properties)\n            parent_group.add_object(obj)\n\n            pos = object_match.end()\n        else:\n            snippet = text[pos : pos + 100]\n            print(f\"Unrecognized text at pos {pos}: '{snippet}'\")\n            pos = text.find(\"\\n\", pos) if \"\\n\" in text[pos:] else len(text)\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.parse_screen_properties","title":"<code>parse_screen_properties()</code>","text":"<p>Get the screen properties from the .edl file and set the UI height and width</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>def parse_screen_properties(self) -&gt; None:\n    \"\"\"Get the screen properties from the .edl file and set the UI\n    height and width\n    \"\"\"\n    match = self.screen_prop_pattern.search(self.text)\n    if match:\n        screen_prop_text = match.group(1)\n        self.screen_properties_end = match.end()\n        size_properties = self.get_size_properties(screen_prop_text, strict=True)\n        other_properties = self.get_object_properties(screen_prop_text)\n        if \"bgColor\" in other_properties:\n            color_list_filepath = search_color_list()\n            color_list_dict = parse_colors_list(color_list_filepath)\n\n            edmColor = other_properties[\"bgColor\"]\n            other_properties[\"bgColor\"] = convert_color_property_to_qcolor(edmColor, color_data=color_list_dict)\n        self.ui.properties = other_properties\n\n        self.ui.height = size_properties[\"height\"]\n        self.ui.width = size_properties[\"width\"]\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.populate_symbol_pvs","title":"<code>populate_symbol_pvs(temp_group, properties, ranges)</code>","text":"<p>Given a group of symbol groups, add visPvs to each group based on their respective ranges. This will determine which group will appear based on the value of the pv connected to this activeSymbolClass.</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.populate_symbol_pvs--parameters","title":"Parameters","text":"<p>temp_group: EDMGroup     Group of groups whose objects will be modified properties: dict[str, bool | str | list[str]]     Object properties from the activesymbolclass ranges: list[list[str]]     The ranges taht determine the visPv ranges</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>def populate_symbol_pvs(\n    self, temp_group: EDMGroup, properties: dict[str, bool | str | list[str]], ranges: list[list[str]]\n) -&gt; None:\n    \"\"\"\n    Given a group of symbol groups, add visPvs to each group based on their\n    respective ranges. This will determine which group will appear based on\n    the value of the pv connected to this activeSymbolClass.\n\n    Parameters\n    ----------\n    temp_group: EDMGroup\n        Group of groups whose objects will be modified\n    properties: dict[str, bool | str | list[str]]\n        Object properties from the activesymbolclass\n    ranges: list[list[str]]\n        The ranges taht determine the visPv ranges\n    \"\"\"\n    num_states = int(properties[\"numStates\"])\n    if len(properties[\"controlPvs\"]) &gt; 1:\n        print(f\"This symbol object has more than one pV: {properties}\")\n    for i in range(\n        min(len(temp_group.objects), num_states)\n    ):  # TODO: Figure out what happens when numStates &lt; temp_group.objects\n        temp_group.objects[i].properties[\"symbolMin\"] = ranges[i][0]\n        temp_group.objects[i].properties[\"symbolMax\"] = ranges[i][1]\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.remove_extra_groups","title":"<code>remove_extra_groups(temp_group, ranges)</code>","text":"<p>Given a group of symbol groups, remove extra groups that are outside of the ranges given. (if there are more groups than ranges, the extra groups are removed) Also, if there are no ranges, only include the first group.</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.remove_extra_groups--parameters","title":"Parameters","text":"<p>temp_group: EDMGroup     The EDMGroup making up each symbol group whose objects will be modified ranges: list[list[str]]     A list encompassing the ranges (mainly the len(ranges) is important)</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>def remove_extra_groups(self, temp_group: EDMGroup, ranges: list[list[str]]) -&gt; None:\n    \"\"\"\n    Given a group of symbol groups, remove extra groups that are outside\n    of the ranges given. (if there are more groups than ranges, the extra\n    groups are removed) Also, if there are no ranges, only include the first\n    group.\n\n    Parameters\n    ----------\n    temp_group: EDMGroup\n        The EDMGroup making up each symbol group whose objects will be modified\n    ranges: list[list[str]]\n        A list encompassing the ranges (mainly the len(ranges) is important)\n    \"\"\"\n    if ranges is None:\n        temp_group.objects = temp_group.objects[:1]\n        return\n    while len(temp_group.objects) &gt; len(ranges):\n        print(f\"removed symbol group: {temp_group.objects.pop()}\")\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.remove_prepended_index","title":"<code>remove_prepended_index(lines)</code>  <code>staticmethod</code>","text":"<p>Removes the prepended indices from the given multi-line property value</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.remove_prepended_index--parameters","title":"Parameters","text":"<p>lines : list[str]     List of lines in a multi-line property value to remove the prepended indices from</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.remove_prepended_index--returns","title":"Returns","text":"<p>list[str]     Lines of the multi-line property value with the prepended indices removed</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>@staticmethod\ndef remove_prepended_index(lines: list[str]) -&gt; list[str]:\n    \"\"\"Removes the prepended indices from the given multi-line property value\n\n    Parameters\n    ----------\n    lines : list[str]\n        List of lines in a multi-line property value to remove the prepended indices from\n\n    Returns\n    -------\n    list[str]\n        Lines of the multi-line property value with the prepended indices removed\n    \"\"\"\n    indices = []\n    values = []\n\n    def check_sequential(indices):\n        \"\"\"Check if the list of indices is sequential starting from 0\"\"\"\n        return indices == list(range(len(indices)))\n\n    for line in lines:\n        try:\n            k, v = line.split(maxsplit=1)\n            indices.append(int(k))\n            values.append(v.strip(' \"'))\n        except ValueError:\n            return lines\n\n    if not check_sequential(indices):\n        return lines\n    return values\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.remove_symbol_groups","title":"<code>remove_symbol_groups(temp_group, ranges)</code>","text":"<p>Given a group of symbol groups, remove all groups whose ranges do not include 1. (This is done when no pvs are given and only the \"1\" group should be displayed)</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.remove_symbol_groups--parameters","title":"Parameters","text":"<p>temp_group: EDMGroup     The EDMGroup making up each symbol group whose objects will be modified ranges: list[list[str]]     A list encompassing the ranges (mainly the len(ranges) is important)</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>def remove_symbol_groups(self, temp_group: EDMGroup, ranges: list[list[str]]) -&gt; None:\n    \"\"\"\n    Given a group of symbol groups, remove all groups whose ranges do not include 1.\n    (This is done when no pvs are given and only the \"1\" group should be displayed)\n\n    Parameters\n    ----------\n    temp_group: EDMGroup\n        The EDMGroup making up each symbol group whose objects will be modified\n    ranges: list[list[str]]\n        A list encompassing the ranges (mainly the len(ranges) is important)\n    \"\"\"\n    for i in range(\n        len(ranges) - 1, -1, -1\n    ):  # going backwards so I do not need to change indices when deleting objects\n        min_range = ranges[i][0] or float(\"-inf\")\n        max_range = ranges[i][1] or float(\"inf\")\n        if float(min_range) &gt; 1 or float(max_range) &lt;= 1:\n            temp_group.objects.pop(i)\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.reorient_symbol_groups","title":"<code>reorient_symbol_groups(temp_group, orientation, size_properties)</code>","text":"<p>Given a group of symbol groups, change the orientation of each object within the symbol groups (rotateCW, rotateCCW, FlipV, FlipH) either flipping or rotating these objects about their respective symbol group.</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.reorient_symbol_groups--parameters","title":"Parameters","text":"<p>temp_group: EDMGroup     The EDMGroup making up each symbol group whose objects will be modified orientation : str     The orientation instruction to flip or rotate size_properties : dict[str, int]     The coordinate and size_properties of the activesymbolclass</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.reorient_symbol_groups--returns","title":"Returns","text":"<p>EDMGroup     A group representing a collection of ActiveSymbolclass groups</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>def reorient_symbol_groups(self, temp_group: EDMGroup, orientation: str, size_properties: dict[str, int]) -&gt; None:\n    \"\"\"\n    Given a group of symbol groups, change the orientation of each object\n    within the symbol groups (rotateCW, rotateCCW, FlipV, FlipH) either\n    flipping or rotating these objects about their respective symbol group.\n\n    Parameters\n    ----------\n    temp_group: EDMGroup\n        The EDMGroup making up each symbol group whose objects will be modified\n    orientation : str\n        The orientation instruction to flip or rotate\n    size_properties : dict[str, int]\n        The coordinate and size_properties of the activesymbolclass\n\n    Returns\n    ----------\n    EDMGroup\n        A group representing a collection of ActiveSymbolclass groups\n    \"\"\"\n    if orientation == \"FlipV\":\n        for sub_group in temp_group.objects:\n            for sub_object in sub_group.objects:\n                if sub_object.name.lower() == \"activearcclass\":\n                    sub_object.properties[\"startAngle\"] = str(-int(sub_object.properties[\"startAngle\"]))\n                    sub_object.properties[\"totalAngle\"] = str(-int(sub_object.properties[\"totalAngle\"]))\n                if sub_object.name.lower() == \"activelineclass\":\n                    for i in range(len(sub_object.properties[\"yPoints\"])):\n                        sub_object.properties[\"yPoints\"][i] = str(\n                            int(sub_object.height) - int(sub_object.properties[\"yPoints\"][i]) + int(sub_object.y)\n                        )\n                sub_object.y = int(sub_object.height) + int(sub_object.y) - int(sub_group.height)\n\n    if orientation == \"FlipH\":\n        for sub_group in temp_group.objects:\n            for sub_object in sub_group.objects:\n                if sub_object.name.lower() == \"activearcclass\":\n                    sub_object.properties[\"startAngle\"] = str(-int(sub_object.properties[\"startAngle\"]))\n                if sub_object.name.lower() == \"activelineclass\":\n                    for i in range(len(sub_object.properties[\"xPoints\"])):\n                        sub_object.properties[\"xPoints\"][i] = str(\n                            int(sub_object.width) - int(sub_object.properties[\"xPoints\"][i]) + int(sub_object.x)\n                        )\n                sub_object.x = int(size_properties[\"x\"]) - int(sub_object.x)\n    if orientation == \"rotateCW\":\n        for sub_group in temp_group.objects:\n            group_cx = sub_group.x + sub_group.width / 2\n            group_cy = sub_group.y + sub_group.height / 2\n\n            for sub_object in sub_group.objects:\n                if sub_object.name.lower() == \"activearcclass\":\n                    sub_object.properties[\"startAngle\"] = str((int(sub_object.properties[\"startAngle\"]) - 90) % 360)\n\n                obj_cx = sub_object.x + sub_object.width / 2\n                obj_cy = sub_object.y + sub_object.height / 2\n\n                rel_x = obj_cx - group_cx\n                rel_y = obj_cy - group_cy\n\n                new_rel_x = -rel_y\n                new_rel_y = rel_x\n\n                new_cx = group_cx + new_rel_x\n                new_cy = group_cy + new_rel_y\n\n                sub_object.x = int(new_cx - sub_object.height // 2)  # width/height swap\n                sub_object.y = int(new_cy - sub_object.width // 2)\n\n                sub_object.width, sub_object.height = sub_object.height, sub_object.width\n\n                if \"xPoints\" in sub_object.properties and \"yPoints\" in sub_object.properties:\n                    for i in range(len(sub_object.properties[\"xPoints\"])):\n                        px = int(sub_object.properties[\"xPoints\"][i])\n                        py = int(sub_object.properties[\"yPoints\"][i])\n\n                        rel_px = px - group_cx\n                        rel_py = py - group_cy\n\n                        new_rel_px = rel_py\n                        new_rel_py = -rel_px\n\n                        sub_object.properties[\"xPoints\"][i] = str(group_cx + new_rel_px)\n                        sub_object.properties[\"yPoints\"][i] = str(group_cy + new_rel_py)\n\n    if orientation == \"rotateCCW\":\n        for sub_group in temp_group.objects:\n            group_cx = sub_group.x + sub_group.width / 2\n            group_cy = sub_group.y + sub_group.height / 2\n\n            for sub_object in sub_group.objects:\n                if sub_object.name.lower() == \"activearcclass\":\n                    sub_object.properties[\"startAngle\"] = str((int(sub_object.properties[\"startAngle\"]) + 90) % 360)\n\n                obj_cx = sub_object.x + sub_object.width / 2\n                obj_cy = sub_object.y + sub_object.height / 2\n\n                rel_x = obj_cx - group_cx\n                rel_y = obj_cy - group_cy\n\n                new_rel_x = rel_y\n                new_rel_y = -rel_x\n\n                new_cx = group_cx + new_rel_x\n                new_cy = group_cy + new_rel_y\n\n                sub_object.x = int(new_cx - sub_object.height // 2)  # width/height swap\n                sub_object.y = int(new_cy - sub_object.width // 2)\n\n                sub_object.width, sub_object.height = sub_object.height, sub_object.width\n\n                if \"xPoints\" in sub_object.properties and \"yPoints\" in sub_object.properties:\n                    for i in range(len(sub_object.properties[\"xPoints\"])):\n                        px = int(sub_object.properties[\"xPoints\"][i])\n                        py = int(sub_object.properties[\"yPoints\"][i])\n\n                        rel_px = px - group_cx\n                        rel_py = py - group_cy\n\n                        new_rel_px = rel_py\n                        new_rel_py = -rel_px\n\n                        sub_object.properties[\"xPoints\"][i] = str(group_cx + new_rel_px)\n                        sub_object.properties[\"yPoints\"][i] = str(group_cy + new_rel_py)\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.resize_symbol_groups","title":"<code>resize_symbol_groups(temp_group, size_properties)</code>","text":"<p>Given a group of symbol groups, modify the coordinates of each object within the symbol groupsto be in relation to the coordinates of the new file rather than from the embedded file.</p>"},{"location":"reference/edm/parser/#edm.parser.EDMFileParser.resize_symbol_groups--parameters","title":"Parameters","text":"<p>temp_group: EDMGroup     The EDMGroup making up each symbol group whose objects will be modified size_properties : dict[str, int]     The coordinate and size_properties of the activesymbolclass</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>def resize_symbol_groups(self, temp_group: EDMGroup, size_properties: dict[str, int]) -&gt; None:\n    \"\"\"\n    Given a group of symbol groups, modify the coordinates of each\n    object within the symbol groupsto be in relation to the coordinates\n    of the new file rather than from the embedded file.\n\n    Parameters\n    ----------\n    temp_group: EDMGroup\n        The EDMGroup making up each symbol group whose objects will be modified\n    size_properties : dict[str, int]\n        The coordinate and size_properties of the activesymbolclass\n    \"\"\"\n    for sub_group in temp_group.objects:\n        for sub_object in sub_group.objects:\n            sub_object.x = sub_object.x - sub_group.x + size_properties[\"x\"]\n            sub_object.y = sub_object.y - sub_group.y + size_properties[\"y\"]\n        sub_group.x = size_properties[\"x\"]\n        sub_group.y = size_properties[\n            \"y\"\n        ]  # The group resizing is needed to reorient symbol groups for rotations later\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMGroup","title":"<code>EDMGroup</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EDMObjectBase</code></p> <p>EDM Group class represents a group in .edl files</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>@dataclass\nclass EDMGroup(EDMObjectBase):\n    \"\"\"EDM Group class represents a group in .edl files\"\"\"\n\n    objects: list[EDMObjectBase] = field(default_factory=list)\n    properties: dict = field(default_factory=dict)\n\n    def add_object(self, obj):\n        self.objects.append(obj)\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMObject","title":"<code>EDMObject</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EDMObjectBase</code></p> <p>EDM Object class represents an object in .edl files</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>@dataclass\nclass EDMObject(EDMObjectBase):\n    \"\"\"EDM Object class represents an object in .edl files\"\"\"\n\n    name: str = \"\"\n    properties: dict = field(default_factory=dict)\n</code></pre>"},{"location":"reference/edm/parser/#edm.parser.EDMObjectBase","title":"<code>EDMObjectBase</code>  <code>dataclass</code>","text":"<p>EDM Abstract Object class represents an abstract object in .edl files</p> Source code in <code>pydmconverter/edm/parser.py</code> <pre><code>@dataclass\nclass EDMObjectBase:\n    \"\"\"EDM Abstract Object class represents an abstract object in .edl files\"\"\"\n\n    x: int = 0\n    y: int = 0\n    width: int = 0\n    height: int = 0\n</code></pre>"},{"location":"reference/edm/parser_helpers/","title":"Parser Helpers","text":""},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.apply_rewrite_rule","title":"<code>apply_rewrite_rule(rewrite_rule, arg_list)</code>","text":"<p>Apply a rewrite rule to an argument list. Rewrite rules often look like '$(A),$(A).SEVR', which can expand a single argument into multiple arguments by replacing placeholders.</p> For example <p>rewrite_rule = '$(A),$(A).SEVR' arg_list = ['myPV']</p> <p>=&gt; new_args = ['myPV', 'myPV.SEVR']</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.apply_rewrite_rule--parameters","title":"Parameters","text":"<p>rewrite_rule : str     The rewrite rule, without the leading '@' (e.g. '$(A),$(A).SEVR'). arg_list : List[str]     The list of arguments to which we apply the rule.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.apply_rewrite_rule--returns","title":"Returns","text":"<p>List[str]     A new list of arguments produced by the rewrite rule.</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def apply_rewrite_rule(rewrite_rule: str, arg_list: List[str]) -&gt; List[str]:\n    \"\"\"\n    Apply a rewrite rule to an argument list. Rewrite rules often look like\n    '$(A),$(A).SEVR', which can expand a single argument into multiple arguments\n    by replacing placeholders.\n\n    For example:\n        rewrite_rule = '$(A),$(A).SEVR'\n        arg_list = ['myPV']\n      =&gt; new_args = ['myPV', 'myPV.SEVR']\n\n    Parameters\n    ----------\n    rewrite_rule : str\n        The rewrite rule, without the leading '@' (e.g. '$(A),$(A).SEVR').\n    arg_list : List[str]\n        The list of arguments to which we apply the rule.\n\n    Returns\n    -------\n    List[str]\n        A new list of arguments produced by the rewrite rule.\n    \"\"\"\n    placeholders = \"ABCDEFGHIJKL\"\n\n    arg_map = {}\n    for i, arg_val in enumerate(arg_list):\n        if i &lt; len(placeholders):\n            arg_map[placeholders[i]] = arg_val\n\n    new_args = []\n\n    for part in rewrite_rule.split(\",\"):\n        result = part\n\n        for letter, val in arg_map.items():\n            result = result.replace(\"$(\" + letter + \")\", val)\n        new_args.append(result)\n\n    return new_args\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.clean_escape_characters","title":"<code>clean_escape_characters(expr)</code>","text":"<p>Remove extra ' characters from CALC/LOC expressions.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.clean_escape_characters--parameters","title":"Parameters","text":"<p>expression : str     The expression to be cleaned.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.clean_escape_characters--returns","title":"Returns","text":"<p>str     The new expression with \\s removed.</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def clean_escape_characters(expr: str) -&gt; str:\n    \"\"\"\n    Remove extra \\' characters from CALC/LOC expressions.\n\n    Parameters\n    ----------\n    expression : str\n        The expression to be cleaned.\n\n    Returns\n    -------\n    str\n        The new expression with \\\\s removed.\n    \"\"\"\n    expr = expr.lstrip(\"\\\\\")\n    expr = expr.replace(r\"\\{\", \"{\").replace(r\"\\}\", \"}\")\n    # TODO: If more \\ removal cases are needed, add them here\n\n    return expr\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.convert_color_property_to_qcolor","title":"<code>convert_color_property_to_qcolor(fillColor, color_data)</code>","text":"<p>Convert the EDM 'fillColor', 'bgColor', 'fgColor' property into a tuple representing RGBA values.</p> <p>Returns:</p> Type Description <code>Optional[Tuple[int, int, int, int]]</code> <p>Optional[Tuple[int, int, int, int]]: A tuple (red, green, blue, alpha) or None.</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def convert_color_property_to_qcolor(fillColor: str, color_data: Dict[str, Any]) -&gt; Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Convert the EDM 'fillColor', 'bgColor', 'fgColor' property into a tuple representing RGBA values.\n\n    Returns:\n        Optional[Tuple[int, int, int, int]]: A tuple (red, green, blue, alpha) or None.\n    \"\"\"\n    if fillColor.startswith(\"rgb\"):\n        color_info = get_color_by_rgb(fillColor)\n    else:\n        color_info = get_color_by_index(color_data, fillColor)\n    if not color_info:\n        logger.warning(f\"Could not find a color for fillColor '{fillColor}'. Using default gray.\")\n        return (128, 128, 128, 255)\n\n    rgb = color_info.get(\"rgb\")\n    if not rgb or len(rgb) &lt; 3:\n        logger.warning(f\"Invalid RGB data for color '{fillColor}': {rgb}\")\n        return (128, 128, 128, 255)\n    red, green, blue = rgb[:3]\n    alpha = 255\n\n    max_val = color_data.get(\"max\", 256)\n    rgbMax = max(rgb)\n    if rgbMax &gt; 256:\n        # Scale from 0-65535 to 0-255\n        red = int(red * 255 / (max_val - 1))\n        green = int(green * 255 / (max_val - 1))\n        blue = int(blue * 255 / (max_val - 1))\n\n    # result = (red, green, blue, alpha)\n    result = RGBA(r=red, g=green, b=blue, a=alpha)\n    logger.info(f\"Converted {fillColor} to color: {result}\")\n\n    return result\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.get_color_by_index","title":"<code>get_color_by_index(color_data, index)</code>","text":"<p>Retrieve the color definition from color_data using an index string like 'index 3'.</p> <p>Parameters:</p> Name Type Description Default <code>color_data</code> <code>Dict[str, Any]</code> <p>The parsed colors.list data.</p> required <code>index</code> <code>str</code> <p>The color index string, e.g., 'index 3'.</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict[str, Any]]: The corresponding color dictionary (expected to have an 'rgb' key)                       or None if not found.</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def get_color_by_index(color_data: Dict[str, Any], index: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve the color definition from color_data using an index string like 'index 3'.\n\n    Args:\n        color_data (Dict[str, Any]): The parsed colors.list data.\n        index (str): The color index string, e.g., 'index 3'.\n\n    Returns:\n        Optional[Dict[str, Any]]: The corresponding color dictionary (expected to have an 'rgb' key)\n                                  or None if not found.\n    \"\"\"\n    match = re.match(r\"index\\s+(\\d+)\", index)\n    if match:\n        idx = int(match.group(1))\n        color = color_data.get(\"static\", {}).get(idx)\n        if not color:\n            logger.warning(f\"Color index {idx} not found in colors.list.\")\n        return color\n    logger.warning(f\"Invalid color index format: '{index}'.\")\n    return None\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.get_color_by_rgb","title":"<code>get_color_by_rgb(colorStr)</code>","text":"<p>Retrieve the color definition from color_data using an rgb string like 'rgb 0 0 0'.</p> <p>Parameters:</p> Name Type Description Default <code>colorStr</code> <code>str</code> <p>The color index string, e.g., 'rgb 0 0 0'.</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict[str, Any]]: The corresponding color dictionary (expected to have an 'rgb' key)                       or None if not found.</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def get_color_by_rgb(colorStr: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve the color definition from color_data using an rgb string like 'rgb 0 0 0'.\n\n    Args:\n        colorStr (str): The color index string, e.g., 'rgb 0 0 0'.\n\n    Returns:\n        Optional[Dict[str, Any]]: The corresponding color dictionary (expected to have an 'rgb' key)\n                                  or None if not found.\n    \"\"\"\n    color_list: list[str] = colorStr.split(\" \")\n    output_dict = {}\n    output_dict[\"rgb\"] = [int(s) for s in color_list[1:]]  # get ints from list excluding 'rgb' at index 0\n\n    return output_dict\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.loc_conversion","title":"<code>loc_conversion(edm_string)</code>","text":"<p>Convert an EDM local PV string to a PyDM local variable string, mapping types to supported PyDM types.</p> <p>Supported PyDM types: - int - float - str - array (numpy.ndarray)</p> <p>Enum ('e') is mapped to int for simplicity in this conversion.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.loc_conversion--parameters","title":"Parameters","text":"<p>edm_string : str     EDM local PV string to be converted. Expected format is:     \"LOC\\name=type:value\" (with optional scope modifiers and ignoring special functions).</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.loc_conversion--returns","title":"Returns","text":"<p>pydm_string : str     Corresponding PyDM string in the format:     \"loc://?type=&amp;init=\"."},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.loc_conversion--raises","title":"Raises","text":"<p>ValueError     If the EDM string does not start with 'LOC\\' or if it lacks the proper format.</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def loc_conversion(edm_string: str) -&gt; str:\n    \"\"\"\n    Convert an EDM local PV string to a PyDM local variable string, mapping types to supported PyDM types.\n\n    Supported PyDM types:\n    - int\n    - float\n    - str\n    - array (numpy.ndarray)\n\n    Enum ('e') is mapped to int for simplicity in this conversion.\n\n    Parameters\n    ----------\n    edm_string : str\n        EDM local PV string to be converted. Expected format is:\n        \"LOC\\\\name=type:value\" (with optional scope modifiers and ignoring special functions).\n\n    Returns\n    -------\n    pydm_string : str\n        Corresponding PyDM string in the format:\n        \"loc://&lt;name&gt;?type=&lt;mapped_type&gt;&amp;init=&lt;value&gt;\".\n\n    Raises\n    ------\n    ValueError\n        If the EDM string does not start with 'LOC\\\\' or if it lacks the proper format.\n    \"\"\"\n    prefix = \"LOC\\\\\"\n    if not edm_string.startswith(prefix):\n        raise ValueError(\"Provided string does not start with 'LOC\\\\'\")\n\n    content = edm_string[len(prefix) :]\n\n    # if \"$(\" in content and \")\" in content:\n    #    content = content.split(\")\", 1)[-1]\n\n    type_mapping = {\n        \"d\": \"float\",\n        \"i\": \"int\",\n        \"s\": \"str\",\n        \"e\": \"int\",  # mapping enum to int\n    }\n\n    try:\n        name, type_and_value = content.split(\"=\", 1)\n        name = name.lstrip(\"\\\\\")\n        type_and_value = type_and_value.lstrip(\"=\")  # for edgecases with ==\n    except ValueError:\n        name = content.lstrip(\"\\\\\")\n        return f\"loc://{name}\"\n        # raise ValueError(\"Invalid EDM format: Missing '=' separator\")\n\n    try:\n        type_char, value = type_and_value.split(\":\", 1)\n    except ValueError:\n        try:\n            if (\n                len(type_and_value) &gt; 1 and type_and_value[0] in type_mapping and type_and_value[1] == \",\"\n            ):  # ex. type_and_value=i,10\n                value = type_and_value[2:]\n                type_char = type_and_value[0]\n            elif type_and_value in type_mapping:  # value is one of the mapped characters\n                value = \"\"\n                type_char = type_and_value\n            else:\n                int(type_and_value)  # testing if this is a proper int\n                value = type_and_value\n                type_char = \"i\"\n            \"\"\"if type_and_value.startswith(\"d,\"):\n                value = type_and_value[2:]\n                float(value)\n                type_char = \"d\"\n            elif type_and_value.startswith(\"i,\"):\n                value = type_and_value[2:]\n                int(value)\n                type_char = \"i\"\n            elif type_and_value == \"s,\":\n                value = type_and_value[2:]\n                type_char = \"s\"\n            \"\"\"\n        except ValueError:\n            try:\n                float(type_and_value)\n                value = type_and_value\n                type_char = \"d\"\n            except ValueError:\n                # print(\"Invalid EDM format: Missing ':' separator and not an integer (enter c to continue)\")\n                print(f\"name: {name}\")\n                print(f\"value: {type_and_value}\")\n                raise ValueError(\"Invalid EDM format: Missing ':' separator and not an integer\")\n\n    edm_type = type_char.lower()\n    if edm_type.isdigit():\n        value = edm_type\n        edm_type = \"i\"\n    pydm_type = type_mapping.get(edm_type)\n    if pydm_type is None:\n        # logger.warning(f\"Unsupported type character: {type_char}\")\n        # return f\"No loc here\"\n        if edm_type and len(edm_type) &gt; 1:\n            edm_type = \"s\"\n            value = type_and_value\n            print(type_and_value)\n            breakpoint()\n        else:\n            raise ValueError(f\"Unsupported type character: {type_char}\")\n\n    if value.strip().upper() == \"RAND()\":\n        raise NotImplementedError(\"Special function RAND() is not supported yet.\")\n\n        # a calc pv would have to be returned instead of a local pv\n        # pydm_string = f\"calc://{name}?var=loc://temp&amp;expr=np.random.rand()\"\n        # an invisible widget with the definiation of a temp local pv would have to be added to the screen as well\n        # temp_pv_string = \"loc://temp?type=float&amp;init=0.0\"\n\n    elif edm_type == \"e\":\n        value_arr: List[str] = value.split(\",\")\n        init: str = value_arr[0]\n        enum_string: List[str] = value_arr[1:]\n        pydm_string = f\"loc://{name}?type={pydm_type}&amp;init={init}&amp;enum_string={enum_string}\"\n    else:\n        pydm_string = f\"loc://{name}?type={pydm_type}&amp;init={value}\"\n\n    return pydm_string\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.parse_calc_list","title":"<code>parse_calc_list(calc_list_path)</code>","text":"<p>Parse an EPICS-style calc.list file and return a dictionary mapping calculation names to a tuple of (rewrite_rule, expression).</p> The file format typically looks like <pre><code>CALC1 ...\n# ...\n&lt;calc_name&gt;\n[@rewrite_rule]\n&lt;expression&gt;\n# ...\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.parse_calc_list--parameters","title":"Parameters","text":"<p>calc_list_path : str     Path to the calc.list file.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.parse_calc_list--returns","title":"Returns","text":"<p>Dict[str, Tuple[Optional[str], Optional[str]]]     A dictionary with keys as calculation names (e.g. 'sum', 'diff') and     values as a 2-tuple (rewrite_rule, expression). Both are optional:     rewrite_rule may be None if not present, and expression may also be None     if the file has incomplete entries.</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def parse_calc_list(calc_list_path: str) -&gt; Dict[str, Tuple[Optional[str], Optional[str]]]:\n    \"\"\"\n    Parse an EPICS-style calc.list file and return a dictionary mapping\n    calculation names to a tuple of (rewrite_rule, expression).\n\n    The file format typically looks like:\n        ```\n        CALC1 ...\n        # ...\n        &lt;calc_name&gt;\n        [@rewrite_rule]\n        &lt;expression&gt;\n        # ...\n        ```\n    Parameters\n    ----------\n    calc_list_path : str\n        Path to the calc.list file.\n\n    Returns\n    -------\n    Dict[str, Tuple[Optional[str], Optional[str]]]\n        A dictionary with keys as calculation names (e.g. 'sum', 'diff') and\n        values as a 2-tuple (rewrite_rule, expression). Both are optional:\n        rewrite_rule may be None if not present, and expression may also be None\n        if the file has incomplete entries.\n    \"\"\"\n    calc_dict: Dict[str, Tuple[Optional[str], Optional[str]]] = {}\n\n    if calc_list_path is None or not os.path.isfile(calc_list_path):\n        return calc_dict\n\n    with open(calc_list_path, \"r\") as f:\n        lines = [line.strip() for line in f]\n\n    i = 1  # first line of file should be ignored\n    while i &lt; len(lines):\n        line = lines[i]\n\n        if not line or line.startswith(\"#\"):\n            i += 1\n            continue\n\n        calc_name = line\n        i += 1\n\n        rewrite_rule: Optional[str] = None\n        expression: Optional[str] = None\n\n        while i &lt; len(lines) and (not lines[i] or lines[i].startswith(\"#\")):\n            i += 1\n\n        if i &lt; len(lines) and lines[i].startswith(\"@\"):\n            rewrite_rule = lines[i][1:].strip()\n            i += 1\n\n        while i &lt; len(lines) and (not lines[i] or lines[i].startswith(\"#\")):\n            i += 1\n\n        if i &lt; len(lines):\n            expression = lines[i]\n            i += 1\n\n        calc_dict[calc_name] = (rewrite_rule, expression)\n\n    return calc_dict\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.parse_calc_pv","title":"<code>parse_calc_pv(edm_pv)</code>","text":"<p>Parse an EDM-style CALC PV reference and extract the calculation name (or inline expression), list of arguments, and whether it's an inline expression (curly braces).</p> EDM CALC PV examples <ul> <li>'CALC\\sum(pv1, pv2)'</li> <li>'CALC\\{A+B}(pv1, pv2)'</li> <li>'CALC\\{(A)}($(P)$(R)Acquire)'</li> </ul>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.parse_calc_pv--parameters","title":"Parameters","text":"<p>edm_pv : str     The EDM-style CALC PV string to parse. For example, 'CALC\\sum(pv1, pv2)'.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.parse_calc_pv--returns","title":"Returns","text":"<p>calc_name_or_expr : str     The calculation name (e.g. 'sum') or inline expression (e.g. 'A+B'). arg_list : List[str]     The list of arguments, e.g. ['pv1', 'pv2']. is_inline_expr : bool     True if the EDM PV used inline curly brace syntax (e.g. '{A+B}'),     False otherwise.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.parse_calc_pv--raises","title":"Raises","text":"<p>ValueError     If the given edm_pv string doesn't match the expected CALC syntax.</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def parse_calc_pv(edm_pv: str) -&gt; Tuple[str, List[str], bool]:\n    \"\"\"\n    Parse an EDM-style CALC PV reference and extract the calculation name (or inline\n    expression), list of arguments, and whether it's an inline expression (curly braces).\n\n    EDM CALC PV examples:\n      - 'CALC\\\\sum(pv1, pv2)'\n      - 'CALC\\\\\\\\{A+B\\\\}(pv1, pv2)'\n      - 'CALC\\\\\\\\{(A)\\\\}($(P)$(R)Acquire)'\n\n    Parameters\n    ----------\n    edm_pv : str\n        The EDM-style CALC PV string to parse. For example, 'CALC\\\\sum(pv1, pv2)'.\n\n    Returns\n    -------\n    calc_name_or_expr : str\n        The calculation name (e.g. 'sum') or inline expression (e.g. 'A+B').\n    arg_list : List[str]\n        The list of arguments, e.g. ['pv1', 'pv2'].\n    is_inline_expr : bool\n        True if the EDM PV used inline curly brace syntax (e.g. '{A+B}'),\n        False otherwise.\n\n    Raises\n    ------\n    ValueError\n        If the given edm_pv string doesn't match the expected CALC syntax.\n    \"\"\"\n\n    expr_part, args_part = get_calc_groups(edm_pv)\n    name_or_expr = clean_escape_characters(expr_part).strip()\n    arg_string = clean_escape_characters(args_part)\n\n    arg_list: List[str] = []\n    if arg_string:\n        arg_list = [arg.strip() for arg in arg_string.split(\",\")]\n        for i in range(len(arg_list)):\n            if arg_list[i].startswith(\"LOC\\\\\"):\n                arg_list[i] = loc_conversion(arg_list[i])\n\n    is_inline_expr = False\n    if name_or_expr.startswith(\"{\") and name_or_expr.endswith(\"}\"):\n        is_inline_expr = True\n        name_or_expr = name_or_expr[1:-1]\n    return name_or_expr, arg_list, is_inline_expr\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.parse_colors_list","title":"<code>parse_colors_list(filepath)</code>","text":"<p>Parse an EDM <code>colors.list</code> file into a structured Python dictionary.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.parse_colors_list--parameters","title":"Parameters","text":"<p>filepath : str     Path to the <code>colors.list</code> file.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.parse_colors_list--returns","title":"Returns","text":"<p>Dict[str, Any]     A dictionary representing the parsed content of the <code>colors.list</code> file.</p> <pre><code>Keys\n----\nversion : Dict[str, int]\n    Dictionary containing {\"major\", \"minor\", \"release\"}.\nblinkms : int or None\n    The blink period in milliseconds.\ncolumns : int or None\n    Number of columns in the color palette.\nmax : int or None\n    The maximum RGB component value + 1 (e.g. 256 or 0x10000).\nalias : Dict[str, str]\n    Maps an alias name to a (static or rule-based) color name.\nstatic : Dict[int, Dict[str, Union[str, List[int]]]]\n    Static color definitions keyed by their numeric index.\n    Each value is a dictionary containing:\n      - \"name\": str\n      - \"rgb\": List[int]  (3 values) or 6 values if blinking\nrules : Dict[int, Dict[str, Any]]\n    Rule definitions keyed by their numeric index.\n    Each value is a dictionary containing:\n      - \"name\": str\n      - \"conditions\": List[Dict[str, str]]\n        Each condition has:\n          - \"condition\": str  (e.g. \"&gt;0 &amp;&amp; &lt;10\" or \"default\")\n          - \"color\": str\nmenumap : List[str]\n    List of color names as displayed in the color name menu.\nalarm : Dict[str, str]\n    Alarm color configuration. Keys are alarm states, values are color names.\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.parse_colors_list--notes","title":"Notes","text":"<ul> <li>The first non-comment, non-empty line must be the version line: e.g. \"4 0 0\".</li> <li>The parser assumes a well-formed file. If your file structure differs, you may need to   handle additional edge cases (e.g. malformed lines, trailing braces, etc.).</li> <li>A \u201cblinking\u201d static color has six numeric components for its two RGB states.</li> <li>A rule line has the form: rule   { ... }. <li>The menumap and alarm blocks must each be enclosed in braces.</li> <li>The alias lines have the form: alias  . Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def parse_colors_list(filepath: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Parse an EDM `colors.list` file into a structured Python dictionary.\n\n    Parameters\n    ----------\n    filepath : str\n        Path to the `colors.list` file.\n\n    Returns\n    -------\n    Dict[str, Any]\n        A dictionary representing the parsed content of the `colors.list` file.\n\n        Keys\n        ----\n        version : Dict[str, int]\n            Dictionary containing {\"major\", \"minor\", \"release\"}.\n        blinkms : int or None\n            The blink period in milliseconds.\n        columns : int or None\n            Number of columns in the color palette.\n        max : int or None\n            The maximum RGB component value + 1 (e.g. 256 or 0x10000).\n        alias : Dict[str, str]\n            Maps an alias name to a (static or rule-based) color name.\n        static : Dict[int, Dict[str, Union[str, List[int]]]]\n            Static color definitions keyed by their numeric index.\n            Each value is a dictionary containing:\n              - \"name\": str\n              - \"rgb\": List[int]  (3 values) or 6 values if blinking\n        rules : Dict[int, Dict[str, Any]]\n            Rule definitions keyed by their numeric index.\n            Each value is a dictionary containing:\n              - \"name\": str\n              - \"conditions\": List[Dict[str, str]]\n                Each condition has:\n                  - \"condition\": str  (e.g. \"&gt;0 &amp;&amp; &lt;10\" or \"default\")\n                  - \"color\": str\n        menumap : List[str]\n            List of color names as displayed in the color name menu.\n        alarm : Dict[str, str]\n            Alarm color configuration. Keys are alarm states, values are color names.\n\n    Notes\n    -----\n    - The first non-comment, non-empty line must be the version line: e.g. \"4 0 0\".\n    - The parser assumes a well-formed file. If your file structure differs, you may need to\n      handle additional edge cases (e.g. malformed lines, trailing braces, etc.).\n    - A \u201cblinking\u201d static color has six numeric components for its two RGB states.\n    - A rule line has the form: rule &lt;index&gt; &lt;name&gt; { ... }.\n    - The menumap and alarm blocks must each be enclosed in braces.\n    - The alias lines have the form: alias &lt;alias_name&gt; &lt;color_name&gt;.\n    \"\"\"\n\n    re_comment = re.compile(r\"^\\s*#\")\n    re_setting = re.compile(r\"^\\s*([a-zA-Z0-9_]+)\\s*=\\s*([^\\s]+)\")\n    re_alias = re.compile(r\"^\\s*alias\\s+(\\S+)\\s+(.+)$\")\n\n    # Regex for static color definitions:\n    # e.g. static 25 Controller { 0 0 65535 }\n    # or   static 26 \"blinking red\" { 65535 0 0 41120 0 0 }\n    # Captures: index, name, content inside braces\n    re_static = re.compile(r\"^\\s*static\\s+(\\d+)\\s+\\\"?([^\\\"{]+)\\\"?\\s*\\{\\s*([^}]*)\\}\")\n\n    # Regex for rule definitions:\n    # e.g. rule 100 exampleRule {\n    #        =100 || =200 : strange\n    #        default      : green\n    #      }\n    re_rule_header = re.compile(r\"^\\s*rule\\s+(\\d+)\\s+(.*?){?\\s*$\")\n\n    parsed_data: Dict[str, Any] = {\n        \"version\": {},\n        \"blinkms\": None,\n        \"columns\": None,\n        \"max\": None,\n        \"alias\": {},\n        \"static\": {},\n        \"rules\": {},\n        \"menumap\": [],\n        \"alarm\": {},\n    }\n\n    if filepath is None:\n        return parsed_data\n\n    with open(filepath, \"r\", encoding=\"utf-8\") as f:\n        lines = f.readlines()\n\n    def skip_blanks_and_comments(idx: int) -&gt; int:\n        while idx &lt; len(lines):\n            line_stripped = lines[idx].strip()\n            if not line_stripped or re_comment.match(line_stripped):\n                idx += 1\n            else:\n                break\n        return idx\n\n    idx = 0\n    idx = skip_blanks_and_comments(idx)\n    if idx &gt;= len(lines):\n        raise ValueError(\"File is empty or missing version line.\")\n\n    first_line = lines[idx].strip()\n    idx += 1\n\n    version_parts = first_line.split()\n    if len(version_parts) != 3:\n        raise ValueError(\"Version line must have exactly three integers: e.g. '4 0 0'.\")\n\n    parsed_data[\"version\"] = {\n        \"major\": int(version_parts[0]),\n        \"minor\": int(version_parts[1]),\n        \"release\": int(version_parts[2]),\n    }\n\n    while idx &lt; len(lines):\n        line = lines[idx].strip()\n        idx += 1\n\n        if not line or re_comment.match(line):\n            continue\n\n        match_setting = re_setting.match(line)\n        if match_setting:\n            key, value_str = match_setting.groups()\n            try:\n                if value_str.startswith(\"0x\"):\n                    value_int = int(value_str, 16)\n                else:\n                    value_int = int(value_str)\n                parsed_data[key] = value_int\n            except ValueError:\n                parsed_data[key] = value_str\n            continue\n\n        match_alias = re_alias.match(line)\n        if match_alias:\n            alias_name, color_name = match_alias.groups()\n            color_name = color_name.strip().strip('\"')\n            parsed_data[\"alias\"][alias_name] = color_name\n            continue\n\n        match_static = re_static.match(line)\n        if match_static:\n            idx_str, color_name, rgb_str = match_static.groups()\n            color_index = int(idx_str)\n            color_name = color_name.strip()\n            rgb_vals_str = rgb_str.replace(\",\", \" \")\n            rgb_vals = rgb_vals_str.split()\n\n            def convert_val(v: str) -&gt; int:\n                v = v.strip()\n                return int(v, 16) if v.startswith(\"0x\") else int(v)\n\n            rgb_nums = [convert_val(v) for v in rgb_vals]\n\n            parsed_data[\"static\"][color_index] = {\n                \"name\": color_name,\n                \"rgb\": rgb_nums,\n            }\n            continue\n\n        match_rule = re_rule_header.match(line)\n        if match_rule:\n            rule_index_str, rule_name_part = match_rule.groups()\n            rule_index = int(rule_index_str)\n            rule_name_part = rule_name_part.strip()\n\n            if rule_name_part.endswith(\"{\"):\n                rule_name_part = rule_name_part[:-1].strip()\n\n            conditions = []\n            if \"{\" not in line:\n                idx = skip_blanks_and_comments(idx)\n\n            while idx &lt; len(lines):\n                inner_line = lines[idx].strip()\n                idx += 1\n                if not inner_line or re_comment.match(inner_line):\n                    continue\n                if inner_line.startswith(\"}\"):\n                    break\n\n                parts = inner_line.split(\":\")\n                if len(parts) == 2:\n                    condition_str = parts[0].strip()\n                    color_str = parts[1].strip().strip('\"')\n                    conditions.append(\n                        {\n                            \"condition\": condition_str,\n                            \"color\": color_str,\n                        }\n                    )\n\n            parsed_data[\"rules\"][rule_index] = {\"name\": rule_name_part, \"conditions\": conditions}\n            continue\n\n        if line.startswith(\"menumap\"):\n            idx = skip_blanks_and_comments(idx)\n            while idx &lt; len(lines):\n                inner_line = lines[idx].strip()\n                idx += 1\n                if inner_line.startswith(\"}\"):\n                    break\n                if not inner_line or re_comment.match(inner_line):\n                    continue\n                color_name = inner_line.strip().strip('\"')\n                parsed_data[\"menumap\"].append(color_name)\n            continue\n\n        if line.startswith(\"alarm\"):\n            idx = skip_blanks_and_comments(idx)\n            while idx &lt; len(lines):\n                inner_line = lines[idx].strip()\n                idx += 1\n                if inner_line.startswith(\"}\"):\n                    break\n                if not inner_line or re_comment.match(inner_line):\n                    continue\n                alarm_parts = inner_line.split(\":\")\n                if len(alarm_parts) == 2:\n                    alarm_state = alarm_parts[0].strip()\n                    color_name = alarm_parts[1].strip().strip('\"')\n                    parsed_data[\"alarm\"][alarm_state] = color_name\n            continue\n\n        logging.warning(f\"Unrecognized line in colors.list: '{line}'\")\n\n    for possible_key in (\"blinkms\", \"columns\", \"max\"):\n        if possible_key in parsed_data:\n            parsed_data[possible_key] = parsed_data[possible_key]\n        else:\n            parsed_data[possible_key] = None\n\n    return parsed_data\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.reformat_calc_expression","title":"<code>reformat_calc_expression(exp)</code>","text":"<p>Convert EPICS calc expression operators to Python equivalents.</p> <p>EPICS calc uses different operators than Python: - ^ for exponentiation (Python uses **) - # for not equal (Python uses !=)</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def reformat_calc_expression(exp):\n    \"\"\"\n    Convert EPICS calc expression operators to Python equivalents.\n\n    EPICS calc uses different operators than Python:\n    - ^ for exponentiation (Python uses **)\n    - # for not equal (Python uses !=)\n    \"\"\"\n    # Exponentiation: ^ -&gt; **\n    exp = exp.replace(\"^\", \"**\")\n\n    # Not equal: # -&gt; !=\n    exp = exp.replace(\"#\", \"!=\")\n\n    return exp\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.replace_calc_and_loc_in_edm_content","title":"<code>replace_calc_and_loc_in_edm_content(edm_content, filepath)</code>","text":"<p>Replace both CALC...(...) and LOC...=... references in the EDM file content with PyDM equivalents. The first time each unique reference appears, the replacement is the full PyDM string; subsequent appearances use the short form.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.replace_calc_and_loc_in_edm_content--parameters","title":"Parameters","text":"<p>edm_content : str     The full text of the EDM file, as a single string. filepath : str     path of the given edm file</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.replace_calc_and_loc_in_edm_content--returns","title":"Returns","text":"<p>new_content : str     The EDM content after all CALC and LOC references have been replaced. encountered_calcs : Dict[str, Dict[str, str]]     A dictionary of all encountered CALC references, mapping the original     EDM reference to {\"full\": ..., \"short\": ...}. encountered_locs : Dict[str, Dict[str, str]]     A dictionary of all encountered LOC references, similarly mapping each     unique original LOC reference to \"full\" and \"short\" addresses.</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def replace_calc_and_loc_in_edm_content(\n    edm_content: str, filepath: str\n) -&gt; Tuple[str, Dict[str, Dict[str, str]], Dict[str, Dict[str, str]]]:\n    \"\"\"\n    Replace both CALC\\\\...(...) and LOC\\\\...=... references in the EDM file content\n    with PyDM equivalents. The first time each unique reference appears, the\n    replacement is the full PyDM string; subsequent appearances use the short form.\n\n    Parameters\n    ----------\n    edm_content : str\n        The full text of the EDM file, as a single string.\n    filepath : str\n        path of the given edm file\n\n    Returns\n    -------\n    new_content : str\n        The EDM content after all CALC and LOC references have been replaced.\n    encountered_calcs : Dict[str, Dict[str, str]]\n        A dictionary of all encountered CALC references, mapping the original\n        EDM reference to {\"full\": ..., \"short\": ...}.\n    encountered_locs : Dict[str, Dict[str, str]]\n        A dictionary of all encountered LOC references, similarly mapping each\n        unique original LOC reference to \"full\" and \"short\" addresses.\n    \"\"\"\n    calc_list_path = search_calc_list(filepath)\n    calc_dict = parse_calc_list(calc_list_path)\n\n    encountered_calcs: Dict[str, Dict[str, str]] = {}\n    encountered_locs: Dict[str, Dict[str, str]] = {}\n\n    calc_pattern = re.compile(r'\"(CALC\\\\\\\\[^\"]+)\"')\n\n    def replace_calc_match(match: re.Match) -&gt; str:\n        edm_pv = match.group(1)\n        if edm_pv not in encountered_calcs:\n            full_url = translate_calc_pv_to_pydm(edm_pv, calc_dict=calc_dict)\n            short_url = full_url.split(\"?\", 1)[0]\n            encountered_calcs[edm_pv] = {\"full\": full_url, \"short\": short_url}\n            return full_url\n        else:\n            return encountered_calcs[edm_pv][\"short\"]\n\n    new_content = calc_pattern.sub(replace_calc_match, edm_content)\n\n    # loc_pattern = re.compile(r'LOC\\\\+[^=]+=[dies]:[^\"]*')]\n    loc_pattern = re.compile(r'\"(LOC\\\\[^\"]+)\"')\n\n    def replace_loc_match(match: re.Match) -&gt; str:\n        edm_pv = match.group(1)\n        if edm_pv not in encountered_locs:\n            if \"=\" not in edm_pv:  # For case when calling pvs (with no =)\n                cleaned_pv = re.sub(r\"^LOC\\\\+\", \"\", edm_pv)\n                full_url = f\"loc://{cleaned_pv}\"\n                short_url = full_url\n            else:\n                full_url = loc_conversion(edm_pv)  # TODO: remove the ifs later\n                if full_url:\n                    short_url = full_url.split(\"?\", 1)[0]\n                else:\n                    full_url, short_url = \"\", \"\"\n            encountered_locs[edm_pv] = {\"full\": full_url, \"short\": short_url}\n            return full_url\n        elif \"=\" in edm_pv:\n            return encountered_locs[edm_pv][\"full\"]\n        return encountered_locs[edm_pv][\"short\"]\n\n    new_content = loc_pattern.sub(replace_loc_match, new_content)\n\n    return new_content, encountered_calcs, encountered_locs\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.search_calc_list","title":"<code>search_calc_list(file_path)</code>","text":"<p>search for a calc.list file and return the path if found, returns None if no calc.list exists.</p> <p>This function reads a file, filters out comment lines (lines starting with '#') and empty lines, and assumes each definition in the file is specified by two consecutive non-comment lines:</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.search_calc_list--parameters","title":"Parameters","text":"<p>file_path : str     The path to a file whose directory will be searched for 'calc.list'.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.search_calc_list--returns","title":"Returns","text":"<p>Optional[str]     The full path to the found 'calc.list' file, in either the local directory or in $EDMFILES, as a string if it exists;     otherwise, None.</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def search_calc_list(file_path: str) -&gt; str:\n    \"\"\"\n    search for a calc.list file and return the path if found, returns None if no calc.list exists.\n\n    This function reads a file, filters out comment lines (lines starting with\n    '#') and empty lines, and assumes each definition in the file is specified\n    by two consecutive non-comment lines:\n\n    Parameters\n    ----------\n    file_path : str\n        The path to a file whose directory will be searched for 'calc.list'.\n\n    Returns\n    -------\n    Optional[str]\n        The full path to the found 'calc.list' file, in either the local directory or in $EDMFILES, as a string if it exists;\n        otherwise, None.\n    \"\"\"\n    directory = os.path.dirname(file_path)\n    local_calc_list = os.path.join(directory, \"calc.list\")\n\n    if os.path.isfile(local_calc_list):\n        return directory\n\n    edmfiles = os.environ.get(\"EDMFILES\", \"\")\n    global_calc_list = os.path.join(edmfiles, \"calc.list\")\n\n    if edmfiles and os.path.isfile(global_calc_list):\n        return global_calc_list\n\n    return None\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.search_color_list","title":"<code>search_color_list(cli_color_file=None)</code>","text":"<p>Attempt to find the EDM color file by the following priority:</p> <ol> <li>CLI argument (cli_color_file), if provided.</li> <li>EDMCOLORFILE env variable (absolute path).</li> <li>EDMFILES env variable + \"colors.list\".</li> <li>Default path: \"/etc/edm/colors.list\".</li> </ol>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.search_color_list--parameters","title":"Parameters","text":"<p>cli_color_file : str or None, optional     A file path passed via command line argument.     If this is provided and valid, it overrides other checks.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.search_color_list--returns","title":"Returns","text":"<p>str or None     The path to the EDM color file if found, else None.</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def search_color_list(cli_color_file=None) -&gt; str | None:\n    \"\"\"\n    Attempt to find the EDM color file by the following priority:\n\n    1. CLI argument (cli_color_file), if provided.\n    2. EDMCOLORFILE env variable (absolute path).\n    3. EDMFILES env variable + \"colors.list\".\n    4. Default path: \"/etc/edm/colors.list\".\n\n    Parameters\n    ----------\n    cli_color_file : str or None, optional\n        A file path passed via command line argument.\n        If this is provided and valid, it overrides other checks.\n\n    Returns\n    -------\n    str or None\n        The path to the EDM color file if found, else None.\n    \"\"\"\n    if cli_color_file and os.path.isfile(cli_color_file):\n        return cli_color_file\n\n    edmc = os.environ.get(\"EDMCOLORFILE\")\n    if edmc and os.path.isfile(edmc):\n        return edmc\n\n    edmfiles = os.environ.get(\"EDMFILES\")\n    if edmfiles:\n        candidate = os.path.join(edmfiles, \"colors.list\")\n        if os.path.isfile(candidate):\n            return candidate\n\n    default_path = \"/etc/edm/colors.list\"\n    if os.path.isfile(default_path):\n        return default_path\n\n    return None\n</code></pre>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.translate_calc_pv_to_pydm","title":"<code>translate_calc_pv_to_pydm(edm_pv, calc_dict=None, default_prefix='ca://')</code>","text":"<p>Translate an EDM-style CALC PV (e.g., 'CALC\\sum(pv1, pv2)') into a PyDM calc plugin address, e.g.:</p> <p>calc://my_variable_name?A=channel://pv1&amp;B=channel://pv2&amp;expr=A+B</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.translate_calc_pv_to_pydm--parameters","title":"Parameters","text":"<p>edm_pv : str     The CALC PV in EDM syntax. For instance, \"CALC\\sum(pv1, pv2)\"     or \"CALC{A-B}(myPv, 10.5)\". calc_dict : dict, optional     A dictionary mapping calculation names to (rewrite_rule, expression).     Typically from <code>parse_calc_list()</code>. This is required if the CALC PV     references a named calc (e.g. 'sum') that is defined in a calc.list file.     If the CALC PV uses an inline expression ({A+B}), this dictionary     may be omitted. default_prefix : str, optional     A prefix to apply to each argument if it doesn't already include a protocol.     Defaults to 'channel://'.</p>"},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.translate_calc_pv_to_pydm--returns","title":"Returns","text":"<p>str     A PyDM calc plugin address string in the format:     'calc://?A=channel://pv1&amp;B=channel://pv2&amp;expr=A+B'."},{"location":"reference/edm/parser_helpers/#edm.parser_helpers.translate_calc_pv_to_pydm--raises","title":"Raises","text":"<p>ValueError     If the named calculation does not exist in the provided <code>calc_dict</code>.</p> Source code in <code>pydmconverter/edm/parser_helpers.py</code> <pre><code>def translate_calc_pv_to_pydm(\n    edm_pv: str,\n    calc_dict: Optional[Dict[str, Tuple[Optional[str], Optional[str]]]] = None,\n    default_prefix: str = \"ca://\",\n) -&gt; str:\n    \"\"\"\n    Translate an EDM-style CALC PV (e.g., 'CALC\\\\sum(pv1, pv2)') into\n    a PyDM calc plugin address, e.g.:\n\n      calc://my_variable_name?A=channel://pv1&amp;B=channel://pv2&amp;expr=A+B\n\n    Parameters\n    ----------\n    edm_pv : str\n        The CALC PV in EDM syntax. For instance, \"CALC\\\\sum(pv1, pv2)\"\n        or \"CALC\\\\{A-B}(myPv, 10.5)\".\n    calc_dict : dict, optional\n        A dictionary mapping calculation names to (rewrite_rule, expression).\n        Typically from `parse_calc_list()`. This is required if the CALC PV\n        references a named calc (e.g. 'sum') that is defined in a calc.list file.\n        If the CALC PV uses an inline expression ({A+B}), this dictionary\n        may be omitted.\n    default_prefix : str, optional\n        A prefix to apply to each argument if it doesn't already include a protocol.\n        Defaults to 'channel://'.\n\n    Returns\n    -------\n    str\n        A PyDM calc plugin address string in the format:\n        'calc://&lt;identifier&gt;?A=channel://pv1&amp;B=channel://pv2&amp;expr=A+B'.\n\n    Raises\n    ------\n    ValueError\n        If the named calculation does not exist in the provided `calc_dict`.\n    \"\"\"\n    if calc_dict is None:\n        calc_dict = {}\n    name_or_expr, arg_list, is_inline_expr = parse_calc_pv(edm_pv)\n\n    if is_inline_expr:\n        expression = name_or_expr\n        # identifier = \"inline_expr\"\n        identifier = f\"calc_{hash(edm_pv)}\"\n    else:\n        calc_name = name_or_expr\n        if calc_name == \"sum2\":  # convert sum2 to sum (sum2 is not in calc_dict)\n            calc_name = \"sum\"\n        if calc_name not in calc_dict:\n            print(calc_dict)\n            raise ValueError(f\"Calculation '{calc_name}' is not defined in calc_dict. {arg_list}\")\n            # logger.warning(f\"Calculation '{calc_name}' is not defined in calc_dict. {arg_list}\")\n            # return \"failed CALC\"\n        rewrite_rule, expression = calc_dict[calc_name]\n        if expression is None:\n            raise ValueError(f\"Calculation '{calc_name}' in calc_dict has no expression defined.\")\n\n        if rewrite_rule:\n            arg_list = apply_rewrite_rule(rewrite_rule, arg_list)\n\n        identifier = calc_name\n\n    expression = reformat_calc_expression(expression)\n    letters = \"ABCDEFGHIJKL\"\n    var_map = {}\n    for i, arg in enumerate(arg_list):\n        if i &lt; len(letters):\n            var_map[letters[i]] = arg\n\n    query_pairs = []\n    for letter, arg_val in var_map.items():\n        if not any(arg_val.startswith(proto) for proto in (\"ca://\", \"pva://\", \"channel://\")):\n            arg_val = f\"{default_prefix}{arg_val}\"\n        query_pairs.append(f\"{letter}={arg_val}\")\n\n    query_pairs.append(f\"expr={expression}\")\n\n    query_str = \"&amp;\".join(query_pairs)\n    pydm_calc_address = f\"calc://{identifier}?{query_str}\"\n\n    return pydm_calc_address\n</code></pre>"}]}